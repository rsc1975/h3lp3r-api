// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

function delay(ms, options = {}) {
    const { signal  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve, reject)=>{
        const abort = ()=>{
            clearTimeout(i);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
    });
}
const ERROR_SERVER_CLOSED = "Server closed";
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
class Server {
    #port;
    #host;
    #handler;
    #closed = false;
    #listeners = new Set();
    #httpConnections = new Set();
    #onError;
    constructor(serverInit){
        this.#port = serverInit.port;
        this.#host = serverInit.hostname;
        this.#handler = serverInit.handler;
        this.#onError = serverInit.onError ?? function(error) {
            console.error(error);
            return new Response("Internal Server Error", {
                status: 500
            });
        };
    }
    async serve(listener) {
        if (this.#closed) {
            throw new Deno.errors.Http(ERROR_SERVER_CLOSED);
        }
        this.#trackListener(listener);
        try {
            return await this.#accept(listener);
        } finally{
            this.#untrackListener(listener);
            try {
                listener.close();
            } catch  {}
        }
    }
    async listenAndServe() {
        if (this.#closed) {
            throw new Deno.errors.Http(ERROR_SERVER_CLOSED);
        }
        const listener = Deno.listen({
            port: this.#port ?? 80,
            hostname: this.#host ?? "0.0.0.0",
            transport: "tcp"
        });
        return await this.serve(listener);
    }
    async listenAndServeTls(certFile, keyFile) {
        if (this.#closed) {
            throw new Deno.errors.Http(ERROR_SERVER_CLOSED);
        }
        const listener = Deno.listenTls({
            port: this.#port ?? 443,
            hostname: this.#host ?? "0.0.0.0",
            certFile,
            keyFile,
            transport: "tcp"
        });
        return await this.serve(listener);
    }
    close() {
        if (this.#closed) {
            throw new Deno.errors.Http(ERROR_SERVER_CLOSED);
        }
        this.#closed = true;
        for (const listener of this.#listeners){
            try {
                listener.close();
            } catch  {}
        }
        this.#listeners.clear();
        for (const httpConn of this.#httpConnections){
            this.#closeHttpConn(httpConn);
        }
        this.#httpConnections.clear();
    }
    get closed() {
        return this.#closed;
    }
    get addrs() {
        return Array.from(this.#listeners).map((listener)=>listener.addr);
    }
    async #respond(requestEvent, httpConn, connInfo) {
        let response;
        try {
            response = await this.#handler(requestEvent.request, connInfo);
        } catch (error) {
            response = await this.#onError(error);
        }
        try {
            await requestEvent.respondWith(response);
        } catch  {
            return this.#closeHttpConn(httpConn);
        }
    }
    async #serveHttp(httpConn1, connInfo1) {
        while(!this.#closed){
            let requestEvent1;
            try {
                requestEvent1 = await httpConn1.nextRequest();
            } catch  {
                break;
            }
            if (requestEvent1 === null) {
                break;
            }
            this.#respond(requestEvent1, httpConn1, connInfo1);
        }
        this.#closeHttpConn(httpConn1);
    }
    async #accept(listener) {
        let acceptBackoffDelay;
        while(!this.#closed){
            let conn;
            try {
                conn = await listener.accept();
            } catch (error1) {
                if (error1 instanceof Deno.errors.BadResource || error1 instanceof Deno.errors.InvalidData || error1 instanceof Deno.errors.UnexpectedEof || error1 instanceof Deno.errors.ConnectionReset || error1 instanceof Deno.errors.NotConnected) {
                    if (!acceptBackoffDelay) {
                        acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
                    } else {
                        acceptBackoffDelay *= 2;
                    }
                    if (acceptBackoffDelay >= 1000) {
                        acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
                    }
                    await delay(acceptBackoffDelay);
                    continue;
                }
                throw error1;
            }
            acceptBackoffDelay = undefined;
            let httpConn2;
            try {
                httpConn2 = Deno.serveHttp(conn);
            } catch  {
                continue;
            }
            this.#trackHttpConnection(httpConn2);
            const connInfo2 = {
                localAddr: conn.localAddr,
                remoteAddr: conn.remoteAddr
            };
            this.#serveHttp(httpConn2, connInfo2);
        }
    }
     #closeHttpConn(httpConn3) {
        this.#untrackHttpConnection(httpConn3);
        try {
            httpConn3.close();
        } catch  {}
    }
     #trackListener(listener1) {
        this.#listeners.add(listener1);
    }
     #untrackListener(listener2) {
        this.#listeners.delete(listener2);
    }
     #trackHttpConnection(httpConn4) {
        this.#httpConnections.add(httpConn4);
    }
     #untrackHttpConnection(httpConn5) {
        this.#httpConnections.delete(httpConn5);
    }
}
function hostnameForDisplay(hostname) {
    return hostname === "0.0.0.0" ? "localhost" : hostname;
}
async function serve(handler, options = {}) {
    let port = options.port ?? 8000;
    const hostname = options.hostname ?? "0.0.0.0";
    const server = new Server({
        port,
        hostname,
        handler,
        onError: options.onError
    });
    options?.signal?.addEventListener("abort", ()=>server.close(), {
        once: true
    });
    const s = server.listenAndServe();
    port = server.addrs[0].port;
    if ("onListen" in options) {
        options.onListen?.({
            port,
            hostname
        });
    } else {
        console.log(`Listening on http://${hostnameForDisplay(hostname)}:${port}/`);
    }
    return await s;
}
const parse = (cookie)=>{
    const pairs = cookie.split(/;\s*/g);
    const parsedCookie = {};
    for(let i = 0, len = pairs.length; i < len; i++){
        const pair = pairs[i].split(/\s*=\s*([^\s]+)/);
        parsedCookie[pair[0]] = decodeURIComponent(pair[1]);
    }
    return parsedCookie;
};
const serialize = (name, value, opt = {})=>{
    value = encodeURIComponent(value);
    let cookie = `${name}=${value}`;
    if (opt.maxAge) {
        cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
    }
    if (opt.domain) {
        cookie += '; Domain=' + opt.domain;
    }
    if (opt.path) {
        cookie += '; Path=' + opt.path;
    }
    if (opt.expires) {
        cookie += '; Expires=' + opt.expires.toUTCString();
    }
    if (opt.httpOnly) {
        cookie += '; HttpOnly';
    }
    if (opt.secure) {
        cookie += '; Secure';
    }
    if (opt.sameSite) {
        cookie += `; SameSite=${opt.sameSite}`;
    }
    return cookie;
};
const URL_REGEXP = /^https?:\/\/[a-zA-Z0-9\-\.:]+(\/?[^?#]*)/;
const splitPath = (path)=>{
    const paths = path.split(/\//);
    if (paths[0] === '') {
        paths.shift();
    }
    return paths;
};
const patternCache = {};
const getPattern = (label)=>{
    if (label === '*') {
        return '*';
    }
    const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    if (match) {
        if (!patternCache[label]) {
            if (match[2]) {
                patternCache[label] = [
                    label,
                    match[1],
                    new RegExp('^' + match[2] + '$')
                ];
            } else {
                patternCache[label] = [
                    label,
                    match[1],
                    true
                ];
            }
        }
        return patternCache[label];
    }
    return null;
};
const getPathFromURL = (url, strict = true)=>{
    const queryIndex = url.indexOf('?');
    const result = url.substring(url.indexOf('/', 8), queryIndex === -1 ? url.length : queryIndex);
    if (strict === false && result.endsWith('/')) {
        return result.slice(0, -1);
    }
    return result;
};
const isAbsoluteURL = (url)=>{
    const match = url.match(URL_REGEXP);
    if (match) {
        return true;
    }
    return false;
};
const mergePath = (...paths)=>{
    let p = '';
    let endsWithSlash = false;
    for (let path of paths){
        if (p.endsWith('/')) {
            p = p.slice(0, -1);
            endsWithSlash = true;
        }
        if (!path.startsWith('/')) {
            path = `/${path}`;
        }
        if (path === '/' && endsWithSlash) {
            p = `${p}/`;
        } else if (path !== '/') {
            p = `${p}${path}`;
        }
        if (path === '/' && p === '') {
            p = '/';
        }
    }
    return p;
};
class HonoContext {
    req;
    env;
    finalized;
    _status = 200;
    _executionCtx;
    _pretty = false;
    _prettySpace = 2;
    _map;
    _headers;
    _res;
    notFoundHandler;
    constructor(req, env = undefined, executionCtx = undefined, notFoundHandler = ()=>new Response()){
        this._executionCtx = executionCtx;
        this.req = req;
        this.env = env ? env : {};
        this.notFoundHandler = notFoundHandler;
        this.finalized = false;
    }
    get event() {
        if (this._executionCtx instanceof FetchEvent) {
            return this._executionCtx;
        } else {
            throw Error('This context has no FetchEvent');
        }
    }
    get executionCtx() {
        if (this._executionCtx) {
            return this._executionCtx;
        } else {
            throw Error('This context has no ExecutionContext');
        }
    }
    get res() {
        return this._res ||= new Response();
    }
    set res(_res) {
        this._res = _res;
        this.finalized = true;
    }
    header(name, value) {
        this._headers ||= {};
        this._headers[name.toLowerCase()] = value;
        if (this.finalized) {
            this.res.headers.set(name, value);
        }
    }
    status(status) {
        this._status = status;
    }
    set(key, value) {
        this._map ||= {};
        this._map[key] = value;
    }
    get(key) {
        if (!this._map) {
            return undefined;
        }
        return this._map[key];
    }
    pretty(prettyJSON, space = 2) {
        this._pretty = prettyJSON;
        this._prettySpace = space;
    }
    newResponse(data, status, headers = {}) {
        const _headers = {
            ...this._headers
        };
        if (this._res) {
            this._res.headers.forEach((v, k)=>{
                _headers[k] = v;
            });
        }
        return new Response(data, {
            status: status || this._status || 200,
            headers: {
                ..._headers,
                ...headers
            }
        });
    }
    body(data, status = this._status, headers = {}) {
        return this.newResponse(data, status, headers);
    }
    text(text, status = this._status, headers = {}) {
        headers['content-type'] = 'text/plain; charset=UTF-8';
        return this.body(text, status, headers);
    }
    json(object, status = this._status, headers = {}) {
        const body = this._pretty ? JSON.stringify(object, null, this._prettySpace) : JSON.stringify(object);
        headers['content-type'] = 'application/json; charset=UTF-8';
        return this.body(body, status, headers);
    }
    html(html, status = this._status, headers = {}) {
        headers['content-type'] = 'text/html; charset=UTF-8';
        return this.body(html, status, headers);
    }
    redirect(location, status = 302) {
        if (!isAbsoluteURL(location)) {
            const url = new URL(this.req.url);
            url.pathname = location;
            location = url.toString();
        }
        return this.newResponse(null, status, {
            Location: location
        });
    }
    cookie(name, value, opt) {
        const cookie = serialize(name, value, opt);
        this.header('set-cookie', cookie);
    }
    notFound() {
        return this.notFoundHandler(this);
    }
}
const compose = (middleware, onError, onNotFound)=>{
    const middlewareLength = middleware.length;
    return (context, next)=>{
        let index = -1;
        return dispatch(0);
        async function dispatch(i) {
            if (i <= index) {
                return Promise.reject(new Error('next() called multiple times'));
            }
            let handler = middleware[i];
            index = i;
            if (i === middlewareLength && next) handler = next;
            if (!handler) {
                if (context instanceof HonoContext && context.finalized === false && onNotFound) {
                    context.res = await onNotFound(context);
                }
                return Promise.resolve(context);
            }
            return Promise.resolve(handler(context, ()=>dispatch(i + 1))).then((res)=>{
                if (res && context instanceof HonoContext) {
                    context.res = res;
                }
                return context;
            }).catch((err)=>{
                if (context instanceof HonoContext && onError) {
                    if (err instanceof Error) {
                        context.res = onError(err, context);
                    }
                    return context;
                } else {
                    throw err;
                }
            });
        }
    };
};
const parseBody = async (r)=>{
    const contentType = r.headers.get('Content-Type') || '';
    if (contentType.includes('application/json')) {
        let body = {};
        try {
            body = await r.json();
        } catch  {}
        return body;
    } else if (contentType.includes('application/text')) {
        return await r.text();
    } else if (contentType.startsWith('text')) {
        return await r.text();
    } else if (contentType.includes('form')) {
        const form = {};
        const data = [
            ...await r.formData()
        ].reduce((acc, cur)=>{
            acc[cur[0]] = cur[1];
            return acc;
        }, form);
        return data;
    }
    const arrayBuffer = await r.arrayBuffer();
    return arrayBuffer;
};
function extendRequestPrototype() {
    if (!!Request.prototype.param) {
        return;
    }
    Request.prototype.param = function(key) {
        if (this.paramData) {
            if (key) {
                return this.paramData[key];
            } else {
                return this.paramData;
            }
        }
        return null;
    };
    Request.prototype.header = function(name) {
        if (name) {
            return this.headers.get(name);
        } else {
            const result = {};
            for (const [key, value] of this.headers){
                result[key] = value;
            }
            return result;
        }
    };
    Request.prototype.query = function(key) {
        const url = new URL(this.url);
        if (key) {
            return url.searchParams.get(key);
        } else {
            const result = {};
            for (const key1 of url.searchParams.keys()){
                result[key1] = url.searchParams.get(key1) || '';
            }
            return result;
        }
    };
    Request.prototype.queries = function(key) {
        const url = new URL(this.url);
        if (key) {
            return url.searchParams.getAll(key);
        } else {
            const result = {};
            for (const key1 of url.searchParams.keys()){
                result[key1] = url.searchParams.getAll(key1);
            }
            return result;
        }
    };
    Request.prototype.cookie = function(key) {
        const cookie = this.headers.get('Cookie') || '';
        const obj = parse(cookie);
        if (key) {
            const value = obj[key];
            return value;
        } else {
            return obj;
        }
    };
    Request.prototype.parseBody = function() {
        if (!this.parsedBody) {
            this.parsedBody = parseBody(this);
        }
        return this.parsedBody;
    };
}
const METHOD_NAME_ALL = 'ALL';
const METHOD_NAME_ALL_LOWERCASE = 'all';
function findParam(node, name) {
    for(let i = 0, len = node.patterns.length; i < len; i++){
        if (typeof node.patterns[i] === 'object' && node.patterns[i][1] === name) {
            return true;
        }
    }
    const nodes = Object.values(node.children);
    for(let i1 = 0, len1 = nodes.length; i1 < len1; i1++){
        if (findParam(nodes[i1], name)) {
            return true;
        }
    }
    return false;
}
class Node {
    methods;
    children;
    patterns;
    order = 0;
    name;
    handlerSetCache;
    constructor(method, handler, children){
        this.children = children || {};
        this.methods = [];
        this.name = '';
        if (method && handler) {
            const m = {};
            m[method] = {
                handler: handler,
                score: 0,
                name: this.name
            };
            this.methods = [
                m
            ];
        }
        this.patterns = [];
        this.handlerSetCache = {};
    }
    insert(method, path, handler) {
        this.name = `${method} ${path}`;
        this.order = ++this.order;
        let curNode = this;
        const parts = splitPath(path);
        const parentPatterns = [];
        const errorMessage = (name)=>{
            return `Duplicate param name, use another name instead of '${name}' - ${method} ${path} <--- '${name}'`;
        };
        for(let i = 0, len = parts.length; i < len; i++){
            const p = parts[i];
            if (Object.keys(curNode.children).includes(p)) {
                parentPatterns.push(...curNode.patterns);
                curNode = curNode.children[p];
                continue;
            }
            curNode.children[p] = new Node();
            const pattern = getPattern(p);
            if (pattern) {
                if (typeof pattern === 'object') {
                    for(let j = 0, len1 = parentPatterns.length; j < len1; j++){
                        if (typeof parentPatterns[j] === 'object' && parentPatterns[j][1] === pattern[1]) {
                            throw new Error(errorMessage(pattern[1]));
                        }
                    }
                    if (Object.values(curNode.children).some((n)=>findParam(n, pattern[1]))) {
                        throw new Error(errorMessage(pattern[1]));
                    }
                }
                curNode.patterns.push(pattern);
                parentPatterns.push(...curNode.patterns);
            }
            parentPatterns.push(...curNode.patterns);
            curNode = curNode.children[p];
        }
        if (!curNode.methods.length) {
            curNode.methods = [];
        }
        const m = {};
        const handlerSet = {
            handler: handler,
            name: this.name,
            score: this.order
        };
        m[method] = handlerSet;
        curNode.methods.push(m);
        return curNode;
    }
    getHandlerSets(node, method, wildcard) {
        return node.handlerSetCache[`${method}:${wildcard ? '1' : '0'}`] ||= (()=>{
            const handlerSets = [];
            node.methods.map((m)=>{
                const handlerSet = m[method] || m[METHOD_NAME_ALL];
                if (handlerSet !== undefined) {
                    const hs = {
                        ...handlerSet
                    };
                    handlerSets.push(hs);
                    return;
                }
            });
            return handlerSets;
        })();
    }
    search(method, path) {
        const handlerSets = [];
        const params = {};
        const curNode = this;
        let curNodes = [
            curNode
        ];
        const parts = splitPath(path);
        for(let i = 0, len = parts.length; i < len; i++){
            const part = parts[i];
            const isLast = i === len - 1;
            const tempNodes = [];
            let matched = false;
            for(let j = 0, len2 = curNodes.length; j < len2; j++){
                const node = curNodes[j];
                const nextNode = node.children[part];
                if (nextNode) {
                    if (isLast === true) {
                        if (nextNode.children['*']) {
                            handlerSets.push(...this.getHandlerSets(nextNode.children['*'], method, true));
                        }
                        handlerSets.push(...this.getHandlerSets(nextNode, method));
                        matched = true;
                    }
                    tempNodes.push(nextNode);
                }
                for(let k = 0, len3 = node.patterns.length; k < len3; k++){
                    const pattern = node.patterns[k];
                    if (pattern === '*') {
                        const astNode = node.children['*'];
                        if (astNode) {
                            handlerSets.push(...this.getHandlerSets(astNode, method));
                            tempNodes.push(astNode);
                        }
                        continue;
                    }
                    if (part === '') continue;
                    const [key, name, matcher] = pattern;
                    if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {
                        if (typeof key === 'string') {
                            if (isLast === true) {
                                handlerSets.push(...this.getHandlerSets(node.children[key], method));
                            }
                            tempNodes.push(node.children[key]);
                        }
                        if (typeof name === 'string' && !matched) {
                            params[name] = part;
                        }
                    }
                }
            }
            curNodes = tempNodes;
        }
        if (handlerSets.length <= 0) return null;
        const handlers = handlerSets.sort((a, b)=>{
            return a.score - b.score;
        }).map((s)=>{
            return s.handler;
        });
        return {
            handlers,
            params
        };
    }
}
class TrieRouter {
    node;
    constructor(){
        this.node = new Node();
    }
    add(method, path, handler) {
        this.node.insert(method, path, handler);
    }
    match(method, path) {
        return this.node.search(method, path);
    }
}
const methods = [
    'get',
    'post',
    'put',
    'delete',
    'head',
    'options',
    'patch'
];
function defineDynamicClass() {
    return class {
    };
}
class Hono extends defineDynamicClass() {
    router = new TrieRouter();
    strict = true;
    _tempPath = '';
    path = '/';
    routes = [];
    constructor(init = {}){
        super();
        extendRequestPrototype();
        const allMethods = [
            ...methods,
            METHOD_NAME_ALL_LOWERCASE
        ];
        allMethods.map((method)=>{
            this[method] = (args1, ...args)=>{
                if (typeof args1 === 'string') {
                    this.path = args1;
                } else {
                    this.addRoute(method, this.path, args1);
                }
                args.map((handler)=>{
                    if (typeof handler !== 'string') {
                        this.addRoute(method, this.path, handler);
                    }
                });
                return this;
            };
        });
        Object.assign(this, init);
    }
    notFoundHandler = (c)=>{
        const message = '404 Not Found';
        return c.text(message, 404);
    };
    errorHandler = (err, c)=>{
        console.error(`${err.stack || err.message}`);
        const message = 'Internal Server Error';
        return c.text(message, 500);
    };
    route(path, app) {
        this._tempPath = path;
        if (app) {
            app.routes.map((r)=>{
                this.addRoute(r.method, r.path, r.handler);
            });
            this._tempPath = '';
        }
        return this;
    }
    use(arg1, ...handlers) {
        if (typeof arg1 === 'string') {
            this.path = arg1;
        } else {
            handlers.unshift(arg1);
        }
        handlers.map((handler)=>{
            this.addRoute(METHOD_NAME_ALL, this.path, handler);
        });
        return this;
    }
    onError(handler) {
        this.errorHandler = handler;
        return this;
    }
    notFound(handler) {
        this.notFoundHandler = handler;
        return this;
    }
    addRoute(method, path, handler) {
        method = method.toUpperCase();
        if (this._tempPath) {
            path = mergePath(this._tempPath, path);
        }
        this.router.add(method, path, handler);
        const r = {
            path: path,
            method: method,
            handler: handler
        };
        this.routes.push(r);
    }
    matchRoute(method, path) {
        return this.router.match(method, path);
    }
    async dispatch(request, eventOrExecutionCtx, env) {
        const path = getPathFromURL(request.url, this.strict);
        const method = request.method;
        const result = this.matchRoute(method, path);
        request.paramData = result?.params;
        const handlers = result ? result.handlers : [
            this.notFoundHandler
        ];
        const c = new HonoContext(request, env, eventOrExecutionCtx, this.notFoundHandler);
        const composed = compose(handlers, this.errorHandler, this.notFoundHandler);
        let context;
        try {
            context = await composed(c);
            if (!context.finalized) {
                throw new Error('Context is not finalized. You may forget returning Response object or `await next()`');
            }
        } catch (err) {
            if (err instanceof Error) {
                return this.errorHandler(err, c);
            }
            throw err;
        }
        return context.res;
    }
    handleEvent(event) {
        return this.dispatch(event.request, event);
    }
    fetch = (request, env, executionCtx)=>{
        return this.dispatch(request, executionCtx, env);
    };
    request(input, requestInit) {
        const req = input instanceof Request ? input : new Request(input, requestInit);
        return this.dispatch(req);
    }
}
const LABEL_REG_EXP_STR = '[^/]+';
const ONLY_WILDCARD_REG_EXP_STR = '.*';
const TAIL_WILDCARD_REG_EXP_STR = '(?:|/.*)';
function compareKey(a, b) {
    if (a.length === 1) {
        return b.length === 1 ? a < b ? -1 : 1 : -1;
    }
    if (b.length === 1) {
        return 1;
    }
    if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
        return 1;
    } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
        return -1;
    }
    if (a === LABEL_REG_EXP_STR) {
        return 1;
    } else if (b === LABEL_REG_EXP_STR) {
        return -1;
    }
    return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
class Node1 {
    index;
    varIndex;
    children = {};
    reverse;
    constructor({ reverse  } = {
        reverse: false
    }){
        this.reverse = reverse;
    }
    newChildNode() {
        return new Node1({
            reverse: this.reverse
        });
    }
    insert(tokens, index, paramMap, context) {
        if (tokens.length === 0) {
            this.index = index;
            return;
        }
        const [token, ...restTokens] = tokens;
        const pattern = token === '*' ? restTokens.length === 0 ? [
            '',
            '',
            ONLY_WILDCARD_REG_EXP_STR
        ] : [
            '',
            '',
            LABEL_REG_EXP_STR
        ] : token === '/*' ? [
            '',
            '',
            TAIL_WILDCARD_REG_EXP_STR
        ] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
        let node;
        if (pattern) {
            const name = pattern[1];
            const regexpStr = pattern[2] || LABEL_REG_EXP_STR;
            node = this.children[regexpStr];
            if (!node) {
                node = this.children[regexpStr] = this.newChildNode();
                if (name !== '') {
                    node.varIndex = context.varIndex++;
                }
            }
            if (name !== '') {
                paramMap.push([
                    name,
                    node.varIndex
                ]);
            }
        } else {
            node = this.children[token] ||= this.newChildNode();
        }
        node.insert(restTokens, index, paramMap, context);
    }
    buildRegExpStr() {
        let childKeys = Object.keys(this.children).sort(compareKey);
        if (this.reverse) {
            childKeys = childKeys.reverse();
        }
        const strList = childKeys.map((k)=>{
            const c = this.children[k];
            return (typeof c.varIndex === 'number' ? `(${k})@${c.varIndex}` : k) + c.buildRegExpStr();
        });
        if (typeof this.index === 'number') {
            strList.unshift(`#${this.index}`);
        }
        if (strList.length === 0) {
            return '';
        }
        if (strList.length === 1) {
            return strList[0];
        }
        return '(?:' + strList.join('|') + ')';
    }
}
const createHash = async (data, algorithm)=>{
    let sourceBuffer;
    if (data instanceof ReadableStream) {
        let body = '';
        const reader = data.getReader();
        await reader?.read().then(async (chuck)=>{
            const value = await createHash(chuck.value || '', algorithm);
            body += value;
        });
        return body;
    }
    if (ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
        sourceBuffer = data;
    } else {
        if (typeof data === 'object') {
            data = JSON.stringify(data);
        }
        sourceBuffer = new TextEncoder().encode(String(data));
    }
    if (crypto && crypto.subtle) {
        const buffer = await crypto.subtle.digest({
            name: algorithm.name
        }, sourceBuffer);
        const hash = Array.prototype.map.call(new Uint8Array(buffer), (x)=>('00' + x.toString(16)).slice(-2)).join('');
        return hash;
    }
    return null;
};
const hexTable = new TextEncoder().encode("0123456789abcdef");
function errInvalidByte(__byte) {
    return new Error("encoding/hex: invalid byte: " + new TextDecoder().decode(new Uint8Array([
        __byte
    ])));
}
function errLength() {
    return new Error("encoding/hex: odd length hex string");
}
function fromHexChar(__byte) {
    if (48 <= __byte && __byte <= 57) return __byte - 48;
    if (97 <= __byte && __byte <= 102) return __byte - 97 + 10;
    if (65 <= __byte && __byte <= 70) return __byte - 65 + 10;
    throw errInvalidByte(__byte);
}
function encodedLen(n) {
    return n * 2;
}
function encode(src) {
    const dst = new Uint8Array(encodedLen(src.length));
    for(let i = 0; i < dst.length; i++){
        const v = src[i];
        dst[i * 2] = hexTable[v >> 4];
        dst[i * 2 + 1] = hexTable[v & 0x0f];
    }
    return dst;
}
function encodeToString(src) {
    return new TextDecoder().decode(encode(src));
}
function decode(src) {
    const dst = new Uint8Array(decodedLen(src.length));
    for(let i = 0; i < dst.length; i++){
        const a = fromHexChar(src[i * 2]);
        const b = fromHexChar(src[i * 2 + 1]);
        dst[i] = a << 4 | b;
    }
    if (src.length % 2 == 1) {
        fromHexChar(src[dst.length * 2]);
        throw errLength();
    }
    return dst;
}
function decodedLen(x) {
    return x >>> 1;
}
function decodeString(s) {
    return decode(new TextEncoder().encode(s));
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode1(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode1(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
globalThis.Deno?.noColor ?? true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
TextDecoder;
TextEncoder;
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
const notImplementedEncodings = [
    "ascii",
    "binary",
    "latin1",
    "ucs2",
    "utf16le", 
];
function checkEncoding(encoding = "utf8", strict = true) {
    if (typeof encoding !== "string" || strict && encoding === "") {
        if (!strict) return "utf8";
        throw new TypeError(`Unkown encoding: ${encoding}`);
    }
    const normalized = normalizeEncoding(encoding);
    if (normalized === undefined) {
        throw new TypeError(`Unkown encoding: ${encoding}`);
    }
    if (notImplementedEncodings.includes(encoding)) {
        notImplemented(`"${encoding}" encoding`);
    }
    return normalized;
}
const encodingOps = {
    utf8: {
        byteLength: (string)=>new TextEncoder().encode(string).byteLength
    },
    ucs2: {
        byteLength: (string)=>string.length * 2
    },
    utf16le: {
        byteLength: (string)=>string.length * 2
    },
    latin1: {
        byteLength: (string)=>string.length
    },
    ascii: {
        byteLength: (string)=>string.length
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1
    }
};
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3d) bytes--;
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3d) bytes--;
    return bytes * 3 >>> 2;
}
class Buffer extends Uint8Array {
    static alloc(size, fill, encoding = "utf8") {
        if (typeof size !== "number") {
            throw new TypeError(`The "size" argument must be of type number. Received type ${typeof size}`);
        }
        const buf = new Buffer(size);
        if (size === 0) return buf;
        let bufFill;
        if (typeof fill === "string") {
            const clearEncoding = checkEncoding(encoding);
            if (typeof fill === "string" && fill.length === 1 && clearEncoding === "utf8") {
                buf.fill(fill.charCodeAt(0));
            } else bufFill = Buffer.from(fill, clearEncoding);
        } else if (typeof fill === "number") {
            buf.fill(fill);
        } else if (fill instanceof Uint8Array) {
            if (fill.length === 0) {
                throw new TypeError(`The argument "value" is invalid. Received ${fill.constructor.name} []`);
            }
            bufFill = fill;
        }
        if (bufFill) {
            if (bufFill.length > buf.length) {
                bufFill = bufFill.subarray(0, buf.length);
            }
            let offset = 0;
            while(offset < size){
                buf.set(bufFill, offset);
                offset += bufFill.length;
                if (offset + bufFill.length >= size) break;
            }
            if (offset !== size) {
                buf.set(bufFill.subarray(0, size - offset), offset);
            }
        }
        return buf;
    }
    static allocUnsafe(size) {
        return new Buffer(size);
    }
    static byteLength(string, encoding = "utf8") {
        if (typeof string != "string") return string.byteLength;
        encoding = normalizeEncoding(encoding) || "utf8";
        return encodingOps[encoding].byteLength(string);
    }
    static concat(list, totalLength) {
        if (totalLength == undefined) {
            totalLength = 0;
            for (const buf of list){
                totalLength += buf.length;
            }
        }
        const buffer = Buffer.allocUnsafe(totalLength);
        let pos = 0;
        for (const item of list){
            let buf1;
            if (!(item instanceof Buffer)) {
                buf1 = Buffer.from(item);
            } else {
                buf1 = item;
            }
            buf1.copy(buffer, pos);
            pos += buf1.length;
        }
        return buffer;
    }
    static from(value, offsetOrEncoding, length) {
        const offset = typeof offsetOrEncoding === "string" ? undefined : offsetOrEncoding;
        let encoding = typeof offsetOrEncoding === "string" ? offsetOrEncoding : undefined;
        if (typeof value == "string") {
            encoding = checkEncoding(encoding, false);
            if (encoding === "hex") return new Buffer(decodeString(value).buffer);
            if (encoding === "base64") return new Buffer(decode1(value).buffer);
            return new Buffer(new TextEncoder().encode(value).buffer);
        }
        return new Buffer(value, offset, length);
    }
    static isBuffer(obj) {
        return obj instanceof Buffer;
    }
    static isEncoding(encoding) {
        return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== undefined;
    }
    copy(targetBuffer, targetStart = 0, sourceStart = 0, sourceEnd = this.length) {
        const sourceBuffer = this.subarray(sourceStart, sourceEnd).subarray(0, Math.max(0, targetBuffer.length - targetStart));
        if (sourceBuffer.length === 0) return 0;
        targetBuffer.set(sourceBuffer, targetStart);
        return sourceBuffer.length;
    }
    equals(otherBuffer) {
        if (!(otherBuffer instanceof Uint8Array)) {
            throw new TypeError(`The "otherBuffer" argument must be an instance of Buffer or Uint8Array. Received type ${typeof otherBuffer}`);
        }
        if (this === otherBuffer) return true;
        if (this.byteLength !== otherBuffer.byteLength) return false;
        for(let i = 0; i < this.length; i++){
            if (this[i] !== otherBuffer[i]) return false;
        }
        return true;
    }
    readBigInt64BE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getBigInt64(offset);
    }
    readBigInt64LE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getBigInt64(offset, true);
    }
    readBigUInt64BE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getBigUint64(offset);
    }
    readBigUInt64LE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getBigUint64(offset, true);
    }
    readDoubleBE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getFloat64(offset);
    }
    readDoubleLE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getFloat64(offset, true);
    }
    readFloatBE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getFloat32(offset);
    }
    readFloatLE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getFloat32(offset, true);
    }
    readInt8(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt8(offset);
    }
    readInt16BE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt16(offset);
    }
    readInt16LE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt16(offset, true);
    }
    readInt32BE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt32(offset);
    }
    readInt32LE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt32(offset, true);
    }
    readUInt8(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint8(offset);
    }
    readUInt16BE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint16(offset);
    }
    readUInt16LE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint16(offset, true);
    }
    readUInt32BE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint32(offset);
    }
    readUInt32LE(offset = 0) {
        return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint32(offset, true);
    }
    slice(begin = 0, end = this.length) {
        return this.subarray(begin, end);
    }
    toJSON() {
        return {
            type: "Buffer",
            data: Array.from(this)
        };
    }
    toString(encoding = "utf8", start = 0, end = this.length) {
        encoding = checkEncoding(encoding);
        const b = this.subarray(start, end);
        if (encoding === "hex") return encodeToString(b);
        if (encoding === "base64") return encode1(b.buffer);
        return new TextDecoder(encoding).decode(b);
    }
    write(string, offset = 0, length = this.length) {
        return new TextEncoder().encodeInto(string, this.subarray(offset, offset + length)).written;
    }
    writeBigInt64BE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setBigInt64(offset, value);
        return offset + 4;
    }
    writeBigInt64LE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setBigInt64(offset, value, true);
        return offset + 4;
    }
    writeBigUInt64BE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setBigUint64(offset, value);
        return offset + 4;
    }
    writeBigUInt64LE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setBigUint64(offset, value, true);
        return offset + 4;
    }
    writeDoubleBE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setFloat64(offset, value);
        return offset + 8;
    }
    writeDoubleLE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setFloat64(offset, value, true);
        return offset + 8;
    }
    writeFloatBE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setFloat32(offset, value);
        return offset + 4;
    }
    writeFloatLE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setFloat32(offset, value, true);
        return offset + 4;
    }
    writeInt8(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setInt8(offset, value);
        return offset + 1;
    }
    writeInt16BE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setInt16(offset, value);
        return offset + 2;
    }
    writeInt16LE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setInt16(offset, value, true);
        return offset + 2;
    }
    writeInt32BE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setUint32(offset, value);
        return offset + 4;
    }
    writeInt32LE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setInt32(offset, value, true);
        return offset + 4;
    }
    writeUInt8(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setUint8(offset, value);
        return offset + 1;
    }
    writeUInt16BE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setUint16(offset, value);
        return offset + 2;
    }
    writeUInt16LE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setUint16(offset, value, true);
        return offset + 2;
    }
    writeUInt32BE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setUint32(offset, value);
        return offset + 4;
    }
    writeUInt32LE(value, offset = 0) {
        new DataView(this.buffer, this.byteOffset, this.byteLength).setUint32(offset, value, true);
        return offset + 4;
    }
}
const cors = (options)=>{
    const defaults = {
        origin: '*',
        allowMethods: [
            'GET',
            'HEAD',
            'PUT',
            'POST',
            'DELETE',
            'PATCH'
        ],
        allowHeaders: [],
        exposeHeaders: []
    };
    const opts = {
        ...defaults,
        ...options
    };
    return async (c, next)=>{
        await next();
        function set(key, value) {
            c.res.headers.append(key, value);
        }
        set('Access-Control-Allow-Origin', opts.origin);
        if (opts.origin !== '*') {
            set('Vary', 'Origin');
        }
        if (opts.credentials) {
            set('Access-Control-Allow-Credentials', 'true');
        }
        if (opts.exposeHeaders?.length) {
            set('Access-Control-Expose-Headers', opts.exposeHeaders.join(','));
        }
        if (c.req.method === 'OPTIONS') {
            if (opts.maxAge != null) {
                set('Access-Control-Max-Age', opts.maxAge.toString());
            }
            if (opts.allowMethods?.length) {
                set('Access-Control-Allow-Methods', opts.allowMethods.join(','));
            }
            let headers = opts.allowHeaders;
            if (!headers?.length) {
                const requestHeaders = c.req.headers.get('Access-Control-Request-Headers');
                if (requestHeaders) {
                    headers = requestHeaders.split(/\s*,\s*/);
                }
            }
            if (headers?.length) {
                set('Access-Control-Allow-Headers', headers.join(','));
                set('Vary', 'Access-Control-Request-Headers');
            }
            c.res.headers.delete('Content-Length');
            c.res.headers.delete('Content-Type');
            c.res = new Response(null, {
                headers: c.res.headers,
                status: 204,
                statusText: c.res.statusText
            });
        }
    };
};
const escapeRe = /[&<>"]/;
const escapeToBuffer = (str, buffer)=>{
    const match = str.search(escapeRe);
    if (match === -1) {
        buffer[0] += str;
        return;
    }
    let escape;
    let index;
    let lastIndex = 0;
    for(index = match; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escape = '&quot;';
                break;
            case 38:
                escape = '&amp;';
                break;
            case 60:
                escape = '&lt;';
                break;
            case 62:
                escape = '&gt;';
                break;
            default:
                continue;
        }
        buffer[0] += str.substring(lastIndex, index) + escape;
        lastIndex = index + 1;
    }
    buffer[0] += str.substring(lastIndex, index);
};
const emptyTags = [
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'keygen',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr', 
];
const booleanAttributes = [
    'allowfullscreen',
    'async',
    'autofocus',
    'autoplay',
    'checked',
    'controls',
    'default',
    'defer',
    'disabled',
    'formnovalidate',
    'hidden',
    'inert',
    'ismap',
    'itemscope',
    'loop',
    'multiple',
    'muted',
    'nomodule',
    'novalidate',
    'open',
    'playsinline',
    'readonly',
    'required',
    'reversed',
    'selected', 
];
const childrenToStringToBuffer = (children, buffer)=>{
    for(let i = 0, len = children.length; i < len; i++){
        const child = children[i];
        if (typeof child === 'string') {
            escapeToBuffer(child, buffer);
        } else if (typeof child === 'boolean' || child === null || child === undefined) {
            continue;
        } else if (child instanceof JSXNode) {
            child.toStringToBuffer(buffer);
        } else if (typeof child === 'number' || child.isEscaped) {
            buffer[0] += child;
        } else {
            childrenToStringToBuffer(child, buffer);
        }
    }
};
class JSXNode {
    tag;
    props;
    children;
    isEscaped = true;
    constructor(tag, props, children){
        this.tag = tag;
        this.props = props;
        this.children = children;
    }
    toString() {
        const buffer = [
            ''
        ];
        this.toStringToBuffer(buffer);
        return buffer[0];
    }
    toStringToBuffer(buffer) {
        const tag = this.tag;
        const props = this.props;
        let { children  } = this;
        buffer[0] += `<${tag}`;
        const propsKeys = Object.keys(props || {});
        for(let i = 0, len = propsKeys.length; i < len; i++){
            const v = props[propsKeys[i]];
            if (typeof v === 'string') {
                buffer[0] += ` ${propsKeys[i]}="`;
                escapeToBuffer(v, buffer);
                buffer[0] += '"';
            } else if (typeof v === 'number') {
                buffer[0] += ` ${propsKeys[i]}="${v}"`;
            } else if (v === null || v === undefined) {} else if (typeof v === 'boolean' && booleanAttributes.includes(propsKeys[i])) {
                if (v) {
                    buffer[0] += ` ${propsKeys[i]}=""`;
                }
            } else if (propsKeys[i] === 'dangerouslySetInnerHTML') {
                if (children.length > 0) {
                    throw 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.';
                }
                const escapedString = new String(v.__html);
                escapedString.isEscaped = true;
                children = [
                    escapedString
                ];
            } else {
                buffer[0] += ` ${propsKeys[i]}="`;
                escapeToBuffer(v.toString(), buffer);
                buffer[0] += '"';
            }
        }
        if (emptyTags.includes(tag)) {
            buffer[0] += '/>';
            return;
        }
        buffer[0] += '>';
        childrenToStringToBuffer(children, buffer);
        buffer[0] += `</${tag}>`;
    }
}
var AlgorithmTypes;
(function(AlgorithmTypes) {
    AlgorithmTypes["HS256"] = "HS256";
    AlgorithmTypes["HS384"] = "HS384";
    AlgorithmTypes["HS512"] = "HS512";
})(AlgorithmTypes || (AlgorithmTypes = {}));
var CryptoKeyFormat;
(function(CryptoKeyFormat) {
    CryptoKeyFormat["RAW"] = 'raw';
    CryptoKeyFormat["PKCS8"] = 'pkcs8';
    CryptoKeyFormat["SPKI"] = 'spki';
    CryptoKeyFormat["JWK"] = 'jwk';
})(CryptoKeyFormat || (CryptoKeyFormat = {}));
var CryptoKeyUsage;
(function(CryptoKeyUsage) {
    CryptoKeyUsage["Ecrypt"] = 'encrypt';
    CryptoKeyUsage["Decrypt"] = 'decrypt';
    CryptoKeyUsage["Sign"] = 'sign';
    CryptoKeyUsage["Verify"] = 'verify';
    CryptoKeyUsage["Deriverkey"] = 'deriveKey';
    CryptoKeyUsage["DeriveBits"] = 'deriveBits';
    CryptoKeyUsage["WrapKey"] = 'wrapKey';
    CryptoKeyUsage["UnwrapKey"] = 'unwrapKey';
})(CryptoKeyUsage || (CryptoKeyUsage = {}));
var LogPrefix;
(function(LogPrefix) {
    LogPrefix["Outgoing"] = '-->';
    LogPrefix["Incoming"] = '<--';
    LogPrefix["Error"] = 'xxx';
})(LogPrefix || (LogPrefix = {}));
const getCommandInput = (ctx, opts)=>{
    const action = opts.action || ctx.req.param(opts.actionParamName || 'action')?.toLowerCase();
    if (!opts.action && !opts.validActions?.includes(action)) {
        ctx.set('response-status', 400);
        throw new Error(`Invalid action: '${action}'`);
    }
    if (!opts.mandatoryParams) {
        opts.mandatoryParams = opts.paramsName;
    }
    const params = {};
    for (const param of opts.paramsName){
        const value = ctx.req.query(param);
        if (value === undefined && opts.mandatoryParams.includes(param)) {
            ctx.set('response-status', 400);
            throw new Error(`Missing parameter: '${param}'`);
        } else {
            params[param] = value;
        }
    }
    return {
        action,
        params
    };
};
const getPathFromURL1 = (url)=>{
    const fromIndex = url.indexOf('/', 'https://'.length);
    const initParamsIndex = url.indexOf('?');
    const toIndex = initParamsIndex > -1 ? initParamsIndex : url.length;
    return url.substring(fromIndex, toIndex);
};
const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse1,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse2(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod1 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join1,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse2,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod : mod1;
const { join: join2 , normalize: normalize2  } = path;
const path1 = isWindows ? mod : mod1;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse3 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
const importMeta = {
    url: "file:///home/rob/git/OSS/H3LP3R_BUN/h3lp3r-api/src/commons/utils.ts",
    main: false
};
const __currentdir = dirname2(fromFileUrl2(importMeta.url));
let _currentVersion;
const getVersion = async ()=>{
    if (!_currentVersion) {
        if (Deno.env.get('H3LP3R_VERSION')) {
            _currentVersion = Deno.env.get('H3LP3R_VERSION');
        } else {
            const pkgLocatios = [
                '../package.json',
                './package.json',
                join3(Deno.cwd(), 'package.json'),
                join3(__currentdir, '..', '..', 'package.json')
            ];
            for (const pkgLocation of pkgLocatios){
                try {
                    console.log(pkgLocation);
                    const content = await Deno.readFile(pkgLocation);
                    const pkg = JSON.parse(new TextDecoder().decode(content));
                    _currentVersion = pkg.version;
                    break;
                } catch (_) {}
            }
            if (_currentVersion) {
                return _currentVersion;
            } else {
                return 'Unknown';
            }
        }
    }
    return _currentVersion;
};
const BASE_OPERATIONS = {
    encode: (text)=>btoa(text),
    decode: (textBase64)=>atob(textBase64)
};
const VALID_ACTIONS = Object.keys(BASE_OPERATIONS);
const baseRoutes = new Hono();
baseRoutes.get("/", (c)=>{
    return c.text('Base commands');
});
baseRoutes.get("/64/:action", (c)=>{
    const input = getCommandInput(c, {
        validActions: VALID_ACTIONS,
        paramsName: [
            'text'
        ]
    });
    const coderAction = BASE_OPERATIONS[input.action];
    const result = coderAction(input.params.text);
    return c.json({
        result,
        input
    });
});
const CONVERT_OPERATIONS = {
    epoch: (value, unit)=>{
        value = +value * (unit === 'sec' ? 1000 : 1);
        return new Date(value).toISOString();
    }
};
const convRoutes = new Hono();
convRoutes.get("/", (c)=>{
    return c.text('Base commands');
});
convRoutes.get("/epoch", (c)=>{
    const input = getCommandInput(c, {
        action: 'epoch',
        paramsName: [
            'value',
            'unit'
        ],
        mandatoryParams: [
            'value'
        ]
    });
    if ([
        'ms',
        'sec'
    ].includes(input.params.unit || '')) {
        input.params.unit = 'ms';
    }
    const result = CONVERT_OPERATIONS[input.action](input.params.value, input.params.unit);
    return c.json({
        result,
        input
    });
});
const codes = {};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object";
const _isFunctionLike = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod2 = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
Symbol("kHandle");
Symbol("kKeyObject");
const kKeyType = Symbol("kKeyType");
function isKeyObject(obj) {
    return obj != null && obj[kKeyType] !== undefined;
}
const _toString1 = Object.prototype.toString;
const _isObjectLike1 = (value)=>value !== null && typeof value === "object";
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isFloat32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float64Array]";
}
function isTypedArray(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike1(value) && reTypedTag.test(_toString1.call(value));
}
function isUint8Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8Array]";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1 ,  } = mod2;
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const validateBuffer = hideStackFrames((buffer, name = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
const validateInteger = hideStackFrames((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames((value, name, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
function validateBoolean(value, name) {
    if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
}
hideStackFrames((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
const validateCallback = hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
const validateAbortSignal = hideStackFrames((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
function once(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
new Set();
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        },
        eventLoopHasMoreWork () {
            return false;
        }
    };
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
function processTicksAndRejections() {
    let tock;
    do {
        while(tock = queue.shift()){
            try {
                const callback = tock.callback;
                if (tock.args === undefined) {
                    callback();
                } else {
                    const args = tock.args;
                    switch(args.length){
                        case 1:
                            callback(args[0]);
                            break;
                        case 2:
                            callback(args[0], args[1]);
                            break;
                        case 3:
                            callback(args[0], args[1], args[2]);
                            break;
                        case 4:
                            callback(args[0], args[1], args[2], args[3]);
                            break;
                        default:
                            callback(...args);
                    }
                }
            } finally{}
        }
        core.runMicrotasks();
    }while (!queue.isEmpty())
    core.setHasTickScheduled(false);
}
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateCallback(callback);
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i = 0; i < args.length; i++){
                    args_[i] = args[i];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick(callback, ...args) {
    _nextTick(callback, ...args);
}
var State;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format, ...args){
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val1 = parseInt(c);
                        if (isNaN(val1)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val1;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        let esign = m[F.esign];
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format, ...args) {
    const printf = new Printf(format, ...args);
    return printf.doPrintf();
}
const { Deno: Deno1  } = globalThis;
const noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
let enabled = !noColor;
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str, code) {
    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function bold(str) {
    return run(str, code([
        1
    ], 22));
}
function red(str) {
    return run(str, code([
        31
    ], 39));
}
function green(str) {
    return run(str, code([
        32
    ], 39));
}
function white(str) {
    return run(str, code([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run(str, code([
        90
    ], 39));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType1;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType1 || (DiffType1 = {}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
    const common = [];
    if (A.length === 0 || B.length === 0) return [];
    for(let i = 0; i < Math.min(A.length, B.length); i += 1){
        if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
            common.push(A[reverse ? A.length - i - 1 : i]);
        } else {
            return common;
        }
    }
    return common;
}
function diff(A, B) {
    const prefixCommon = createCommon(A, B);
    const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
    A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
    B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
    const swapped = B.length > A.length;
    [A, B] = swapped ? [
        B,
        A
    ] : [
        A,
        B
    ];
    const M = A.length;
    const N = B.length;
    if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
    if (!N) {
        return [
            ...prefixCommon.map((c)=>({
                    type: DiffType1.common,
                    value: c
                })),
            ...A.map((a)=>({
                    type: swapped ? DiffType1.added : DiffType1.removed,
                    value: a
                })),
            ...suffixCommon.map((c)=>({
                    type: DiffType1.common,
                    value: c
                })), 
        ];
    }
    const offset = N;
    const delta = M - N;
    const size = M + N + 1;
    const fp = Array.from({
        length: size
    }, ()=>({
            y: -1,
            id: -1
        }));
    const routes = new Uint32Array((M * N + size + 1) * 2);
    const diffTypesPtrOffset = routes.length / 2;
    let ptr = 0;
    let p = -1;
    function backTrace(A, B, current, swapped) {
        const M = A.length;
        const N = B.length;
        const result = [];
        let a = M - 1;
        let b = N - 1;
        let j = routes[current.id];
        let type = routes[current.id + diffTypesPtrOffset];
        while(true){
            if (!j && !type) break;
            const prev = j;
            if (type === 1) {
                result.unshift({
                    type: swapped ? DiffType1.removed : DiffType1.added,
                    value: B[b]
                });
                b -= 1;
            } else if (type === 3) {
                result.unshift({
                    type: swapped ? DiffType1.added : DiffType1.removed,
                    value: A[a]
                });
                a -= 1;
            } else {
                result.unshift({
                    type: DiffType1.common,
                    value: A[a]
                });
                a -= 1;
                b -= 1;
            }
            j = routes[prev];
            type = routes[prev + diffTypesPtrOffset];
        }
        return result;
    }
    function createFP(slide, down, k, M) {
        if (slide && slide.y === -1 && down && down.y === -1) {
            return {
                y: 0,
                id: 0
            };
        }
        if (down && down.y === -1 || k === M || (slide && slide.y) > (down && down.y) + 1) {
            const prev = slide.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = ADDED;
            return {
                y: slide.y,
                id: ptr
            };
        } else {
            const prev1 = down.id;
            ptr++;
            routes[ptr] = prev1;
            routes[ptr + diffTypesPtrOffset] = REMOVED;
            return {
                y: down.y + 1,
                id: ptr
            };
        }
    }
    function snake(k, slide, down, _offset, A, B) {
        const M = A.length;
        const N = B.length;
        if (k < -N || M < k) return {
            y: -1,
            id: -1
        };
        const fp = createFP(slide, down, k, M);
        while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
            const prev = fp.id;
            ptr++;
            fp.id = ptr;
            fp.y += 1;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp;
    }
    while(fp[delta + offset].y < N){
        p = p + 1;
        for(let k = -p; k < delta; ++k){
            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
        }
        for(let k1 = delta + p; k1 > delta; --k1){
            fp[k1 + offset] = snake(k1, fp[k1 - 1 + offset], fp[k1 + 1 + offset], offset, A, B);
        }
        fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    }
    return [
        ...prefixCommon.map((c)=>({
                type: DiffType1.common,
                value: c
            })),
        ...backTrace(A, B, fp[delta + offset], swapped),
        ...suffixCommon.map((c)=>({
                type: DiffType1.common,
                value: c
            })), 
    ];
}
function diffstr(A, B) {
    function unescape1(string) {
        return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
    }
    function tokenize(string, { wordDiff =false  } = {}) {
        if (wordDiff) {
            const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
            const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
            for(let i = 0; i < tokens.length - 1; i++){
                if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) && words.test(tokens[i + 2])) {
                    tokens[i] += tokens[i + 2];
                    tokens.splice(i + 1, 2);
                    i--;
                }
            }
            return tokens.filter((token)=>token);
        } else {
            const tokens1 = [], lines = string.split(/(\n|\r\n)/);
            if (!lines[lines.length - 1]) {
                lines.pop();
            }
            for(let i1 = 0; i1 < lines.length; i1++){
                if (i1 % 2) {
                    tokens1[tokens1.length - 1] += lines[i1];
                } else {
                    tokens1.push(lines[i1]);
                }
            }
            return tokens1;
        }
    }
    function createDetails(line, tokens) {
        return tokens.filter(({ type  })=>type === line.type || type === DiffType1.common).map((result, i, t)=>{
            if (result.type === DiffType1.common && t[i - 1] && t[i - 1]?.type === t[i + 1]?.type && /\s+/.test(result.value)) {
                result.type = t[i - 1].type;
            }
            return result;
        });
    }
    const diffResult = diff(tokenize(`${unescape1(A)}\n`), tokenize(`${unescape1(B)}\n`));
    const added = [], removed = [];
    for (const result of diffResult){
        if (result.type === DiffType1.added) {
            added.push(result);
        }
        if (result.type === DiffType1.removed) {
            removed.push(result);
        }
    }
    const aLines = added.length < removed.length ? added : removed;
    const bLines = aLines === removed ? added : removed;
    for (const a of aLines){
        let tokens = [], b;
        while(bLines.length){
            b = bLines.shift();
            tokens = diff(tokenize(a.value, {
                wordDiff: true
            }), tokenize(b?.value ?? "", {
                wordDiff: true
            }));
            if (tokens.some(({ type , value  })=>type === DiffType1.common && value.trim().length)) {
                break;
            }
        }
        a.details = createDetails(a, tokens);
        if (b) {
            b.details = createDetails(b, tokens);
        }
    }
    return diffResult;
}
function createColor(diffType, { background =false  } = {}) {
    switch(diffType){
        case DiffType1.added:
            return (s)=>background ? bgGreen(white(s)) : green(bold(s));
        case DiffType1.removed:
            return (s)=>background ? bgRed(white(s)) : red(bold(s));
        default:
            return white;
    }
}
function createSign(diffType) {
    switch(diffType){
        case DiffType1.added:
            return "+   ";
        case DiffType1.removed:
            return "-   ";
        default:
            return "    ";
    }
}
function buildMessage(diffResult, { stringDiff =false  } = {}) {
    const messages = [], diffMessages = [];
    messages.push("");
    messages.push("");
    messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
    messages.push("");
    messages.push("");
    diffResult.forEach((result)=>{
        const c = createColor(result.type);
        const line = result.details?.map((detail)=>detail.type !== DiffType1.common ? createColor(detail.type, {
                background: true
            })(detail.value) : detail.value).join("") ?? result.value;
        diffMessages.push(c(`${createSign(result.type)}${line}`));
    });
    messages.push(...stringDiff ? [
        diffMessages.join("")
    ] : diffMessages);
    messages.push("");
    return messages;
}
function format3(v) {
    const { Deno: Deno1  } = globalThis;
    return typeof Deno1?.inspect === "function" ? Deno1.inspect(v, {
        depth: Infinity,
        sorted: true,
        trailingComma: true,
        compact: false,
        iterableLimit: Infinity
    }) : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}
const CAN_NOT_DISPLAY = "[Cannot display]";
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function isKeyedCollection(x) {
    return [
        Symbol.iterator,
        "size"
    ].every((k)=>k in x);
}
function equal(c, d) {
    const seen = new Map();
    return function compare(a, b) {
        if (a && b && (a instanceof RegExp && b instanceof RegExp || a instanceof URL && b instanceof URL)) {
            return String(a) === String(b);
        }
        if (a instanceof Date && b instanceof Date) {
            const aTime = a.getTime();
            const bTime = b.getTime();
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                return true;
            }
            return aTime === bTime;
        }
        if (typeof a === "number" && typeof b === "number") {
            return Number.isNaN(a) && Number.isNaN(b) || a === b;
        }
        if (Object.is(a, b)) {
            return true;
        }
        if (a && typeof a === "object" && b && typeof b === "object") {
            if (a && b && !constructorsEqual(a, b)) {
                return false;
            }
            if (a instanceof WeakMap || b instanceof WeakMap) {
                if (!(a instanceof WeakMap && b instanceof WeakMap)) return false;
                throw new TypeError("cannot compare WeakMap instances");
            }
            if (a instanceof WeakSet || b instanceof WeakSet) {
                if (!(a instanceof WeakSet && b instanceof WeakSet)) return false;
                throw new TypeError("cannot compare WeakSet instances");
            }
            if (seen.get(a) === b) {
                return true;
            }
            if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                return false;
            }
            seen.set(a, b);
            if (isKeyedCollection(a) && isKeyedCollection(b)) {
                if (a.size !== b.size) {
                    return false;
                }
                let unmatchedEntries = a.size;
                for (const [aKey, aValue] of a.entries()){
                    for (const [bKey, bValue] of b.entries()){
                        if (aKey === aValue && bKey === bValue && compare(aKey, bKey) || compare(aKey, bKey) && compare(aValue, bValue)) {
                            unmatchedEntries--;
                            break;
                        }
                    }
                }
                return unmatchedEntries === 0;
            }
            const merged = {
                ...a,
                ...b
            };
            for (const key of [
                ...Object.getOwnPropertyNames(merged),
                ...Object.getOwnPropertySymbols(merged), 
            ]){
                if (!compare(a && a[key], b && b[key])) {
                    return false;
                }
                if (key in a && !(key in b) || key in b && !(key in a)) {
                    return false;
                }
            }
            if (a instanceof WeakRef || b instanceof WeakRef) {
                if (!(a instanceof WeakRef && b instanceof WeakRef)) return false;
                return compare(a.deref(), b.deref());
            }
            return true;
        }
        return false;
    }(c, d);
}
function constructorsEqual(a, b) {
    return a.constructor === b.constructor || a.constructor === Object && !b.constructor || !a.constructor && b.constructor === Object;
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new AssertionError(msg);
    }
}
function assertEquals(actual, expected, msg) {
    if (equal(actual, expected)) {
        return;
    }
    let message = "";
    const actualString = format3(actual);
    const expectedString = format3(expected);
    try {
        const stringDiff = typeof actual === "string" && typeof expected === "string";
        const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
        const diffMsg = buildMessage(diffResult, {
            stringDiff
        }).join("\n");
        message = `Values are not equal:\n${diffMsg}`;
    } catch  {
        message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
    }
    if (msg) {
        message = msg;
    }
    throw new AssertionError(message);
}
function unreachable() {
    throw new AssertionError("unreachable");
}
class DenoStdInternalError1 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert2(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg);
    }
}
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert2(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr1 = await this.#rd.read(p);
                const nread = rr1 ?? 0;
                assert2(nread >= 0, "negative read");
                return rr1;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert2(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert2(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert2(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.#buf.subarray(this.#r, this.#r + i + 1);
                this.#r += i + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
function notImplemented1(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
TextDecoder;
TextEncoder;
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function normalizeEncoding2(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases2(enc);
}
function slowCases2(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i = 0;
                for(; i < length; ++i){
                    ch = value.charCodeAt(i);
                    if (i === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i = 0; i < optKeys.length; ++i){
                const key = optKeys[i];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)];
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i = 0; i < lastIndex; i++){
        const point = str.charCodeAt(i);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i)}${meta[point]}`;
            }
            last = i + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size = value.size;
            const prefix1 = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix1}{}`;
            }
            braces = [
                `${prefix1}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size1 = value.size;
            const prefix2 = getPrefix(constructor, tag, "Map", `(${size1})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size1 === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix2}{}`;
            }
            braces = [
                `${prefix2}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            const size2 = value.length;
            const prefix3 = getPrefix(constructor, tag, fallback, `(${size2})`);
            braces = [
                `${prefix3}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size2);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "special");
            }
        } else if (isRegExp1(value)) {
            base = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix4 = getPrefix(constructor, tag, "RegExp");
            if (prefix4 !== "RegExp ") {
                base = `${prefix4}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base, "regexp");
            }
        } else if (isDate1(value)) {
            base = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix5 = getPrefix(constructor, tag, "Date");
            if (prefix5 !== "Date ") {
                base = `${prefix5}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "date");
            }
        } else if (value instanceof Error) {
            base = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix6 = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix6 + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix6}{`;
            Array.prototype.unshift.call(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i = 0; i < keys.length; i++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName1 = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName1, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base = base === "" ? reference : `${reference} ${base}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach.call(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push.call(ctx.seen, main);
        for (const key of keys){
            if (key === "constructor" || main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push.call(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push.call(output, value);
            }
        }
        Array.prototype.pop.call(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i = 0; i < len; i++){
        if (!value.hasOwnProperty(i)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push.call(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i = 0; i < maxLength; ++i){
        output[i] = elementFormatter(ctx.stylize, value[i]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push.call(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString.call(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction1(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction1(value)) {
        type = `Async${type}`;
    }
    let base = `[${type}`;
    if (constructor === null) {
        base += " (null prototype)";
    }
    if (value.name === "") {
        base += " (anonymous)";
    } else {
        base += `: ${value.name}`;
    }
    base += "]";
    if (constructor !== type && constructor !== null) {
        base += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    return base;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name1 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name1);
            if (index !== -1 && stack.includes(err[name1])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos1 = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos1, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos1 = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos1 === 0 ? line : line.slice(pos1);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp1 = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${ctx.stylize(tmp1, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp2 = key.replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${tmp2}]`;
    } else if (keyStrRegExp.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i = 0; i < output.length; i++){
        if (ctx.colors) {
            totalLength += removeColors(output[i]).length;
        } else {
            totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base === "" || !base.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        try {
            output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i]]: ""
            };
            output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
            const pos = output[i].lastIndexOf(" ");
            output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
    const keys = Object.keys(value);
    let index = i;
    for(; i < keys.length && output.length < maxLength; i++){
        const key = keys[i];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending1 = remaining > 1 ? "s" : "";
            const message1 = `<${remaining} empty item${ending1}>`;
            output.push(ctx.stylize(message1, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject1(value)) {
        type = "Number";
    } else if (isStringObject1(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type = "Boolean";
    } else if (isBigIntObject1(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base += " (null prototype)";
        } else {
            base += ` (${constructor})`;
        }
    }
    base += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base;
    }
    return ctx.stylize(base, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base += ` extends ${superName}`;
        }
    } else {
        base += " extends [null prototype]";
    }
    return `[${base}]`;
}
function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
                if (isBelowBreakLength(ctx, output, start, base)) {
                    return `${base ? `${base} ` : ""}${braces[0]} ${join4(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base ? `${base} ` : ""}${braces[0]}${indentation}  ` + `${join4(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base)) {
        return `${braces[0]}${base ? ` ${base}` : ""} ${join4(output, ", ")} ` + braces[1];
    }
    const indentation1 = " ".repeat(ctx.indentationLvl);
    const ln = base === "" && braces[0].length === 1 ? " " : `${base ? ` ${base}` : ""}\n${indentation1}  `;
    return `${braces[0]}${ln}${join4(output, `,\n${indentation1}  `)} ${braces[1]}`;
}
function join4(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i = 0; i < lastIndex; i++){
            str += output[i];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i < outputLength; i++){
        const len = getStringWidth(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i1 = 0; i1 < columns; i1++){
            let lineMaxLength = 0;
            for(let j = i1; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i1] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i2 = 0; i2 < output.length; i2++){
                if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i3 = 0; i3 < outputLength; i3 += columns){
            const max = Math.min(i3 + columns, outputLength);
            let str = "";
            let j1 = i3;
            for(; j1 < max - 1; j1++){
                const padding = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1];
                str += `${output[j1]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding1 = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1] - 2;
                str += output[j1].padStart(padding1, " ");
            } else {
                str += output[j1];
            }
            Array.prototype.push.call(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push.call(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i < maxLength; i++){
            const pos = i * 2;
            output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i < maxLength; i++){
            const pos1 = i * 2;
            const res = [
                formatValue(ctx, entries[pos1], recurseTimes),
                formatValue(ctx, entries[pos1 + 1], recurseTimes), 
            ];
            output[i] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i = 0; i < maxLength; i++){
        output[i] = formatValue(ctx, entries[i], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
let debugImpls;
let testEnabled;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled = (str)=>debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled = ()=>false;
    }
}
function emitWarningIfNeeded(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop = ()=>{};
function debuglogImpl(enabled, set) {
    if (debugImpls[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect(arg)).join(" ");
                console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }
    return debugImpls[set];
}
function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled(set);
    }
    let debug = (...args)=>{
        init();
        debug = debuglogImpl(enabled, set);
        if (typeof cb === "function") {
            cb(debug);
        }
        return debug(...args);
    };
    let enabled;
    let test = ()=>{
        init();
        test = ()=>enabled;
        return enabled;
    };
    const logger = (...args)=>debug(...args);
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let debugEnv;
try {
    debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error2) {
    if (error2 instanceof Deno.errors.PermissionDenied) {
        debugEnv = "";
    } else {
        throw error2;
    }
}
initializeDebugEnv(debugEnv);
const osType1 = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const os = {
    UV_UDP_IPV6ONLY: 1,
    UV_UDP_PARTIAL: 2,
    UV_UDP_REUSEADDR: 4,
    UV_UDP_MMSG_CHUNK: 8,
    UV_UDP_MMSG_FREE: 16,
    UV_UDP_LINUX_RECVERR: 32,
    UV_UDP_RECVMMSG: 256,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGBREAK: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
const crypto1 = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
os.errno.EEXIST;
os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error]])=>[
        error,
        status
    ]);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code]])=>[
        code,
        status
    ]);
const errorMap = new Map(osType1 === "windows" ? codeToErrorWindows : osType1 === "darwin" ? codeToErrorDarwin : osType1 === "linux" ? codeToErrorLinux : unreachable());
const codeMap = new Map(osType1 === "windows" ? errorToCodeWindows : osType1 === "darwin" ? errorToCodeDarwin : osType1 === "linux" ? errorToCodeLinux : unreachable());
codeMap.get("EAI_MEMORY");
codeMap.get("UNKNOWN");
codeMap.get("EBADF");
codeMap.get("EINVAL");
codeMap.get("ENOTSOCK");
var Encodings;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const base64abc1 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode2(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc1[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc1[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc1[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode2(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode3(data) {
    return convertBase64ToBase64url(encode2(data));
}
function decode3(b64url) {
    return decode2(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode2(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode3(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength1(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps1 = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength1(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength1(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps1.utf8;
            if (encoding === "ucs2") return encodingOps1.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps1.utf8;
            if (encoding === "ascii") return encodingOps1.ascii;
            if (encoding === "ucs-2") return encodingOps1.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps1.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps1.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps1.latin1;
            }
            if (encoding === "base64") return encodingOps1.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps1.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps1.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
    }
}
function checkInt(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol1 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer1.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer1.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer1.prototype);
    return buf;
}
function Buffer1(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer1.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer1.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer1, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer1.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer1.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer1.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer1.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer1.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer1.prototype;
};
Buffer1.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer1.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer1.from(b, b.offset, b.byteLength);
    }
    if (!Buffer1.isBuffer(a) || !Buffer1.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer1.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding1(encoding) !== undefined;
};
Buffer1.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer1.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer1.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer1.byteLength = byteLength;
Buffer1.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer1.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer1.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer1.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer1.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer1.prototype.toLocaleString = Buffer1.prototype.toString;
Buffer1.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer1.compare(this, b) === 0;
};
Buffer1.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol1) {
    Buffer1.prototype[customInspectSymbol1] = Buffer1.prototype.inspect;
}
Buffer1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer1.from(target, target.offset, target.byteLength);
    }
    if (!Buffer1.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps1.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer1.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer1.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode2(this);
    } else {
        return encode2(this.slice(offset, length));
    }
};
Buffer1.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer1.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode3(this);
    } else {
        return encode3(this.slice(offset, length));
    }
};
Buffer1.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer1.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer1.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer1.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer1.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer1.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer1.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer1.prototype);
    return buffer;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
Buffer1.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer1.prototype);
    return newBuf;
};
Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = readUInt16BE;
Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = readUInt32BE;
Buffer1.prototype.readBigUint64LE = Buffer1.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer1.prototype.readBigUint64BE = Buffer1.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer1.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer1.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer1.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer1.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer1.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer1.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer1.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer1.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer1.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer1.prototype.writeBigUint64LE = Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeBigUint64BE = Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer1.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer1.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer1.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer1.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer1.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer1.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer1.isBuffer(val) ? val : Buffer1.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds1(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds1(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType;
(function(valueType) {
    valueType[valueType["noIterator"] = 0] = "noIterator";
    valueType[valueType["isArray"] = 1] = "isArray";
    valueType[valueType["isSet"] = 2] = "isSet";
    valueType[valueType["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function innerDeepEqual(val1, val2, strict, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError1(val1) || val1 instanceof Error) {
        if (!isNativeError1(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()).toString();
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter1 = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter1);
        const keysVal2 = getOwnNonIndexProperties(val2, filter1);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.noIterator, keysVal1);
    } else if (isSet1(val1)) {
        if (!isSet1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isSet);
    } else if (isMap1(val1)) {
        if (!isMap1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isMap);
    } else if (isAnyArrayBuffer1(val1)) {
        if (!isAnyArrayBuffer1(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive1(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet1(val2) || isMap1(val2) || isDate1(val2) || isRegExp1(val2) || isAnyArrayBuffer1(val2) || isBoxedPrimitive1(val2) || isNativeError1(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i = 0;
    for(; i < aKeys.length; i++){
        if (!val2.propertyIsEnumerable(aKeys[i])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                const key = symbolKeysA[i];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB1 = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB1.length !== 0 && getEnumerables(val2, symbolKeysB1).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a, b) {
    return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i = 0; i < arr1.byteLength; i++){
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer1.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer1.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject1(a)) {
        return isNumberObject1(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
    }
    if (isStringObject1(a)) {
        return isStringObject1(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject1(a)) {
        return isBooleanObject1(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject1(a)) {
        return isBigIntObject1(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject1(a)) {
        return isSymbolObject1(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key));
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
    let i = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i < obj1.length; i++){
            if (obj1.hasOwnProperty(i)) {
                if (!obj2.hasOwnProperty(i) || !innerDeepEqual(obj1[i], obj2[i], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i < keys1.length; i++){
                    const key = keys1[i];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i = 0; i < keys.length; i++){
        const key1 = keys[i];
        if (!innerDeepEqual(obj1[key1], obj2[key1], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item1 of set2){
            if (typeof item1 === "object" && item1 !== null) {
                if (!setHasEqualElement(set, item1, strict, memos)) return false;
            } else if (!strict && !set1.has(item1) && !setHasEqualElement(set, item1, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key1 , 1: item  } of map2){
            if (typeof key1 === "object" && key1 !== null) {
                if (!mapHasEqualEntry(set, map1, key1, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key1) || !innerDeepEqual(map1.get(key1), item, false, memos)) && !mapHasEqualEntry(set, map1, key1, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code) {
    if (typeof code !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger(code)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap.get(code)?.[0];
}
const { errno: { ENOTDIR , ENOENT  } ,  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
class AbortError extends Error {
    code;
    constructor(){
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function errnoException(err, syscall, original) {
    const code = getSystemErrorName(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
    return errorMap.get(name);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
hideStackFrames(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path;
    let dest;
    if (ctx.path) {
        path = ctx.path.toString();
        message += ` '${path}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path) {
        err.path = path;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap.get("EAI_NODATA") || code === codeMap.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last1 = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last1}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last2 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last2}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert2(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED extends NodeError {
    constructor(x){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap = (a)=>`"${a}"`;
        args = args.map((a)=>Array.isArray(a) ? a.map(wrap).join(" or ") : wrap(a));
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_MULTIPLE_CALLBACK extends NodeError {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name, port, allowZero = true){
        assert2(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_STREAM_ALREADY_FINISHED extends NodeError {
    constructor(x){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE extends NodeError {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES extends NodeTypeError {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF extends NodeError {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends NodeError {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRITE_AFTER_END extends NodeError {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}
class ERR_INVALID_RETURN_VALUE extends NodeTypeError {
    constructor(input, name, value){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name}" function but got ${buildReturnPropertyType(value)}.`);
    }
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError, 
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
hideStackFrames(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
const { hasOwn  } = Object;
function get(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v = get(obj, key);
    assert2(v != null);
    return v;
}
function isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get(o, key) ?? {};
    });
    const key = keys[keys.length - 1];
    return hasOwn(o, key);
}
function parse4(args, { "--": doubleDash = false , alias ={} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , collect =[] , negatable =[] , unknown =(i)=>i  } = {}) {
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {},
        negatable: {}
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
            }
        }
    }
    const aliases = {};
    if (alias !== undefined) {
        for(const key1 in alias){
            const val = getForce(alias, key1);
            if (typeof val === "string") {
                aliases[key1] = [
                    val
                ];
            } else {
                aliases[key1] = val;
            }
            for (const alias1 of getForce(aliases, key1)){
                aliases[alias1] = [
                    key1
                ].concat(aliases[key1].filter((y)=>alias1 !== y));
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key2 of stringArgs.filter(Boolean)){
            flags.strings[key2] = true;
            const alias2 = get(aliases, key2);
            if (alias2) {
                for (const al of alias2){
                    flags.strings[al] = true;
                }
            }
        }
    }
    if (collect !== undefined) {
        const collectArgs = typeof collect === "string" ? [
            collect
        ] : collect;
        for (const key3 of collectArgs.filter(Boolean)){
            flags.collect[key3] = true;
            const alias3 = get(aliases, key3);
            if (alias3) {
                for (const al1 of alias3){
                    flags.collect[al1] = true;
                }
            }
        }
    }
    if (negatable !== undefined) {
        const negatableArgs = typeof negatable === "string" ? [
            negatable
        ] : negatable;
        for (const key4 of negatableArgs.filter(Boolean)){
            flags.negatable[key4] = true;
            const alias4 = get(aliases, key4);
            if (alias4) {
                for (const al2 of alias4){
                    flags.negatable[al2] = true;
                }
            }
        }
    }
    const argv = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
    }
    function setKey(obj, name, value, collect = true) {
        let o = obj;
        const keys = name.split(".");
        keys.slice(0, -1).forEach(function(key) {
            if (get(o, key) === undefined) {
                o[key] = {};
            }
            o = get(o, key);
        });
        const key = keys[keys.length - 1];
        const collectable = collect && !!get(flags.collect, name);
        if (!collectable) {
            o[key] = value;
        } else if (get(o, key) === undefined) {
            o[key] = [
                value
            ];
        } else if (Array.isArray(get(o, key))) {
            o[key].push(value);
        } else {
            o[key] = [
                get(o, key),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined, collect) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
        setKey(argv, key, value, collect);
        const alias = get(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv, x, value, collect);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x)=>typeof get(flags.bools, x) === "boolean");
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert2(m != null);
            const [, key5, value] = m;
            if (flags.bools[key5]) {
                const booleanValue = value !== "false";
                setArg(key5, booleanValue, arg);
            } else {
                setArg(key5, value, arg);
            }
        } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
            const m1 = arg.match(/^--no-(.+)/);
            assert2(m1 != null);
            setArg(m1[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
            const m2 = arg.match(/^--(.+)/);
            assert2(m2 != null);
            const [, key6] = m2;
            const next = args[i + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags.bools, key6) && !flags.allBools && (get(aliases, key6) ? !aliasIsBoolean(key6) : true)) {
                setArg(key6, next, arg);
                i++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key6, next === "true", arg);
                i++;
            } else {
                setArg(key6, get(flags.strings, key6) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next1 = arg.slice(j + 2);
                if (next1 === "-") {
                    setArg(letters[j], next1, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next1)) {
                    setArg(letters[j], next1.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next1)) {
                    setArg(letters[j], next1, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key7] = arg.slice(-1);
            if (!broken && key7 !== "-") {
                if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get(flags.bools, key7) && (get(aliases, key7) ? !aliasIsBoolean(key7) : true)) {
                    setArg(key7, args[i + 1], arg);
                    i++;
                } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
                    setArg(key7, args[i + 1] === "true", arg);
                    i++;
                } else {
                    setArg(key7, get(flags.strings, key7) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv._.push(...args.slice(i + 1));
                break;
            }
        }
    }
    for (const [key8, value1] of Object.entries(defaults)){
        if (!hasKey(argv, key8.split("."))) {
            setKey(argv, key8, value1);
            if (aliases[key8]) {
                for (const x of aliases[key8]){
                    setKey(argv, x, value1);
                }
            }
        }
    }
    for (const key9 of Object.keys(flags.bools)){
        if (!hasKey(argv, key9.split("."))) {
            const value2 = get(flags.collect, key9) ? [] : false;
            setKey(argv, key9, value2, false);
        }
    }
    for (const key10 of Object.keys(flags.strings)){
        if (!hasKey(argv, key10.split(".")) && get(flags.collect, key10)) {
            setKey(argv, key10, [], false);
        }
    }
    if (doubleDash) {
        argv["--"] = [];
        for (const key11 of notFlags){
            argv["--"].push(key11);
        }
    } else {
        for (const key12 of notFlags){
            argv._.push(key12);
        }
    }
    return argv;
}
function getOptions() {
    const args = parse4(Deno.args);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
let wasm;
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
    return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
const cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachedUint8Memory0;
function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr1 = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr1 + offset] = code;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr1 = realloc(ptr1, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr1 + offset, ptr1 + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr1;
}
function isLikeNone(x) {
    return x === undefined || x === null;
}
let cachedInt32Memory0;
function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DigestContextFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_digestcontext_free(ptr));
class DigestContext {
    static __wrap(ptr) {
        const obj = Object.create(DigestContext.prototype);
        obj.ptr = ptr;
        DigestContextFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
    }
    constructor(algorithm){
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.digestcontext_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DigestContext.__wrap(r0);
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    update(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digest(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndReset(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndDrop(length) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    reset() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_reset(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    clone() {
        const ret = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbg_new_a4b61a0f54824cfd: function(arg0, arg1) {
            const ret = new TypeError(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret);
        },
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject(arg0);
        },
        __wbg_byteLength_3e250b41a8915757: function(arg0) {
            const ret = getObject(arg0).byteLength;
            return ret;
        },
        __wbg_byteOffset_4204ecb24a6e5df9: function(arg0) {
            const ret = getObject(arg0).byteOffset;
            return ret;
        },
        __wbg_buffer_facf0398a281c85b: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff: function(arg0, arg1, arg2) {
            const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
            return addHeapObject(ret);
        },
        __wbg_length_1eb8fc608a0d4cdb: function(arg0) {
            const ret = getObject(arg0).length;
            return ret;
        },
        __wbindgen_memory: function() {
            const ret = wasm.memory;
            return addHeapObject(ret);
        },
        __wbg_buffer_397eaa4d72ee94dd: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_new_a7ce447f15ff496f: function(arg0) {
            const ret = new Uint8Array(getObject(arg0));
            return addHeapObject(ret);
        },
        __wbg_set_969ad0a60e51d320: function(arg0, arg1, arg2) {
            getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        }
    }
};
function instantiate() {
    return instantiateWithInstance().exports;
}
let instanceWithExports;
function instantiateWithInstance() {
    if (instanceWithExports == null) {
        const instance = instantiateInstance();
        wasm = instance.exports;
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        instanceWithExports = {
            instance,
            exports: {
                digest,
                DigestContext
            }
        };
    }
    return instanceWithExports;
}
function instantiateInstance() {
    const wasmBytes = base64decode("\
AGFzbQEAAAABo4GAgAAYYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fw\
F/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+\
fwBgB39/f35/f38Bf2ADf39+AGAFf399f38AYAV/f3x/fwBgAn9+AGAEf31/fwBgBH98f38AYAJ+fw\
F/AqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2E0YjYxYTBmNTQ4MjRj\
ZmQABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAh\
hfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3\
AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDIwNGVjYjI0YTZlNW\
RmOQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfZmFjZjAzOThhMjgxYzg1\
YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbm\
d0aF80YjliOGM0ZTNmNWFkYmZmAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0\
aF8xZWI4ZmM2MDhhMGQ0Y2RiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbW\
Vtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5\
NGRkAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmAA\
MYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwAAcYX193\
YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQPrgICAAGoJBwkHBxEFBwcFAw\
cHDwMHBRACBQUFBwUCCAYHBxQMCA4HBwcHBwcIFw0FBQkICA0HCQUJCQYGBQUFBQUFBwcHBwcABQII\
CgcHAgUDDgwLDAsLEhMJBQgIAwYGAgUAAAYDBgAABQUEAAUCBIWAgIAAAXABFRUFg4CAgAABABEGiY\
CAgAABfwFBgIDAAAsHtoKAgAAOBm1lbW9yeQIABmRpZ2VzdAA1GF9fd2JnX2RpZ2VzdGNvbnRleHRf\
ZnJlZQBQEWRpZ2VzdGNvbnRleHRfbmV3ADwUZGlnZXN0Y29udGV4dF91cGRhdGUAVBRkaWdlc3Rjb2\
50ZXh0X2RpZ2VzdAA9HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAPxtkaWdlc3Rjb250ZXh0\
X2RpZ2VzdEFuZERyb3AAOBNkaWdlc3Rjb250ZXh0X3Jlc2V0ACETZGlnZXN0Y29udGV4dF9jbG9uZQ\
AaH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAbBFfX3diaW5kZ2VuX21hbGxvYwBXEl9f\
d2JpbmRnZW5fcmVhbGxvYwBiD19fd2JpbmRnZW5fZnJlZQBoCZqAgIAAAQBBAQsUZWZtdGtZO1pbWG\
NgXF1eX3VBQnIK0smIgABqoH4CEn8CfiMAQbAlayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCAA4YAAECAwQcGxoZGB\
cWFRQTEhEQDw4NDAsKAAsgASgCBCEBQdABEBYiBUUNBCAEQZASakE4aiABQThqKQMANwMAIARBkBJq\
QTBqIAFBMGopAwA3AwAgBEGQEmpBKGogAUEoaikDADcDACAEQZASakEgaiABQSBqKQMANwMAIARBkB\
JqQRhqIAFBGGopAwA3AwAgBEGQEmpBEGogAUEQaikDADcDACAEQZASakEIaiABQQhqKQMANwMAIAQg\
ASkDADcDkBIgASkDQCEWIARBkBJqQcgAaiABQcgAahBDIAQgFjcD0BIgBSAEQZASakHQARA5GkEAIQ\
ZBACEBDB8LIAEoAgQhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBq\
KQMANwMAIARBkBJqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQR\
hqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5AS\
IAEpA0AhFiAEQZASakHIAGogAUHIAGoQQyAEIBY3A9ASIAUgBEGQEmpB0AEQORpBASEBDBsLIAEoAg\
QhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJq\
QShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkB\
JqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZAS\
akHIAGogAUHIAGoQQyAEIBY3A9ASIAUgBEGQEmpB0AEQORpBAiEBDBoLIAEoAgQhAUHwABAWIgVFDQ\
QgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3\
AwAgBCABKQMINwOYEiABKQMAIRYgBEGQEmpBKGogAUEoahA3IAQgFjcDkBIgBSAEQZASakHwABA5Gk\
EDIQEMGQsgASgCBCEBQfgOEBYiBUUNBCAEQZASakGIAWogAUGIAWopAwA3AwAgBEGQEmpBgAFqIAFB\
gAFqKQMANwMAIARBkBJqQfgAaiABQfgAaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQR\
hqIAFBGGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJq\
QThqIAFBOGopAwA3AwAgBEGQEmpBwABqIAFBwABqKQMANwMAIARBkBJqQcgAaiABQcgAaikDADcDAC\
AEQZASakHQAGogAUHQAGopAwA3AwAgBEGQEmpB2ABqIAFB2ABqKQMANwMAIARBkBJqQeAAaiABQeAA\
aikDADcDACAEIAEpA3A3A4ATIAQgASkDCDcDmBIgBCABKQMoNwO4EiABKQMAIRYgAS0AaiEHIAEtAG\
khCCABLQBoIQkCQCABKAKQAUEFdCIKDQBBACEKDBsLIARBGGoiCyABQZQBaiIGQRhqKQAANwMAIARB\
EGoiDCAGQRBqKQAANwMAIARBCGoiDSAGQQhqKQAANwMAIAQgBikAADcDACABQdQBaiEGQQAgCkFgak\
EFdmshDiAEQcQTaiEBQQIhCgNAIAFBYGoiDyAEKQMANwAAIA9BGGogCykDADcAACAPQRBqIAwpAwA3\
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\
ASAEQZASaiABQcgBEDkaIARBkBJqQcgBaiABQcgBahBIIAUgBEGQEmpB4AIQORpBBSEBC0EAIQYMAg\
tB4AJBCEEAKAL41EAiBEEEIAQbEQUAAAsgBCAKNgKgEyAEIAc6APoSIAQgCDoA+RIgBCAJOgD4EiAE\
IBY3A5ASIAUgBEGQEmpB+A4QORpBBCEBQQEhBgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAC\
DgIBABELQSAhAiABDhgBDwIPEAMPBAUGBgcHCA8JCgsPDA0QEA4BCyABQQJ0QZTUwABqKAIAIQMMDw\
tBwAAhAgwNC0EwIQIMDAtBHCECDAsLQTAhAgwKC0HAACECDAkLQRAhAgwIC0EUIQIMBwtBHCECDAYL\
QTAhAgwFC0HAACECDAQLQRwhAgwDC0EwIQIMAgtBwAAhAgwBC0EYIQILIAIgA0YNACAAQa2BwAA2Ag\
QgAEEBNgIAIABBCGpBOTYCAAJAIAZFDQAgBSgCkAFFDQAgBUEANgKQAQsgBRAeDAELAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4YAAECAwQFBg\
cICQoLDA0ODxAREhMUFRYaAAsgBCAFQdABEDkiAUH4DmpBDGpCADcCACABQfgOakEUakIANwIAIAFB\
+A5qQRxqQgA3AgAgAUH4DmpBJGpCADcCACABQfgOakEsakIANwIAIAFB+A5qQTRqQgA3AgAgAUH4Dm\
pBPGpCADcCACABQgA3AvwOIAFBwAA2AvgOIAFBkBJqIAFB+A5qQcQAEDkaIAFBuCJqQThqIgogAUGQ\
EmpBPGopAgA3AwAgAUG4ImpBMGoiAyABQZASakE0aikCADcDACABQbgiakEoaiIPIAFBkBJqQSxqKQ\
IANwMAIAFBuCJqQSBqIgsgAUGQEmpBJGopAgA3AwAgAUG4ImpBGGoiDCABQZASakEcaikCADcDACAB\
QbgiakEQaiINIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhqIhAgAUGQEmpBDGopAgA3AwAgASABKQKUEj\
cDuCIgAUGQEmogAUHQARA5GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohAgJAIAZBgAFG\
DQAgAiAGakEAQYABIAZrEDoaCyABQQA6ANgTIAFBkBJqIAJCfxARIAFB+A5qQQhqIgYgAUGQEmpBCG\
opAwA3AwAgAUH4DmpBEGoiAiABQZASakEQaikDADcDACABQfgOakEYaiIOIAFBkBJqQRhqKQMANwMA\
IAFB+A5qQSBqIgcgASkDsBI3AwAgAUH4DmpBKGoiCCABQZASakEoaikDADcDACABQfgOakEwaiIJIA\
FBkBJqQTBqKQMANwMAIAFB+A5qQThqIhEgAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gECAGKQMA\
NwMAIA0gAikDADcDACAMIA4pAwA3AwAgCyAHKQMANwMAIA8gCCkDADcDACADIAkpAwA3AwAgCiARKQ\
MANwMAIAEgASkD+A43A7giQcAAEBYiBkUNHCAGIAEpA7giNwAAIAZBOGogAUG4ImpBOGopAwA3AAAg\
BkEwaiABQbgiakEwaikDADcAACAGQShqIAFBuCJqQShqKQMANwAAIAZBIGogAUG4ImpBIGopAwA3AA\
AgBkEYaiABQbgiakEYaikDADcAACAGQRBqIAFBuCJqQRBqKQMANwAAIAZBCGogAUG4ImpBCGopAwA3\
AABBwAAhAwwaCyAEIAVB0AEQOSIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBDGpCAD\
cCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCyABQfgOakEYaiICKQMANwMAIAFBkBJqQRBqIgwg\
AUH4DmpBEGoiCikDADcDACABQZASakEIaiINIAFB+A5qQQhqIgMpAwA3AwAgAUGQEmpBIGogAUH4Dm\
pBIGoiECgCADYCACABIAEpA/gONwOQEiABQbgiakEQaiIOIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhq\
IgcgAUGQEmpBDGopAgA3AwAgAUG4ImpBGGoiCCABQZASakEcaikCADcDACABIAEpApQSNwO4IiABQZ\
ASaiABQdABEDkaIAEgASkD0BIgAUHYE2otAAAiBq18NwPQEiABQdgSaiEPAkAgBkGAAUYNACAPIAZq\
QQBBgAEgBmsQOhoLIAFBADoA2BMgAUGQEmogD0J/EBEgAyANKQMANwMAIAogDCkDADcDACACIAspAw\
A3AwAgECABKQOwEjcDACABQfgOakEoaiABQZASakEoaikDADcDACABQfgOakEwaiABQZASakEwaikD\
ADcDACABQfgOakE4aiABQZASakE4aikDADcDACABIAEpA5ASNwP4DiAHIAMpAwA3AwAgDiAKKQMANw\
MAIAggAikDADcDACABIAEpA/gONwO4IkEgEBYiBkUNHCAGIAEpA7giNwAAIAZBGGogAUG4ImpBGGop\
AwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQSAhAwwZCyAEIAVB0A\
EQOSIBQfgOakEsakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBHGpCADcCACABQfgOakEUakIANwIA\
IAFB+A5qQQxqQgA3AgAgAUIANwL8DiABQTA2AvgOIAFBkBJqQShqIg0gAUH4DmpBKGoiAikDADcDAC\
ABQZASakEgaiABQfgOakEgaiIKKQMANwMAIAFBkBJqQRhqIhAgAUH4DmpBGGoiAykDADcDACABQZAS\
akEQaiIOIAFB+A5qQRBqIg8pAwA3AwAgAUGQEmpBCGoiByABQfgOakEIaiILKQMANwMAIAFBkBJqQT\
BqIgggAUH4DmpBMGoiCSgCADYCACABIAEpA/gONwOQEiABQbgiakEgaiIRIAFBkBJqQSRqKQIANwMA\
IAFBuCJqQRhqIhIgAUGQEmpBHGopAgA3AwAgAUG4ImpBEGoiEyABQZASakEUaikCADcDACABQbgiak\
EIaiIUIAFBkBJqQQxqKQIANwMAIAFBuCJqQShqIhUgAUGQEmpBLGopAgA3AwAgASABKQKUEjcDuCIg\
AUGQEmogAUHQARA5GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohDAJAIAZBgAFGDQAgDC\
AGakEAQYABIAZrEDoaCyABQQA6ANgTIAFBkBJqIAxCfxARIAsgBykDADcDACAPIA4pAwA3AwAgAyAQ\
KQMANwMAIAogASkDsBI3AwAgAiANKQMANwMAIAkgCCkDADcDACABQfgOakE4aiABQZASakE4aikDAD\
cDACABIAEpA5ASNwP4DiAUIAspAwA3AwAgEyAPKQMANwMAIBIgAykDADcDACARIAopAwA3AwAgFSAC\
KQMANwMAIAEgASkD+A43A7giQTAQFiIGRQ0cIAYgASkDuCI3AAAgBkEoaiABQbgiakEoaikDADcAAC\
AGQSBqIAFBuCJqQSBqKQMANwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcA\
ACAGQQhqIAFBuCJqQQhqKQMANwAAQTAhAwwYCyAEIAVB8AAQOSIBQfgOakEcakIANwIAIAFB+A5qQR\
RqQgA3AgAgAUH4DmpBDGpCADcCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCiABQfgOakEYaikD\
ADcDACABQZASakEQaiIDIAFB+A5qQRBqKQMANwMAIAFBkBJqQQhqIAFB+A5qQQhqIg8pAwA3AwAgAU\
GQEmpBIGoiCyABQfgOakEgaigCADYCACABIAEpA/gONwOQEiABQegjakEQaiIMIAFBkBJqQRRqKQIA\
NwMAIAFB6CNqQQhqIg0gAUGQEmpBDGopAgA3AwAgAUHoI2pBGGoiECABQZASakEcaikCADcDACABIA\
EpApQSNwPoIyABQZASaiABQfAAEDkaIAEgASkDkBIgAUH4EmotAAAiBq18NwOQEiABQbgSaiECAkAg\
BkHAAEYNACACIAZqQQBBwAAgBmsQOhoLIAFBADoA+BIgAUGQEmogAkF/EBMgDyADKQMAIhY3AwAgDS\
AWNwMAIAwgCikDADcDACAQIAspAwA3AwAgASABKQOYEiIWNwP4DiABIBY3A+gjQSAQFiIGRQ0cIAYg\
ASkD6CM3AAAgBkEYaiABQegjakEYaikDADcAACAGQRBqIAFB6CNqQRBqKQMANwAAIAZBCGogAUHoI2\
pBCGopAwA3AABBICEDDBcLIAQgBUH4DhA5IQEgA0EASA0SAkACQCADDQBBASEGDAELIAMQFiIGRQ0d\
IAZBfGotAABBA3FFDQAgBkEAIAMQOhoLIAFBkBJqIAFB+A4QORogAUH4DmogAUGQEmoQIyABQfgOai\
AGIAMQGAwWCyAEIAVB4AIQOSIKQZASaiAKQeACEDkaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAg\
AUGQAUYNACACQQBBkAEgAWsQOhoLQQAhBiAKQQA6AOgUIAJBAToAACAKQecUaiIBIAEtAABBgAFyOg\
AAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAg\
AUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkA\
FHDQALIApBkBJqECQgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBq\
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\
KQKUEjcD6CMgAUGQEmogAUHgABA5GiABQZASaiABQagSaiABQegjahAuQRAQFiIGRQ0cIAYgASkD6C\
M3AAAgBkEIaiACKQMANwAADBALQRQhAyAEIAVB6AAQOSIBQfgOakEUakEANgIAIAFB+A5qQQxqQgA3\
AgAgAUEANgL4DiABQgA3AvwOIAFBFDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCG\
ogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJq\
QRRqKAIANgIAIAEgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQORogAUGQEmogAUGwEm\
ogAUHoI2oQLUEUEBYiBkUNHCAGIAEpA+gjNwAAIAZBEGogCigCADYAACAGQQhqIAIpAwA3AAAMDwtB\
FCEDIAQgBUHoABA5IgFB+A5qQRRqQQA2AgAgAUH4DmpBDGpCADcCACABQQA2AvgOIAFCADcC/A4gAU\
EUNgL4DiABQZASakEQaiABQfgOakEQaikDADcDACABQZASakEIaiABQfgOakEIaikDADcDACABQegj\
akEIaiICIAFBkBJqQQxqKQIANwMAIAFB6CNqQRBqIgogAUGQEmpBFGooAgA2AgAgASABKQP4DjcDkB\
IgASABKQKUEjcD6CMgAUGQEmogAUHoABA5GiABQZASaiABQbASaiABQegjahAoQRQQFiIGRQ0cIAYg\
ASkD6CM3AAAgBkEQaiAKKAIANgAAIAZBCGogAikDADcAAAwOCyAEIAVB4AIQOSIKQZASaiAKQeACED\
kaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQBBkAEgAWsQOhoLQQAhBiAKQQA6\
AOgUIAJBBjoAACAKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAcz\
oAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oi\
AiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJqECQgCkH4DmpBGGoiASAKQZASak\
EYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIg8gCkGQEmpBCGopAwA3\
AwAgCiAKKQOQEjcD+A5BHCEDQRwQFiIGRQ0cIAYgCikD+A43AAAgBkEYaiABKAIANgAAIAZBEGogAi\
kDADcAACAGQQhqIA8pAwA3AAAMDQsgBCAFQdgCEDkiCkGQEmogCkHYAhA5GiAKQZASaiAKQeAUai0A\
ACIBakHIAWohAgJAIAFBiAFGDQAgAkEAQYgBIAFrEDoaC0EAIQYgCkEAOgDgFCACQQY6AAAgCkHfFG\
oiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAg\
AUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAH\
M6AAAgBkEEaiIGQYgBRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGopAwA3AwAgCkH4DmpB\
EGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQS\
AhA0EgEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMA\
NwAADAwLIAQgBUG4AhA5IgpBkBJqIApBuAIQORogCkGQEmogCkHAFGotAAAiAWpByAFqIQICQCABQe\
gARg0AIAJBAEHoACABaxA6GgtBACEGIApBADoAwBQgAkEGOgAAIApBvxRqIgEgAS0AAEGAAXI6AAAD\
QCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQ\
JqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkHoAEcN\
AAsgCkGQEmoQJCAKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgIgCkGQEmpBIGopAw\
A3AwAgCkH4DmpBGGoiDyAKQZASakEYaikDADcDACAKQfgOakEQaiILIApBkBJqQRBqKQMANwMAIApB\
+A5qQQhqIgwgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCEDQTAQFiIGRQ0cIAYgCikD+A43AA\
AgBkEoaiABKQMANwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AAAgBkEQaiALKQMANwAAIAZBCGog\
DCkDADcAAAwLCyAEIAVBmAIQOSIKQZASaiAKQZgCEDkaIApBkBJqIApBoBRqLQAAIgFqQcgBaiECAk\
AgAUHIAEYNACACQQBByAAgAWsQOhoLQQAhBiAKQQA6AKAUIAJBBjoAACAKQZ8UaiIBIAEtAABBgAFy\
OgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AA\
AgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZB\
yABHDQALIApBkBJqECQgCkH4DmpBOGoiASAKQZASakE4aikDADcDACAKQfgOakEwaiICIApBkBJqQT\
BqKQMANwMAIApB+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4DmpBIGoiCyAKQZASakEgaikDADcD\
ACAKQfgOakEYaiIMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0gCkGQEmpBEGopAwA3AwAgCkH4Dm\
pBCGoiECAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQcAAEBYiBkUNHCAGIAopA/gONwAA\
IAZBOGogASkDADcAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAAIAZBIGogCykDADcAACAGQRhqIA\
wpAwA3AAAgBkEQaiANKQMANwAAIAZBCGogECkDADcAAAwKCyAEIAVB8AAQOSIBQZASaiABQfAAEDka\
QRwhAyABQegjakEcakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBDGpCADcCACABQgA3AuwjIAFBID\
YC6CMgAUH4DmpBGGoiAiABQegjakEYaikDADcDACABQfgOakEQaiIKIAFB6CNqQRBqKQMANwMAIAFB\
+A5qQQhqIg8gAUHoI2pBCGopAwA3AwAgAUH4DmpBIGogAUHoI2pBIGooAgA2AgAgASABKQPoIzcD+A\
4gAUG4ImpBEGoiBiABQfgOakEUaikCADcDACABQbgiakEIaiILIAFB+A5qQQxqKQIANwMAIAFBuCJq\
QRhqIgwgAUH4DmpBHGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUG4EmogAUG4ImoQJyACIAwoAg\
A2AgAgCiAGKQMANwMAIA8gCykDADcDACABIAEpA7giNwP4DkEcEBYiBkUNHCAGIAEpA/gONwAAIAZB\
GGogAigCADYAACAGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAkLIAQgBUHwABA5IgFBkBJqIAFB8A\
AQORogAUHoI2pBHGpCADcCACABQegjakEUakIANwIAIAFB6CNqQQxqQgA3AgAgAUIANwLsI0EgIQMg\
AUEgNgLoIyABQfgOakEgaiABQegjakEgaigCADYCACABQfgOakEYaiICIAFB6CNqQRhqKQMANwMAIA\
FB+A5qQRBqIgogAUHoI2pBEGopAwA3AwAgAUH4DmpBCGoiDyABQegjakEIaikDADcDACABIAEpA+gj\
NwP4DiABQbgiakEYaiIGIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgsgAUH4DmpBFGopAgA3AwAgAU\
G4ImpBCGoiDCABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQbgSaiABQbgiahAnIAIg\
BikDADcDACAKIAspAwA3AwAgDyAMKQMANwMAIAEgASkDuCI3A/gOQSAQFiIGRQ0cIAYgASkD+A43AA\
AgBkEYaiACKQMANwAAIAZBEGogCikDADcAACAGQQhqIA8pAwA3AAAMCAsgBCAFQdgBEDkiAUGQEmog\
AUHYARA5GiABQegjakEMakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBHGpCADcCACABQegjakEkak\
IANwIAIAFB6CNqQSxqQgA3AgAgAUHoI2pBNGpCADcCACABQegjakE8akIANwIAIAFCADcC7CMgAUHA\
ADYC6CMgAUH4DmogAUHoI2pBxAAQORogAUHwImogAUH4DmpBPGopAgA3AwBBMCEDIAFBuCJqQTBqIA\
FB+A5qQTRqKQIANwMAIAFBuCJqQShqIgYgAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiAiABQfgOakEk\
aikCADcDACABQbgiakEYaiIKIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIg8gAUH4DmpBFGopAgA3Aw\
AgAUG4ImpBCGoiCyABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAi\
IAFB+A5qQShqIgwgBikDADcDACABQfgOakEgaiINIAIpAwA3AwAgAUH4DmpBGGoiAiAKKQMANwMAIA\
FB+A5qQRBqIgogDykDADcDACABQfgOakEIaiIPIAspAwA3AwAgASABKQO4IjcD+A5BMBAWIgZFDRwg\
BiABKQP4DjcAACAGQShqIAwpAwA3AAAgBkEgaiANKQMANwAAIAZBGGogAikDADcAACAGQRBqIAopAw\
A3AAAgBkEIaiAPKQMANwAADAcLIAQgBUHYARA5IgFBkBJqIAFB2AEQORogAUHoI2pBDGpCADcCACAB\
QegjakEUakIANwIAIAFB6CNqQRxqQgA3AgAgAUHoI2pBJGpCADcCACABQegjakEsakIANwIAIAFB6C\
NqQTRqQgA3AgAgAUHoI2pBPGpCADcCACABQgA3AuwjQcAAIQMgAUHAADYC6CMgAUH4DmogAUHoI2pB\
xAAQORogAUG4ImpBOGoiBiABQfgOakE8aikCADcDACABQbgiakEwaiICIAFB+A5qQTRqKQIANwMAIA\
FBuCJqQShqIgogAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiDyABQfgOakEkaikCADcDACABQbgiakEY\
aiILIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgwgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDSABQf\
gOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAiIAFB+A5qQThqIhAgBikD\
ADcDACABQfgOakEwaiIOIAIpAwA3AwAgAUH4DmpBKGoiAiAKKQMANwMAIAFB+A5qQSBqIgogDykDAD\
cDACABQfgOakEYaiIPIAspAwA3AwAgAUH4DmpBEGoiCyAMKQMANwMAIAFB+A5qQQhqIgwgDSkDADcD\
ACABIAEpA7giNwP4DkHAABAWIgZFDRwgBiABKQP4DjcAACAGQThqIBApAwA3AAAgBkEwaiAOKQMANw\
AAIAZBKGogAikDADcAACAGQSBqIAopAwA3AAAgBkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhq\
IAwpAwA3AAAMBgsgBEH4DmogBUH4AhA5GiADQQBIDQECQAJAIAMNAEEBIQYMAQsgAxAWIgZFDR0gBk\
F8ai0AAEEDcUUNACAGQQAgAxA6GgsgBEGQEmogBEH4DmpB+AIQORogBCAEQfgOakHIARA5Ig9ByAFq\
IA9BkBJqQcgBakGpARA5IQEgD0HoI2ogD0H4DmpByAEQORogD0GIIWogAUGpARA5GiAPQYghaiAPLQ\
CwIiIBaiEKAkAgAUGoAUYNACAKQQBBqAEgAWsQOhoLQQAhAiAPQQA6ALAiIApBHzoAACAPQa8iaiIB\
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\
BjcDKCAAIAc3AyAgACAINwMYIAAgCTcDECAAIAo3AwggACALNwMAIANBgAFqJAAL+FsCDH8FfiMAQY\
AGayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOAgABAgsgASgC\
ACICQQJ0QbTTwABqKAIAIQMMEQtBICEFIAEoAgAiAg4YAQ8CDxADDwQFBgYHBwgPCQoLDwwNEBAOAQ\
sgASgCACECDA8LQcAAIQUMDQtBMCEFDAwLQRwhBQwLC0EwIQUMCgtBwAAhBQwJC0EQIQUMCAtBFCEF\
DAcLQRwhBQwGC0EwIQUMBQtBwAAhBQwEC0EcIQUMAwtBMCEFDAILQcAAIQUMAQtBGCEFCyAFIANGDQ\
BBASEBQTkhA0GtgcAAIQIMAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkAgAg4YAAECAwQFBgcICQoLDA0ODxAREhMUFRYaAAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQ\
BGpBFGpCADcCACAEQdAEakEcakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEak\
E0akIANwIAIARB0ARqQTxqQgA3AgAgBEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARB\
oANqQThqIgYgBEEoakE8aikCADcDACAEQaADakEwaiIHIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiCC\
AEQShqQSxqKQIANwMAIARBoANqQSBqIgkgBEEoakEkaikCADcDACAEQaADakEYaiIKIARBKGpBHGop\
AgA3AwAgBEGgA2pBEGoiCyAEQShqQRRqKQIANwMAIARBoANqQQhqIgwgBEEoakEMaikCADcDACAEIA\
QpAiw3A6ADIAIgAikDQCACQcgBaiIDLQAAIgGtfDcDQCACQcgAaiEFAkAgAUGAAUYNACAFIAFqQQBB\
gAEgAWsQOhoLQQAhASADQQA6AAAgAiAFQn8QESAEQShqQQhqIgUgAkEIaikDACIQNwMAIARBKGpBEG\
ogAkEQaikDACIRNwMAIARBKGpBGGogAkEYaikDACISNwMAIARBKGpBIGogAikDICITNwMAIARBKGpB\
KGogAkEoaikDACIUNwMAIAwgEDcDACALIBE3AwAgCiASNwMAIAkgEzcDACAIIBQ3AwAgByACQTBqKQ\
MANwMAIAYgAkE4aikDADcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIAVBwAAQTyACIAVByAAQORogA0EA\
OgAAQcAAEBYiAkUNGiACIAQpA6ADNwAAIAJBOGogBEGgA2pBOGopAwA3AAAgAkEwaiAEQaADakEwai\
kDADcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AAAgAkEYaiAEQaADakEY\
aikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBwAAhAwwyCyABKA\
IEIQIgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2\
AtAEIARBKGpBGGoiByAEQdAEakEYaikDADcDACAEQShqQRBqIgggBEHQBGpBEGopAwA3AwAgBEEoak\
EIaiIDIARB0ARqQQhqKQMANwMAIARBKGpBIGoiCSAEQdAEakEgaigCADYCACAEIAQpA9AENwMoIARB\
oANqQRBqIgogBEEoakEUaikCADcDACAEQaADakEIaiILIARBKGpBDGopAgA3AwAgBEGgA2pBGGoiDC\
AEQShqQRxqKQIANwMAIAQgBCkCLDcDoAMgAiACKQNAIAJByAFqIgUtAAAiAa18NwNAIAJByABqIQYC\
QCABQYABRg0AIAYgAWpBAEGAASABaxA6GgtBACEBIAVBADoAACACIAZCfxARIAMgAkEIaikDACIQNw\
MAIAggAkEQaikDACIRNwMAIAcgAkEYaikDACISNwMAIAkgAikDIDcDACAEQShqQShqIAJBKGopAwA3\
AwAgCyAQNwMAIAogETcDACAMIBI3AwAgBCACKQMAIhA3AyggBCAQNwOgAyADQSAQTyACIANByAAQOR\
ogBUEAOgAAQSAQFiICRQ0aIAIgBCkDoAM3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANq\
QRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBICEDDDELIAEoAgQhAiAEQdAEakEsakIANwIAIA\
RB0ARqQSRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIA\
NwLUBCAEQTA2AtAEIARBKGpBKGoiByAEQdAEakEoaikDADcDACAEQShqQSBqIgggBEHQBGpBIGopAw\
A3AwAgBEEoakEYaiIJIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCiAEQdAEakEQaikDADcDACAEQShq\
QQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEwaiAEQdAEakEwaigCADYCACAEIAQpA9AENwMoIARBoA\
NqQSBqIgsgBEEoakEkaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiDSAE\
QShqQRRqKQIANwMAIARBoANqQQhqIg4gBEEoakEMaikCADcDACAEQaADakEoaiIPIARBKGpBLGopAg\
A3AwAgBCAEKQIsNwOgAyACIAIpA0AgAkHIAWoiBS0AACIBrXw3A0AgAkHIAGohBgJAIAFBgAFGDQAg\
BiABakEAQYABIAFrEDoaC0EAIQEgBUEAOgAAIAIgBkJ/EBEgAyACQQhqKQMAIhA3AwAgCiACQRBqKQ\
MAIhE3AwAgCSACQRhqKQMAIhI3AwAgCCACKQMgIhM3AwAgByACQShqKQMAIhQ3AwAgDiAQNwMAIA0g\
ETcDACAMIBI3AwAgCyATNwMAIA8gFDcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIANBMBBPIAIgA0HIAB\
A5GiAFQQA6AABBMBAWIgJFDRogAiAEKQOgAzcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGg\
A2pBIGopAwA3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBE\
GgA2pBCGopAwA3AABBMCEDDDALIAEoAgQhAiAEQdAEakEcakIANwIAIARB0ARqQRRqQgA3AgAgBEHQ\
BGpBDGpCADcCACAEQgA3AtQEIARBIDYC0AQgBEEoakEYaiIHIARB0ARqQRhqKQMANwMAIARBKGpBEG\
oiCCAEQdAEakEQaikDADcDACAEQShqQQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEgaiIJIARB0ARq\
QSBqKAIANgIAIAQgBCkD0AQ3AyggBEGgA2pBEGoiCiAEQShqQRRqKQIANwMAIARBoANqQQhqIgsgBE\
EoakEMaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBCAEKQIsNwOgAyACIAIpAwAgAkHo\
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\
ECQgBEEoakE4aiIGIAVBOGopAAA3AwAgBEEoakEwaiIHIAVBMGopAAA3AwAgBEEoakEoaiIIIAVBKG\
opAAA3AwAgBEEoakEgaiIJIAVBIGopAAA3AwAgBEEoakEYaiIKIAVBGGopAAA3AwAgBEEoakEQaiIL\
IAVBEGopAAA3AwAgBEEoakEIaiIMIAVBCGopAAA3AwAgBCAFKQAANwMoQQAhASAFQQBByAEQOkGQAm\
pBADoAAEHAACEDQcAAEBYiAkUNGiACIAQpAyg3AAAgAkE4aiAGKQMANwAAIAJBMGogBykDADcAACAC\
QShqIAgpAwA3AAAgAkEgaiAJKQMANwAAIAJBGGogCikDADcAACACQRBqIAspAwA3AAAgAkEIaiAMKQ\
MANwAADCoLIAEoAgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEoakEQaiAE\
QdAEakEQaigCADYCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCAD\
cDACAEIAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEC9BACEBIAJB2ABqQQA6AAAgAkEQ\
akL+uevF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFiICRQ0aIAIgBCkDoAM3AAAgAk\
EIaiAFKQMANwAADCkLIAEoAgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEo\
akEQaiAEQdAEakEQaigCADYCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoak\
EMaikCADcDACAEIAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEC5BACEBIAJB2ABqQQA6\
AAAgAkEQakL+uevF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFiICRQ0aIAIgBCkDoA\
M3AAAgAkEIaiAFKQMANwAADCgLIAEoAgQhAkEUIQNBACEBIARB0ARqQRRqQQA2AgAgBEHQBGpBDGpC\
ADcCACAEQgA3AtQEIARBFDYC0AQgBEEoakEQaiAEQdAEakEQaikDADcDACAEQShqQQhqIARB0ARqQQ\
hqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAEQaADakEQaiIGIARBKGpBFGooAgA2AgAg\
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\
BEEoakEUaikCADcDACAEQaADakEIaiIJIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAJBKGogBE\
GgA2oQJyAFIAEpAwA3AwAgBiAIKQMANwMAIAcgCSkDADcDACAEIAQpA6ADNwMoIAJCADcDAEEAIQEg\
AkHoAGpBADoAACACQQApA/CNQDcDCCACQRBqQQApA/iNQDcDACACQRhqQQApA4COQDcDACACQSBqQQ\
ApA4iOQDcDAEEgEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAFKQMANwAAIAJBEGogBikDADcAACACQQhq\
IAcpAwA3AAAMIAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEcakIANw\
IAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB0ARqQTxqQgA3AgAg\
BEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARBoANqQThqIARBKGpBPGopAgA3AwBBMC\
EDIARBoANqQTBqIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiASAEQShqQSxqKQIANwMAIARBoANqQSBq\
IgUgBEEoakEkaikCADcDACAEQaADakEYaiIGIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiByAEQShqQR\
RqKQIANwMAIARBoANqQQhqIgggBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQ\
IiAEQShqQShqIgkgASkDADcDACAEQShqQSBqIgogBSkDADcDACAEQShqQRhqIgUgBikDADcDACAEQS\
hqQRBqIgYgBykDADcDACAEQShqQQhqIgcgCCkDADcDACAEIAQpA6ADNwMoIAJByABqQgA3AwAgAkIA\
NwNAQQAhASACQThqQQApA6iPQDcDACACQTBqQQApA6CPQDcDACACQShqQQApA5iPQDcDACACQSBqQQ\
ApA5CPQDcDACACQRhqQQApA4iPQDcDACACQRBqQQApA4CPQDcDACACQQhqQQApA/iOQDcDACACQQAp\
A/COQDcDACACQdABakEAOgAAQTAQFiICRQ0aIAIgBCkDKDcAACACQShqIAkpAwA3AAAgAkEgaiAKKQ\
MANwAAIAJBGGogBSkDADcAACACQRBqIAYpAwA3AAAgAkEIaiAHKQMANwAADB8LIAEoAgQhAiAEQdAE\
akEMakIANwIAIARB0ARqQRRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQS\
xqQgA3AgAgBEHQBGpBNGpCADcCACAEQdAEakE8akIANwIAIARCADcC1ARBwAAhAyAEQcAANgLQBCAE\
QShqIARB0ARqQcQAEDkaIARBoANqQThqIgEgBEEoakE8aikCADcDACAEQaADakEwaiIFIARBKGpBNG\
opAgA3AwAgBEGgA2pBKGoiBiAEQShqQSxqKQIANwMAIARBoANqQSBqIgcgBEEoakEkaikCADcDACAE\
QaADakEYaiIIIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiCSAEQShqQRRqKQIANwMAIARBoANqQQhqIg\
ogBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIiAEQShqQThqIgsgASkDADcD\
ACAEQShqQTBqIgwgBSkDADcDACAEQShqQShqIgUgBikDADcDACAEQShqQSBqIgYgBykDADcDACAEQS\
hqQRhqIgcgCCkDADcDACAEQShqQRBqIgggCSkDADcDACAEQShqQQhqIgkgCikDADcDACAEIAQpA6AD\
NwMoIAJByABqQgA3AwAgAkIANwNAQQAhASACQThqQQApA+iOQDcDACACQTBqQQApA+COQDcDACACQS\
hqQQApA9iOQDcDACACQSBqQQApA9COQDcDACACQRhqQQApA8iOQDcDACACQRBqQQApA8COQDcDACAC\
QQhqQQApA7iOQDcDACACQQApA7COQDcDACACQdABakEAOgAAQcAAEBYiAkUNGiACIAQpAyg3AAAgAk\
E4aiALKQMANwAAIAJBMGogDCkDADcAACACQShqIAUpAwA3AAAgAkEgaiAGKQMANwAAIAJBGGogBykD\
ADcAACACQRBqIAgpAwA3AAAgAkEIaiAJKQMANwAADB4LIANBAEgNASABKAIEIQcCQAJAIAMNAEEBIQ\
IMAQsgAxAWIgJFDRsgAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgByAHQfACaiIILQAAIgFqQcgBaiEG\
AkAgAUGoAUYNACAGQQBBqAEgAWsQOhoLQQAhBSAIQQA6AAAgBkEfOgAAIAdB7wJqIgEgAS0AAEGAAX\
I6AAADQCAHIAVqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFB\
AmoiBiAGLQAAIAFBygFqLQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQagBRw\
0ACyAHECQgBEEoaiAHQcgBEDkaQQAhASAHQQBByAEQOkHwAmpBADoAACAEQQA2AqADIARBoANqQQRy\
QQBBqAEQOhogBEGoATYCoAMgBEHQBGogBEGgA2pBrAEQORogBEEoakHIAWogBEHQBGpBBHJBqAEQOR\
ogBEEoakHwAmpBADoAACAEQShqIAIgAxAxDB0LIANBAEgNACABKAIEIQcgAw0BQQEhAgwCCxBpAAsg\
AxAWIgJFDRggAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgByAHQdACaiIILQAAIgFqQcgBaiEGAkAgAU\
GIAUYNACAGQQBBiAEgAWsQOhoLQQAhBSAIQQA6AAAgBkEfOgAAIAdBzwJqIgEgAS0AAEGAAXI6AAAD\
QCAHIAVqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFBAmoiBi\
AGLQAAIAFBygFqLQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQYgBRw0ACyAH\
ECQgBEEoaiAHQcgBEDkaQQAhASAHQQBByAEQOkHQAmpBADoAACAEQQA2AqADIARBoANqQQRyQQBBiA\
EQOhogBEGIATYCoAMgBEHQBGogBEGgA2pBjAEQORogBEEoakHIAWogBEHQBGpBBHJBiAEQORogBEEo\
akHQAmpBADoAACAEQShqIAIgAxAyDBkLIAEoAgQhAiAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3Ag\
AgBEIANwLUBEEYIQMgBEEYNgLQBCAEQShqQRBqIARB0ARqQRBqKQMANwMAIARBKGpBCGogBEHQBGpB\
CGopAwA3AwAgBEEoakEYaiAEQdAEakEYaigCADYCACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBE\
GgA2pBEGoiBiAEQShqQRRqKQIANwMAIAQgBCkD0AQ3AyggBCAEKQIsNwOgAyACIAJBIGogBEGgA2oQ\
MCACQgA3AwBBACEBIAJB4ABqQQA6AAAgAkEAKQP4kUA3AwggAkEQakEAKQOAkkA3AwAgAkEYakEAKQ\
OIkkA3AwBBGBAWIgJFDRcgAiAEKQOgAzcAACACQRBqIAYpAwA3AAAgAkEIaiAFKQMANwAADBgLQcAA\
QQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQ\
QgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQUAAAtBHEEB\
QQAoAvjUQCIEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKAL41EAiBEEEIA\
QbEQUAAAtBwABBAUEAKAL41EAiBEEEIAQbEQUAAAtBEEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EQQQFB\
ACgC+NRAIgRBBCAEGxEFAAALQRRBAUEAKAL41EAiBEEEIAQbEQUAAAtBFEEBQQAoAvjUQCIEQQQgBB\
sRBQAAC0EcQQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAo\
AvjUQCIEQQQgBBsRBQAAC0HAAEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EcQQFBACgC+NRAIgRBBCAEGx\
EFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0HAAEEBQQAo\
AvjUQCIEQQQgBBsRBQAACyADQQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQ\
UAAAtBGEEBQQAoAvjUQCIEQQQgBBsRBQAACyAAIAI2AgQgACABNgIAIABBCGogAzYCACAEQYAGaiQA\
C5xWAhp/An4jAEGwAmsiAyQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCAA4YAAECAw\
QFBgcICQoLDA0ODxAREhMUFRYXAAsgACgCBCIAQcgAaiEEAkBBgAEgAEHIAWotAAAiBWsiBiACTw0A\
AkAgBUUNACAEIAVqIAEgBhA5GiAAIAApA0BCgAF8NwNAIAAgBEIAEBEgASAGaiEBIAIgBmshAgsgAi\
ACQQd2IgYgAkEARyACQf8AcUVxIgdrIgVBB3QiCGshAiAFRQ1FIAhFDUUgBkEAIAdrakEHdCEGIAEh\
BQNAIAAgACkDQEKAAXw3A0AgACAFQgAQESAFQYABaiEFIAZBgH9qIgYNAAxGCwsgBCAFaiABIAIQOR\
ogBSACaiECDEULIAAoAgQiAEHIAGohBAJAQYABIABByAFqLQAAIgVrIgYgAk8NAAJAIAVFDQAgBCAF\
aiABIAYQORogACAAKQNAQoABfDcDQCAAIARCABARIAEgBmohASACIAZrIQILIAIgAkEHdiIGIAJBAE\
cgAkH/AHFFcSIHayIFQQd0IghrIQIgBUUNQSAIRQ1BIAZBACAHa2pBB3QhBiABIQUDQCAAIAApA0BC\
gAF8NwNAIAAgBUIAEBEgBUGAAWohBSAGQYB/aiIGDQAMQgsLIAQgBWogASACEDkaIAUgAmohAgxBCy\
AAKAIEIgBByABqIQQCQEGAASAAQcgBai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDkaIAAg\
ACkDQEKAAXw3A0AgACAEQgAQESABIAZqIQEgAiAGayECCyACIAJBB3YiBiACQQBHIAJB/wBxRXEiB2\
siBUEHdCIIayECIAVFDT0gCEUNPSAGQQAgB2tqQQd0IQYgASEFA0AgACAAKQNAQoABfDcDQCAAIAVC\
ABARIAVBgAFqIQUgBkGAf2oiBg0ADD4LCyAEIAVqIAEgAhA5GiAFIAJqIQIMPQsgACgCBCIAQShqIQ\
QCQEHAACAAQegAai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDkaIAAgACkDAELAAHw3AwAg\
ACAEQQAQEyABIAZqIQEgAiAGayECCyACIAJBBnYiBiACQQBHIAJBP3FFcSIHayIFQQZ0IghrIQIgBU\
UNOSAIRQ05IAZBACAHa2pBBnQhBiABIQUDQCAAIAApAwBCwAB8NwMAIAAgBUEAEBMgBUHAAGohBSAG\
QUBqIgYNAAw6CwsgBCAFaiABIAIQORogBSACaiECDDkLIAAoAgQiCEHpAGotAABBBnQgCC0AaGoiAE\
UNNiAIIAEgAkGACCAAayIAIAAgAksbIgUQMxogAiAFayICRQ1CIANB+ABqQRBqIAhBEGoiACkDADcD\
ACADQfgAakEYaiAIQRhqIgYpAwA3AwAgA0H4AGpBIGogCEEgaiIEKQMANwMAIANB+ABqQTBqIAhBMG\
opAwA3AwAgA0H4AGpBOGogCEE4aikDADcDACADQfgAakHAAGogCEHAAGopAwA3AwAgA0H4AGpByABq\
IAhByABqKQMANwMAIANB+ABqQdAAaiAIQdAAaikDADcDACADQfgAakHYAGogCEHYAGopAwA3AwAgA0\
H4AGpB4ABqIAhB4ABqKQMANwMAIAMgCCkDCDcDgAEgAyAIKQMoNwOgASAIQekAai0AACEHIAgtAGoh\
CSADIAgtAGgiCjoA4AEgAyAIKQMAIh03A3ggAyAJIAdFckECciIHOgDhASADQegBakEYaiIJIAQpAg\
A3AwAgA0HoAWpBEGoiBCAGKQIANwMAIANB6AFqQQhqIgYgACkCADcDACADIAgpAgg3A+gBIANB6AFq\
IANB+ABqQShqIAogHSAHEBkgCSgCACEHIAQoAgAhBCAGKAIAIQkgAygChAIhCiADKAL8ASELIAMoAv\
QBIQwgAygC7AEhDSADKALoASEOIAggCCkDABApIAgoApABIgZBN08NEyAIQZABaiAGQQV0aiIAQSBq\
IAo2AgAgAEEcaiAHNgIAIABBGGogCzYCACAAQRRqIAQ2AgAgAEEQaiAMNgIAIABBDGogCTYCACAAQQ\
hqIA02AgAgAEEEaiAONgIAIAggBkEBajYCkAEgCEEoaiIAQgA3AwAgAEEIakIANwMAIABBEGpCADcD\
ACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAhBADsBaC\
AIQQhqIgAgCCkDcDcDACAAQQhqIAhB+ABqKQMANwMAIABBEGogCEGAAWopAwA3AwAgAEEYaiAIQYgB\
aikDADcDACAIIAgpAwBCAXw3AwAgASAFaiEBDDYLIAAoAgQiBEHIAWohCgJAQZABIARB2AJqLQAAIg\
BrIgggAksNAAJAIABFDQAgCiAAaiABIAgQORogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFq\
LQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIA\
BBA2oiBiAGLQAAIABBywFqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJCABIAhqIQELIAEgAkGQAW5B\
kAFsIgBqIQcgAiAAayEJIAJBjwFNDTMgAEUNMwNAIAFBkAFqIQhBACEFA0AgBCAFaiIAIAAtAAAgAS\
AFaiIGLQAAczoAACAAQQFqIgIgAi0AACAGQQFqLQAAczoAACAAQQJqIgIgAi0AACAGQQJqLQAAczoA\
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\
MGogGykDADcDACAKQThqIBwpAwA3AwAgAy0A4gEhDiADLQDhASEXIAMgAy0A4AEiGDoAcCADIAMpA3\
giHjcDCCADIA4gF0VyQQJyIg46AHEgA0HoAWpBGGoiFyAHKQIANwMAIANB6AFqQRBqIgcgBikCADcD\
ACADQegBakEIaiIGIAUpAgA3AwAgAyALKQIANwPoASADQegBaiAKIBggHiAOEBkgFygCACEOIAcoAg\
AhByAGKAIAIRcgAygChAIhGCADKAL8ASEZIAMoAvQBIRogAygC7AEhGyADKALoASEcIAggCCkDABAp\
IAgoApABIgZBN08NCSANIAZBBXRqIgUgGDYCHCAFIA42AhggBSAZNgIUIAUgBzYCECAFIBo2AgwgBS\
AXNgIIIAUgGzYCBCAFIBw2AgAgCCAGQQFqNgKQAQsgCCAIKQMAIB18Ih43AwAgAiAASQ0JIAEgAGoh\
ASACIABrIgJBgAhLDQALCyACRQ0TIAggASACEDMaIAggCCkDABApDBMLIAAgAkGghcAAEEkACyAFQc\
AAQeCEwAAQSQALIAZBwABB8ITAABBJAAsgBkEgQYCFwAAQSQALIANBkAJqQQhqIgEgGjYCACADQZAC\
akEQaiIAIBg2AgAgA0GQAmpBGGoiBSAONgIAIAMgGTYCnAIgA0GBAWoiBiABKQMANwAAIAMgFzYCpA\
IgA0GJAWoiASAAKQMANwAAIAMgBzYCrAIgA0GRAWoiACAFKQMANwAAIAMgGzYClAIgAyAcNgKQAiAD\
IAMpA5ACNwB5IANBCGpBGGogACkAADcDACADQQhqQRBqIAEpAAA3AwAgA0EIakEIaiAGKQAANwMAIA\
MgAykAeTcDCEGQksAAIANBCGpBgIbAAEH4hsAAEEAACyADQZACakEIaiIBIBQ2AgAgA0GQAmpBEGoi\
ACASNgIAIANBkAJqQRhqIgUgEDYCACADIBM2ApwCIANBgQFqIgYgASkDADcAACADIBE2AqQCIANBiQ\
FqIgEgACkDADcAACADIA82AqwCIANBkQFqIgAgBSkDADcAACADIBU2ApQCIAMgFjYCkAIgAyADKQOQ\
AjcAeSADQQhqQRhqIAApAAA3AwAgA0EIakEQaiABKQAANwMAIANBCGpBCGogBikAADcDACADIAMpAH\
k3AwhBkJLAACADQQhqQYCGwABB+IbAABBAAAsgA0GYAmoiASAXNgIAIANBoAJqIgAgBzYCACADQagC\
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\
NgIcIAMgAUEgaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiCzYCICADIAFBGG\
ooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIgw2AhggAygCACENIAMoAgQhDiAD\
KAIIIQ8gAygCECEQIAMoAgwhESADKAIUIRIgAyABQSRqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdk\
GA/gNxIAJBGHZyciITNgIkIAMgAUEoaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2\
cnIiFDYCKCADIAFBMGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIhU2AjAgAy\
ABQSxqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIWNgIsIAMgAUE0aigAACIC\
QRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiAjYCNCADIAFBOGooAAAiF0EYdCAXQQh0QY\
CA/AdxciAXQQh2QYD+A3EgF0EYdnJyIhc2AjggAyABQTxqKAAAIhhBGHQgGEEIdEGAgPwHcXIgGEEI\
dkGA/gNxIBhBGHZyciIYNgI8IAggEyAKcyAYcyAMIBBzIBVzIBEgDnMgE3MgF3NBAXciGXNBAXciGn\
NBAXciGyAKIBJzIAJzIBAgD3MgFHMgGHNBAXciHHNBAXciHXMgGCACcyAdcyAVIBRzIBxzIBtzQQF3\
Ih5zQQF3Ih9zIBogHHMgHnMgGSAYcyAbcyAXIBVzIBpzIBYgE3MgGXMgCyAMcyAXcyASIBFzIBZzIA\
8gDXMgC3MgAnNBAXciIHNBAXciIXNBAXciInNBAXciI3NBAXciJHNBAXciJXNBAXciJnNBAXciJyAd\
ICFzIAIgFnMgIXMgFCALcyAgcyAdc0EBdyIoc0EBdyIpcyAcICBzIChzIB9zQQF3IipzQQF3IitzIB\
8gKXMgK3MgHiAocyAqcyAnc0EBdyIsc0EBdyItcyAmICpzICxzICUgH3MgJ3MgJCAecyAmcyAjIBtz\
ICVzICIgGnMgJHMgISAZcyAjcyAgIBdzICJzIClzQQF3Ii5zQQF3Ii9zQQF3IjBzQQF3IjFzQQF3Ij\
JzQQF3IjNzQQF3IjRzQQF3IjUgKyAvcyApICNzIC9zICggInMgLnMgK3NBAXciNnNBAXciN3MgKiAu\
cyA2cyAtc0EBdyI4c0EBdyI5cyAtIDdzIDlzICwgNnMgOHMgNXNBAXciOnNBAXciO3MgNCA4cyA6cy\
AzIC1zIDVzIDIgLHMgNHMgMSAncyAzcyAwICZzIDJzIC8gJXMgMXMgLiAkcyAwcyA3c0EBdyI8c0EB\
dyI9c0EBdyI+c0EBdyI/c0EBdyJAc0EBdyJBc0EBdyJCc0EBdyJDIDkgPXMgNyAxcyA9cyA2IDBzID\
xzIDlzQQF3IkRzQQF3IkVzIDggPHMgRHMgO3NBAXciRnNBAXciR3MgOyBFcyBHcyA6IERzIEZzIENz\
QQF3IkhzQQF3IklzIEIgRnMgSHMgQSA7cyBDcyBAIDpzIEJzID8gNXMgQXMgPiA0cyBAcyA9IDNzID\
9zIDwgMnMgPnMgRXNBAXciSnNBAXciS3NBAXciTHNBAXciTXNBAXciTnNBAXciT3NBAXciUHNBAXdq\
IEYgSnMgRCA+cyBKcyBHc0EBdyJRcyBJc0EBdyJSIEUgP3MgS3MgUXNBAXciUyBMIEEgOiA5IDwgMS\
AmIB8gKCAhIBcgEyAQIAhBHnciVGogDiAFIAdBHnciECAGcyAIcSAGc2pqIA0gBCAIQQV3aiAGIAVz\
IAdxIAVzampBmfOJ1AVqIg5BBXdqQZnzidQFaiJVQR53IgggDkEedyINcyAGIA9qIA4gVCAQc3EgEH\
NqIFVBBXdqQZnzidQFaiIOcSANc2ogECARaiBVIA0gVHNxIFRzaiAOQQV3akGZ84nUBWoiEEEFd2pB\
mfOJ1AVqIhFBHnciD2ogDCAIaiARIBBBHnciEyAOQR53IgxzcSAMc2ogEiANaiAMIAhzIBBxIAhzai\
ARQQV3akGZ84nUBWoiEUEFd2pBmfOJ1AVqIhJBHnciCCARQR53IhBzIAogDGogESAPIBNzcSATc2og\
EkEFd2pBmfOJ1AVqIgpxIBBzaiALIBNqIBAgD3MgEnEgD3NqIApBBXdqQZnzidQFaiIMQQV3akGZ84\
nUBWoiD0EedyILaiAVIApBHnciF2ogCyAMQR53IhNzIBQgEGogDCAXIAhzcSAIc2ogD0EFd2pBmfOJ\
1AVqIhRxIBNzaiAWIAhqIA8gEyAXc3EgF3NqIBRBBXdqQZnzidQFaiIVQQV3akGZ84nUBWoiFiAVQR\
53IhcgFEEedyIIc3EgCHNqIAIgE2ogCCALcyAVcSALc2ogFkEFd2pBmfOJ1AVqIhRBBXdqQZnzidQF\
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\
ckEAQYABEDoaIAJBgAE2AgAgAkGwAWogAkGEARA5GiAEQdAAaiACQbABakEEckGAARA5GiAEQcgAak\
IANwMAIARCADcDQCAEQQA6ANABIARBACkDsI5ANwMAIARBCGpBACkDuI5ANwMAIARBEGpBACkDwI5A\
NwMAIARBGGpBACkDyI5ANwMAIARBIGpBACkD0I5ANwMAIARBKGpBACkD2I5ANwMAIARBMGpBACkD4I\
5ANwMAIARBOGpBACkD6I5ANwMAQRQhBQwjC0HwABAWIgRFDQwgAkGwAWpBCGoQVSAEQSBqIAJB2AFq\
KQMANwMAIARBGGogAkGwAWpBIGopAwA3AwAgBEEQaiACQbABakEYaikDADcDACAEQQhqIAJBsAFqQR\
BqKQMANwMAIAQgAikDuAE3AwAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIA\
IAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOR\
ogBEHgAGogAkGwAWpBPGopAgA3AAAgBEHYAGogAkGwAWpBNGopAgA3AAAgBEHQAGogAkGwAWpBLGop\
AgA3AAAgBEHIAGogAkGwAWpBJGopAgA3AAAgBEHAAGogAkGwAWpBHGopAgA3AAAgBEE4aiACQbABak\
EUaikCADcAACAEQTBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ACggBEEAOgBoQQMhBQwiCwJAAkAC\
QAJAIANBuoDAAEEKEFFFDQAgA0HEgMAAQQoQUUUNASADQc6AwABBChBRRQ0CIANB2IDAAEEKEFFFDQ\
MgA0HogMAAQQoQUQ0MQegAEBYiBEUNFiACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRq\
QgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAk\
HEABA5GiAEQdgAaiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbAB\
akEsaikCADcAACAEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAk\
GwAWpBFGopAgA3AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARCADcDACAEQQA6AGAg\
BEEAKQPYjUA3AwggBEEQakEAKQPgjUA3AwAgBEEYakEAKALojUA2AgBBCyEFDCULQeACEBYiBEUNDy\
AEQQBByAEQOiEFIAJBADYCACACQQRyQQBBkAEQOhogAkGQATYCACACQbABaiACQZQBEDkaIAVByAFq\
IAJBsAFqQQRyQZABEDkaIAVBADoA2AJBBSEFDCQLQdgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCAC\
ACQQRyQQBBiAEQOhogAkGIATYCACACQbABaiACQYwBEDkaIAVByAFqIAJBsAFqQQRyQYgBEDkaIAVB\
ADoA0AJBBiEFDCMLQbgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBB6AAQOhogAkHoAD\
YCACACQbABaiACQewAEDkaIAVByAFqIAJBsAFqQQRyQegAEDkaIAVBADoAsAJBByEFDCILQZgCEBYi\
BEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBByAAQOhogAkHIADYCACACQbABaiACQcwAEDkaIA\
VByAFqIAJBsAFqQQRyQcgAEDkaIAVBADoAkAJBCCEFDCELAkAgA0HigMAAQQMQUUUNACADQeWAwABB\
AxBRDQhB4AAQFiIERQ0RIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQS\
xqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDkaIARB\
0ABqIAJBsAFqQTxqKQIANwAAIARByABqIAJBsAFqQTRqKQIANwAAIARBwABqIAJBsAFqQSxqKQIANw\
AAIARBOGogAkGwAWpBJGopAgA3AAAgBEEwaiACQbABakEcaikCADcAACAEQShqIAJBsAFqQRRqKQIA\
NwAAIARBIGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAGCAEQv6568XpjpWZEDcDECAEQoHGlLqW8e\
rmbzcDCCAEQgA3AwAgBEEAOgBYQQohBQwhC0HgABAWIgRFDQ8gAkEMakIANwIAIAJBFGpCADcCACAC\
QRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQc\
AANgIAIAJBsAFqIAJBxAAQORogBEHQAGogAkGwAWpBPGopAgA3AAAgBEHIAGogAkGwAWpBNGopAgA3\
AAAgBEHAAGogAkGwAWpBLGopAgA3AAAgBEE4aiACQbABakEkaikCADcAACAEQTBqIAJBsAFqQRxqKQ\
IANwAAIARBKGogAkGwAWpBFGopAgA3AAAgBEEgaiACQbABakEMaikCADcAACAEIAIpArQBNwAYIARC\
/rnrxemOlZkQNwMQIARCgcaUupbx6uZvNwMIIARCADcDACAEQQA6AFhBCSEFDCALAkACQAJAAkAgAy\
kAAELTkIWa08WMmTRRDQAgAykAAELTkIWa08XMmjZRDQEgAykAAELTkIWa0+WMnDRRDQIgAykAAELT\
kIWa06XNmDJRDQMgAykAAELTkIXa1KiMmThRDQcgAykAAELTkIXa1MjMmjZSDQpB2AIQFiIERQ0eIA\
RBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGIARA6GiACQYgBNgIAIAJBsAFqIAJBjAEQORogBUHIAWog\
AkGwAWpBBHJBiAEQORogBUEAOgDQAkEWIQUMIwtB4AIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIA\
JBBHJBAEGQARA6GiACQZABNgIAIAJBsAFqIAJBlAEQORogBUHIAWogAkGwAWpBBHJBkAEQORogBUEA\
OgDYAkENIQUMIgtB2AIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGIARA6GiACQYgBNg\
IAIAJBsAFqIAJBjAEQORogBUHIAWogAkGwAWpBBHJBiAEQORogBUEAOgDQAkEOIQUMIQtBuAIQFiIE\
RQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEHoABA6GiACQegANgIAIAJBsAFqIAJB7AAQORogBU\
HIAWogAkGwAWpBBHJB6AAQORogBUEAOgCwAkEPIQUMIAtBmAIQFiIERQ0UIARBAEHIARA6IQUgAkEA\
NgIAIAJBBHJBAEHIABA6GiACQcgANgIAIAJBsAFqIAJBzAAQORogBUHIAWogAkGwAWpBBHJByAAQOR\
ogBUEAOgCQAkEQIQUMHwtB8AAQFiIERQ0UIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJB\
JGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABai\
ACQcQAEDkaIARB4ABqIAJBsAFqQTxqKQIANwAAIARB2ABqIAJBsAFqQTRqKQIANwAAIARB0ABqIAJB\
sAFqQSxqKQIANwAAIARByABqIAJBsAFqQSRqKQIANwAAIARBwABqIAJBsAFqQRxqKQIANwAAIARBOG\
ogAkGwAWpBFGopAgA3AAAgBEEwaiACQbABakEMaikCADcAACAEIAIpArQBNwAoIARCADcDACAEQQA6\
AGggBEEAKQOQjkA3AwggBEEQakEAKQOYjkA3AwAgBEEYakEAKQOgjkA3AwAgBEEgakEAKQOojkA3Aw\
BBESEFDB4LQfAAEBYiBEUNFCACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAg\
AkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA5Gi\
AEQeAAaiACQbABakE8aikCADcAACAEQdgAaiACQbABakE0aikCADcAACAEQdAAaiACQbABakEsaikC\
ADcAACAEQcgAaiACQbABakEkaikCADcAACAEQcAAaiACQbABakEcaikCADcAACAEQThqIAJBsAFqQR\
RqKQIANwAAIARBMGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAKCAEQgA3AwAgBEEAOgBoIARBACkD\
8I1ANwMIIARBEGpBACkD+I1ANwMAIARBGGpBACkDgI5ANwMAIARBIGpBACkDiI5ANwMAQRIhBQwdC0\
HYARAWIgRFDRQgAkEANgIAIAJBBHJBAEGAARA6GiACQYABNgIAIAJBsAFqIAJBhAEQORogBEHQAGog\
AkGwAWpBBHJBgAEQORogBEHIAGpCADcDACAEQgA3A0AgBEEAOgDQASAEQQApA/COQDcDACAEQQhqQQ\
ApA/iOQDcDACAEQRBqQQApA4CPQDcDACAEQRhqQQApA4iPQDcDACAEQSBqQQApA5CPQDcDACAEQShq\
QQApA5iPQDcDACAEQTBqQQApA6CPQDcDACAEQThqQQApA6iPQDcDAEETIQUMHAtB+AIQFiIERQ0VIA\
RBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGoARA6GiACQagBNgIAIAJBsAFqIAJBrAEQORogBUHIAWog\
AkGwAWpBBHJBqAEQORogBUEAOgDwAkEVIQUMGwsgA0HygMAAQQUQUUUNFyADQZOBwABBBRBRDQFB6A\
AQFiIERQ0WIARCADcDACAEQQApA/iRQDcDCCAEQRBqQQApA4CSQDcDACAEQRhqQQApA4iSQDcDACAC\
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\
QEEAQbTVwAA2ArzVQEEAQcTVwAA2AtDVQEEAQbzVwAA2AsTVQEEAQQA2ArjYQEEAQczVwAA2AtjVQE\
EAQcTVwAA2AszVQEEAQczVwAA2AtTVQEEAQdTVwAA2AuDVQEEAQdTVwAA2AtzVQEEAQdzVwAA2AujV\
QEEAQdzVwAA2AuTVQEEAQeTVwAA2AvDVQEEAQeTVwAA2AuzVQEEAQezVwAA2AvjVQEEAQezVwAA2Av\
TVQEEAQfTVwAA2AoDWQEEAQfTVwAA2AvzVQEEAQfzVwAA2AojWQEEAQfzVwAA2AoTWQEEAQYTWwAA2\
ApDWQEEAQYTWwAA2AozWQEEAQYzWwAA2ApjWQEEAQZTWwAA2AqDWQEEAQYzWwAA2ApTWQEEAQZzWwA\
A2AqjWQEEAQZTWwAA2ApzWQEEAQaTWwAA2ArDWQEEAQZzWwAA2AqTWQEEAQazWwAA2ArjWQEEAQaTW\
wAA2AqzWQEEAQbTWwAA2AsDWQEEAQazWwAA2ArTWQEEAQbzWwAA2AsjWQEEAQbTWwAA2ArzWQEEAQc\
TWwAA2AtDWQEEAQbzWwAA2AsTWQEEAQczWwAA2AtjWQEEAQcTWwAA2AszWQEEAQdTWwAA2AuDWQEEA\
QczWwAA2AtTWQEEAQdzWwAA2AujWQEEAQdTWwAA2AtzWQEEAQeTWwAA2AvDWQEEAQdzWwAA2AuTWQE\
EAQezWwAA2AvjWQEEAQeTWwAA2AuzWQEEAQfTWwAA2AoDXQEEAQezWwAA2AvTWQEEAQfzWwAA2AojX\
QEEAQfTWwAA2AvzWQEEAQYTXwAA2ApDXQEEAQfzWwAA2AoTXQEEAIAY2AqDYQEEAQYTXwAA2AozXQE\
EAIAhBWGoiADYCmNhAIAYgAEEBcjYCBCAIIAZqQVxqQSg2AgBBAEGAgIABNgK82EALQQAhAUEAKAKY\
2EAiACACTQ0AQQAgACACayIBNgKY2EBBAEEAKAKg2EAiACACaiIFNgKg2EAgBSABQQFyNgIEIAAgAk\
EDcjYCBCAAQQhqDwsgAQu5JQIDfx5+IwBBwABrIgNBOGpCADcDACADQTBqQgA3AwAgA0EoakIANwMA\
IANBIGpCADcDACADQRhqQgA3AwAgA0EQakIANwMAIANBCGpCADcDACADQgA3AwACQCACRQ0AIAEgAk\
EGdGohBCAAKQMQIQYgACkDCCEHIAApAwAhCANAIAMgAUEYaikAACIJIAEpAAAiCiABQThqKQAAIgtC\
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\
NwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANw\
MAIAFBCGpBCGogA0EIaikDADcDACABIAMpAwA3AwggAykDQCEPIAFBCGpByABqIANByABqEEMgASAP\
NwNIIAIgAUEIakHQARA5GkEAIQMMHwsgAigCBCEDQdABEBYiAkUNBiABQQhqQThqIANBOGopAwA3Aw\
AgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAg\
AUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgAS\
ADKQMANwMIIAMpA0AhDyABQQhqQcgAaiADQcgAahBDIAEgDzcDSCACIAFBCGpB0AEQORpBASEDDB4L\
IAIoAgQhA0HQARAWIgJFDQYgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQ\
hqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhq\
QRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADKQNAIQ8gAUEIakHIAG\
ogA0HIAGoQQyABIA83A0ggAiABQQhqQdABEDkaQQIhAwwdCyACKAIEIQNB8AAQFiICRQ0GIAFBCGpB\
IGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCD\
cDECADKQMAIQ8gAUEIakEoaiADQShqEDcgASAPNwMIIAIgAUEIakHwABA5GkEDIQMMHAsgAigCBCED\
QfgOEBYiAkUNBiABQQhqQYgBaiADQYgBaikDADcDACABQQhqQYABaiADQYABaikDADcDACABQQhqQf\
gAaiADQfgAaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpB\
IGogA0EgaikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBwA\
BqIANBwABqKQMANwMAIAFBCGpByABqIANByABqKQMANwMAIAFBCGpB0ABqIANB0ABqKQMANwMAIAFB\
CGpB2ABqIANB2ABqKQMANwMAIAFBCGpB4ABqIANB4ABqKQMANwMAIAEgAykDcDcDeCABIAMpAwg3Ax\
AgASADKQMoNwMwIAMpAwAhDyADLQBqIQQgAy0AaSEFIAMtAGghBgJAIAMoApABQQV0IgcNAEEAIQcM\
GwsgAUGAD2pBGGoiCCADQZQBaiIJQRhqKQAANwMAIAFBgA9qQRBqIgogCUEQaikAADcDACABQYAPak\
EIaiILIAlBCGopAAA3AwAgASAJKQAANwOADyADQdQBaiEJQQAgB0FgakEFdmshDCABQbwBaiEDQQIh\
BwNAIANBYGoiDSABKQOADzcAACANQRhqIAgpAwA3AAAgDUEQaiAKKQMANwAAIA1BCGogCykDADcAAA\
JAAkAgDCAHaiIOQQJGDQAgCCAJQWBqIg1BGGopAAA3AwAgCiANQRBqKQAANwMAIAsgDUEIaikAADcD\
ACABIA0pAAA3A4APIAdBOEcNARBqAAsgB0F/aiEHDBwLIAMgASkDgA83AAAgA0EYaiAIKQMANwAAIA\
NBEGogCikDADcAACADQQhqIAspAwA3AAAgDkEBRg0bIAggCUEYaikAADcDACAKIAlBEGopAAA3AwAg\
CyAJQQhqKQAANwMAIAEgCSkAADcDgA8gA0HAAGohAyAHQQJqIQcgCUHAAGohCQwACwsQbgALEG8AC0\
HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjU\
QCIBQQQgARsRBQAAC0HwAEEIQQAoAvjUQCIBQQQgARsRBQAAC0H4DkEIQQAoAvjUQCIBQQQgARsRBQ\
AACyACKAIEIQMCQEHoABAWIgJFDQAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBGGogA0EYaikDADcD\
ACABIAMpAwg3AxAgAykDACEPIAFBCGpBIGogA0EgahA3IAEgDzcDCCACIAFBCGpB6AAQORpBFyEDDB\
QLQegAQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgCEBYiAkUNACABQQhqIANByAEQORog\
AUEIakHIAWogA0HIAWoQRCACIAFBCGpB2AIQORpBFiEDDBMLQdgCQQhBACgC+NRAIgFBBCABGxEFAA\
ALIAIoAgQhAwJAQfgCEBYiAkUNACABQQhqIANByAEQORogAUEIakHIAWogA0HIAWoQRSACIAFBCGpB\
+AIQORpBFSEDDBILQfgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgBEBYiAkUNACABQQ\
hqQThqIANBOGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhq\
QSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQ\
hqIANBCGopAwA3AwAgASADKQMANwMIIANByABqKQMAIQ8gAykDQCEQIAFBCGpB0ABqIANB0ABqEEMg\
AUEIakHIAGogDzcDACABIBA3A0ggAiABQQhqQdgBEDkaQRQhAwwRC0HYAUEIQQAoAvjUQCIBQQQgAR\
sRBQAACyACKAIEIQMCQEHYARAWIgJFDQAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikD\
ADcDACABQQhqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDAD\
cDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADQcgAaikD\
ACEPIAMpA0AhECABQQhqQdAAaiADQdAAahBDIAFBCGpByABqIA83AwAgASAQNwNIIAIgAUEIakHYAR\
A5GkETIQMMEAtB2AFBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB8AAQFiICRQ0AIAFBCGpB\
IGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCD\
cDECADKQMAIQ8gAUEIakEoaiADQShqEDcgASAPNwMIIAIgAUEIakHwABA5GkESIQMMDwtB8ABBCEEA\
KAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB8AAQFiICRQ0AIAFBCGpBIGogA0EgaikDADcDACABQQ\
hqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8gAUEIakEo\
aiADQShqEDcgASAPNwMIIAIgAUEIakHwABA5GkERIQMMDgtB8ABBCEEAKAL41EAiAUEEIAEbEQUAAA\
sgAigCBCEDAkBBmAIQFiICRQ0AIAFBCGogA0HIARA5GiABQQhqQcgBaiADQcgBahBGIAIgAUEIakGY\
AhA5GkEQIQMMDQtBmAJBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBBuAIQFiICRQ0AIAFBCG\
ogA0HIARA5GiABQQhqQcgBaiADQcgBahBHIAIgAUEIakG4AhA5GkEPIQMMDAtBuAJBCEEAKAL41EAi\
AUEEIAEbEQUAAAsgAigCBCEDAkBB2AIQFiICRQ0AIAFBCGogA0HIARA5GiABQQhqQcgBaiADQcgBah\
BEIAIgAUEIakHYAhA5GkEOIQMMCwtB2AJBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB4AIQ\
FiICRQ0AIAFBCGogA0HIARA5GiABQQhqQcgBaiADQcgBahBIIAIgAUEIakHgAhA5GkENIQMMCgtB4A\
JBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB6AAQFiICRQ0AIAFBCGpBGGogA0EYaigCADYC\
ACABQQhqQRBqIANBEGopAwA3AwAgASADKQMINwMQIAMpAwAhDyABQQhqQSBqIANBIGoQNyABIA83Aw\
ggAiABQQhqQegAEDkaQQwhAwwJC0HoAEEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHoABAW\
IgJFDQAgAUEIakEYaiADQRhqKAIANgIAIAFBCGpBEGogA0EQaikDADcDACABIAMpAwg3AxAgAykDAC\
EPIAFBCGpBIGogA0EgahA3IAEgDzcDCCACIAFBCGpB6AAQORpBCyEDDAgLQegAQQhBACgC+NRAIgFB\
BCABGxEFAAALIAIoAgQhAwJAQeAAEBYiAkUNACABQQhqQRBqIANBEGopAwA3AwAgASADKQMINwMQIA\
MpAwAhDyABQQhqQRhqIANBGGoQNyABIA83AwggAiABQQhqQeAAEDkaQQohAwwHC0HgAEEIQQAoAvjU\
QCIBQQQgARsRBQAACyACKAIEIQMCQEHgABAWIgJFDQAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCD\
cDECADKQMAIQ8gAUEIakEYaiADQRhqEDcgASAPNwMIIAIgAUEIakHgABA5GkEJIQMMBgtB4ABBCEEA\
KAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBBmAIQFiICRQ0AIAFBCGogA0HIARA5GiABQQhqQcgBai\
ADQcgBahBGIAIgAUEIakGYAhA5GkEIIQMMBQtBmAJBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCED\
AkBBuAIQFiICRQ0AIAFBCGogA0HIARA5GiABQQhqQcgBaiADQcgBahBHIAIgAUEIakG4AhA5GkEHIQ\
MMBAtBuAJBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB2AIQFiICRQ0AIAFBCGogA0HIARA5\
GiABQQhqQcgBaiADQcgBahBEIAIgAUEIakHYAhA5GkEGIQMMAwtB2AJBCEEAKAL41EAiAUEEIAEbEQ\
UAAAsgAigCBCEDAkBB4AIQFiICRQ0AIAFBCGogA0HIARA5GiABQQhqQcgBaiADQcgBahBIIAIgAUEI\
akHgAhA5GkEFIQMMAgtB4AJBCEEAKAL41EAiAUEEIAEbEQUAAAsgASAHNgKYASABIAQ6AHIgASAFOg\
BxIAEgBjoAcCABIA83AwggAiABQQhqQfgOEDkaQQQhAwsgACAAKAIAQX9qNgIAAkBBDBAWIgBFDQAg\
ACACNgIIIAAgAzYCBCAAQQA2AgAgAUGgD2okACAADwtBDEEEQQAoAvjUQCIBQQQgARsRBQAAC6MSAR\
p/IwBBwABrIQMgACgCACgCACIEIAQpAwAgAq18NwMAAkAgAkEGdCICRQ0AIAEgAmohBSAEKAIUIQYg\
BCgCECEHIAQoAgwhAiAEKAIIIQgDQCADQRhqIgBCADcDACADQSBqIglCADcDACADQThqQgA3AwAgA0\
EwakIANwMAIANBKGpCADcDACADQQhqIgogAUEIaikAADcDACADQRBqIgsgAUEQaikAADcDACAAIAFB\
GGooAAAiDDYCACAJIAFBIGooAAAiDTYCACADIAEpAAA3AwAgAyABQRxqKAAAIg42AhwgAyABQSRqKA\
AAIg82AiQgCigCACIQIAwgAUEoaigAACIRIAFBOGooAAAiEiABQTxqKAAAIhMgAygCDCIUIA4gAUEs\
aigAACIVIA4gFCATIBUgEiARIAwgByAQaiAGIAMoAgQiFmogCCACIAdxaiAGIAJBf3NxaiADKAIAIh\
dqQfjIqrt9akEHdyACaiIAIAJxaiAHIABBf3NxakHW7p7GfmpBDHcgAGoiCSAAcWogAiAJQX9zcWpB\
2+GBoQJqQRF3IAlqIgpqIAMoAhQiGCAJaiAAIAsoAgAiGWogAiAUaiAKIAlxaiAAIApBf3NxakHunf\
eNfGpBFncgCmoiACAKcWogCSAAQX9zcWpBr5/wq39qQQd3IABqIgkgAHFqIAogCUF/c3FqQaqMn7wE\
akEMdyAJaiIKIAlxaiAAIApBf3NxakGTjMHBempBEXcgCmoiC2ogDyAKaiANIAlqIA4gAGogCyAKcW\
ogCSALQX9zcWpBgaqaampBFncgC2oiACALcWogCiAAQX9zcWpB2LGCzAZqQQd3IABqIgkgAHFqIAsg\
CUF/c3FqQa/vk9p4akEMdyAJaiIKIAlxaiAAIApBf3NxakGxt31qQRF3IApqIgtqIAFBNGooAAAiGi\
AKaiABQTBqKAAAIhsgCWogFSAAaiALIApxaiAJIAtBf3NxakG+r/PKeGpBFncgC2oiACALcWogCiAA\
QX9zcWpBoqLA3AZqQQd3IABqIgkgAHFqIAsgCUF/c3FqQZPj4WxqQQx3IAlqIgogCXFqIAAgCkF/cy\
IccWpBjofls3pqQRF3IApqIgtqIBYgCWogCyAccWogEyAAaiALIApxaiAJIAtBf3MiHHFqQaGQ0M0E\
akEWdyALaiIAIApxakHiyviwf2pBBXcgAGoiCSAAQX9zcWogDCAKaiAAIBxxaiAJIAtxakHA5oKCfG\
pBCXcgCWoiCiAAcWpB0bT5sgJqQQ53IApqIgtqIBggCWogCyAKQX9zcWogFyAAaiAKIAlBf3NxaiAL\
IAlxakGqj9vNfmpBFHcgC2oiACAKcWpB3aC8sX1qQQV3IABqIgkgAEF/c3FqIBEgCmogACALQX9zcW\
ogCSALcWpB06iQEmpBCXcgCWoiCiAAcWpBgc2HxX1qQQ53IApqIgtqIA8gCWogCyAKQX9zcWogGSAA\
aiAKIAlBf3NxaiALIAlxakHI98++fmpBFHcgC2oiACAKcWpB5puHjwJqQQV3IABqIgkgAEF/c3FqIB\
IgCmogACALQX9zcWogCSALcWpB1o/cmXxqQQl3IAlqIgogAHFqQYeb1KZ/akEOdyAKaiILaiAaIAlq\
IAsgCkF/c3FqIA0gAGogCiAJQX9zcWogCyAJcWpB7anoqgRqQRR3IAtqIgAgCnFqQYXSj896akEFdy\
AAaiIJIABBf3NxaiAQIApqIAAgC0F/c3FqIAkgC3FqQfjHvmdqQQl3IAlqIgogAHFqQdmFvLsGakEO\
dyAKaiILaiANIApqIBggCWogGyAAaiAKIAlBf3NxaiALIAlxakGKmanpeGpBFHcgC2oiACALcyILIA\
pzakHC8mhqQQR3IABqIgkgC3NqQYHtx7t4akELdyAJaiIKIAlzIhwgAHNqQaLC9ewGakEQdyAKaiIL\
aiAZIApqIBYgCWogEiAAaiALIBxzakGM8JRvakEXdyALaiIJIAtzIgAgCnNqQcTU+6V6akEEdyAJai\
IKIABzakGpn/veBGpBC3cgCmoiCyAKcyISIAlzakHglu21f2pBEHcgC2oiAGogGiAKaiAAIAtzIBEg\
CWogEiAAc2pB8Pj+9XtqQRd3IABqIglzakHG/e3EAmpBBHcgCWoiCiAJcyAXIAtqIAkgAHMgCnNqQf\
rPhNV+akELdyAKaiIAc2pBheG8p31qQRB3IABqIgtqIA8gCmogCyAAcyAMIAlqIAAgCnMgC3NqQYW6\
oCRqQRd3IAtqIglzakG5oNPOfWpBBHcgCWoiCiAJcyAbIABqIAkgC3MgCnNqQeWz7rZ+akELdyAKai\
IAc2pB+PmJ/QFqQRB3IABqIgtqIA4gAGogFyAKaiAQIAlqIAAgCnMgC3NqQeWssaV8akEXdyALaiIJ\
IABBf3NyIAtzakHExKShf2pBBncgCWoiACALQX9zciAJc2pBl/+rmQRqQQp3IABqIgogCUF/c3IgAH\
NqQafH0Nx6akEPdyAKaiILaiAUIApqIBsgAGogGCAJaiALIABBf3NyIApzakG5wM5kakEVdyALaiIA\
IApBf3NyIAtzakHDs+2qBmpBBncgAGoiCSALQX9zciAAc2pBkpmz+HhqQQp3IAlqIgogAEF/c3IgCX\
NqQf3ov39qQQ93IApqIgtqIBMgCmogDSAJaiAWIABqIAsgCUF/c3IgCnNqQdG7kax4akEVdyALaiIA\
IApBf3NyIAtzakHP/KH9BmpBBncgAGoiCSALQX9zciAAc2pB4M2zcWpBCncgCWoiCiAAQX9zciAJc2\
pBlIaFmHpqQQ93IApqIgtqIBUgCmogGSAJaiAaIABqIAsgCUF/c3IgCnNqQaGjoPAEakEVdyALaiIA\
IApBf3NyIAtzakGC/c26f2pBBncgAGoiCSALQX9zciAAc2pBteTr6XtqQQp3IAlqIgogAEF/c3IgCX\
NqQbul39YCakEPdyAKaiILIAJqIA8gAGogCyAJQX9zciAKc2pBkaeb3H5qQRV3aiECIAsgB2ohByAK\
IAZqIQYgCSAIaiEIIAFBwABqIgEgBUcNAAsgBCAGNgIUIAQgBzYCECAEIAI2AgwgBCAINgIICwvtEQ\
EYfyMAIQIgACgCACIDKAIAIQQgAygCCCEFIAMoAgwhBiADKAIEIQcgAkHAAGsiAEEYaiICQgA3AwAg\
AEEgaiIIQgA3AwAgAEE4aiIJQgA3AwAgAEEwaiIKQgA3AwAgAEEoaiILQgA3AwAgAEEIaiIMIAEpAA\
g3AwAgAEEQaiINIAEpABA3AwAgAiABKAAYIg42AgAgCCABKAAgIg82AgAgACABKQAANwMAIAAgASgA\
HCIQNgIcIAAgASgAJCIRNgIkIAsgASgAKCISNgIAIAAgASgALCILNgIsIAogASgAMCITNgIAIAAgAS\
gANCIKNgI0IAkgASgAOCIUNgIAIAAgASgAPCIJNgI8IAMgBCANKAIAIg0gDyATIAAoAgAiFSARIAog\
ACgCBCIWIAAoAhQiFyAKIBEgFyAWIBMgDyANIAcgFSAEIAcgBXFqIAYgB0F/c3FqakH4yKq7fWpBB3\
dqIgFqIAcgACgCDCIYaiAFIAwoAgAiDGogBiAWaiABIAdxaiAFIAFBf3NxakHW7p7GfmpBDHcgAWoi\
ACABcWogByAAQX9zcWpB2+GBoQJqQRF3IABqIgIgAHFqIAEgAkF/c3FqQe6d9418akEWdyACaiIBIA\
JxaiAAIAFBf3NxakGvn/Crf2pBB3cgAWoiCGogECABaiAOIAJqIBcgAGogCCABcWogAiAIQX9zcWpB\
qoyfvARqQQx3IAhqIgAgCHFqIAEgAEF/c3FqQZOMwcF6akERdyAAaiIBIABxaiAIIAFBf3NxakGBqp\
pqakEWdyABaiICIAFxaiAAIAJBf3NxakHYsYLMBmpBB3cgAmoiCGogCyACaiASIAFqIBEgAGogCCAC\
cWogASAIQX9zcWpBr++T2nhqQQx3IAhqIgAgCHFqIAIgAEF/c3FqQbG3fWpBEXcgAGoiASAAcWogCC\
ABQX9zcWpBvq/zynhqQRZ3IAFqIgIgAXFqIAAgAkF/c3FqQaKiwNwGakEHdyACaiIIaiAUIAFqIAog\
AGogCCACcWogASAIQX9zcWpBk+PhbGpBDHcgCGoiACAIcWogAiAAQX9zIhlxakGOh+WzempBEXcgAG\
oiASAZcWogCSACaiABIABxaiAIIAFBf3MiGXFqQaGQ0M0EakEWdyABaiICIABxakHiyviwf2pBBXcg\
AmoiCGogCyABaiAIIAJBf3NxaiAOIABqIAIgGXFqIAggAXFqQcDmgoJ8akEJdyAIaiIAIAJxakHRtP\
myAmpBDncgAGoiASAAQX9zcWogFSACaiAAIAhBf3NxaiABIAhxakGqj9vNfmpBFHcgAWoiAiAAcWpB\
3aC8sX1qQQV3IAJqIghqIAkgAWogCCACQX9zcWogEiAAaiACIAFBf3NxaiAIIAFxakHTqJASakEJdy\
AIaiIAIAJxakGBzYfFfWpBDncgAGoiASAAQX9zcWogDSACaiAAIAhBf3NxaiABIAhxakHI98++fmpB\
FHcgAWoiAiAAcWpB5puHjwJqQQV3IAJqIghqIBggAWogCCACQX9zcWogFCAAaiACIAFBf3NxaiAIIA\
FxakHWj9yZfGpBCXcgCGoiACACcWpBh5vUpn9qQQ53IABqIgEgAEF/c3FqIA8gAmogACAIQX9zcWog\
ASAIcWpB7anoqgRqQRR3IAFqIgIgAHFqQYXSj896akEFdyACaiIIaiATIAJqIAwgAGogAiABQX9zcW\
ogCCABcWpB+Me+Z2pBCXcgCGoiACAIQX9zcWogECABaiAIIAJBf3NxaiAAIAJxakHZhby7BmpBDncg\
AGoiASAIcWpBipmp6XhqQRR3IAFqIgIgAXMiGSAAc2pBwvJoakEEdyACaiIIaiAUIAJqIAsgAWogDy\
AAaiAIIBlzakGB7ce7eGpBC3cgCGoiASAIcyIAIAJzakGiwvXsBmpBEHcgAWoiAiAAc2pBjPCUb2pB\
F3cgAmoiCCACcyIZIAFzakHE1PulempBBHcgCGoiAGogECACaiAAIAhzIA0gAWogGSAAc2pBqZ/73g\
RqQQt3IABqIgFzakHglu21f2pBEHcgAWoiAiABcyASIAhqIAEgAHMgAnNqQfD4/vV7akEXdyACaiIA\
c2pBxv3txAJqQQR3IABqIghqIBggAmogCCAAcyAVIAFqIAAgAnMgCHNqQfrPhNV+akELdyAIaiIBc2\
pBheG8p31qQRB3IAFqIgIgAXMgDiAAaiABIAhzIAJzakGFuqAkakEXdyACaiIAc2pBuaDTzn1qQQR3\
IABqIghqIAwgAGogEyABaiAAIAJzIAhzakHls+62fmpBC3cgCGoiASAIcyAJIAJqIAggAHMgAXNqQf\
j5if0BakEQdyABaiIAc2pB5ayxpXxqQRd3IABqIgIgAUF/c3IgAHNqQcTEpKF/akEGdyACaiIIaiAX\
IAJqIBQgAGogECABaiAIIABBf3NyIAJzakGX/6uZBGpBCncgCGoiACACQX9zciAIc2pBp8fQ3HpqQQ\
93IABqIgEgCEF/c3IgAHNqQbnAzmRqQRV3IAFqIgIgAEF/c3IgAXNqQcOz7aoGakEGdyACaiIIaiAW\
IAJqIBIgAWogGCAAaiAIIAFBf3NyIAJzakGSmbP4eGpBCncgCGoiACACQX9zciAIc2pB/ei/f2pBD3\
cgAGoiASAIQX9zciAAc2pB0buRrHhqQRV3IAFqIgIgAEF/c3IgAXNqQc/8of0GakEGdyACaiIIaiAK\
IAJqIA4gAWogCSAAaiAIIAFBf3NyIAJzakHgzbNxakEKdyAIaiIAIAJBf3NyIAhzakGUhoWYempBD3\
cgAGoiASAIQX9zciAAc2pBoaOg8ARqQRV3IAFqIgIgAEF/c3IgAXNqQYL9zbp/akEGdyACaiIIajYC\
ACADIAYgCyAAaiAIIAFBf3NyIAJzakG15Ovpe2pBCncgCGoiAGo2AgwgAyAFIAwgAWogACACQX9zci\
AIc2pBu6Xf1gJqQQ93IABqIgFqNgIIIAMgASAHaiARIAJqIAEgCEF/c3IgAHNqQZGnm9x+akEVd2o2\
AgQLnA4CDX8BfiMAQaACayIHJAACQAJAAkACQAJAAkACQAJAAkACQCABQYEISQ0AQX8gAUF/aiIIQQ\
t2Z3ZBCnRBgAhqQYAIIAhB/w9LGyIIIAFLDQQgB0EIakEAQYABEDoaIAEgCGshCSAAIAhqIQEgCEEK\
dq0gA3whFCAIQYAIRw0BIAdBCGpBIGohCkHgACELIABBgAggAiADIAQgB0EIakEgEB0hCAwCCyAHQg\
A3A4gBAkACQCABQYB4cSIKDQBBACEIQQAhCQwBCyAKQYAIRw0DIAcgADYCiAFBASEJIAdBATYCjAEg\
ACEICyABQf8HcSEBAkAgBkEFdiILIAkgCSALSxtFDQAgB0EIakEYaiIJIAJBGGopAgA3AwAgB0EIak\
EQaiILIAJBEGopAgA3AwAgB0EIakEIaiIMIAJBCGopAgA3AwAgByACKQIANwMIIAdBCGogCEHAACAD\
IARBAXIQGSAHQQhqIAhBwABqQcAAIAMgBBAZIAdBCGogCEGAAWpBwAAgAyAEEBkgB0EIaiAIQcABak\
HAACADIAQQGSAHQQhqIAhBgAJqQcAAIAMgBBAZIAdBCGogCEHAAmpBwAAgAyAEEBkgB0EIaiAIQYAD\
akHAACADIAQQGSAHQQhqIAhBwANqQcAAIAMgBBAZIAdBCGogCEGABGpBwAAgAyAEEBkgB0EIaiAIQc\
AEakHAACADIAQQGSAHQQhqIAhBgAVqQcAAIAMgBBAZIAdBCGogCEHABWpBwAAgAyAEEBkgB0EIaiAI\
QYAGakHAACADIAQQGSAHQQhqIAhBwAZqQcAAIAMgBBAZIAdBCGogCEGAB2pBwAAgAyAEEBkgB0EIai\
AIQcAHakHAACADIARBAnIQGSAFIAkpAwA3ABggBSALKQMANwAQIAUgDCkDADcACCAFIAcpAwg3AAAg\
BygCjAEhCQsgAUUNCCAHQZABakEwaiINQgA3AwAgB0GQAWpBOGoiDkIANwMAIAdBkAFqQcAAaiIPQg\
A3AwAgB0GQAWpByABqIhBCADcDACAHQZABakHQAGoiEUIANwMAIAdBkAFqQdgAaiISQgA3AwAgB0GQ\
AWpB4ABqIhNCADcDACAHQZABakEgaiIIIAJBGGopAgA3AwAgB0GQAWpBGGoiCyACQRBqKQIANwMAIA\
dBkAFqQRBqIgwgAkEIaikCADcDACAHQgA3A7gBIAcgBDoA+gEgB0EAOwH4ASAHIAIpAgA3A5gBIAcg\
Ca0gA3w3A5ABIAdBkAFqIAAgCmogARAzGiAHQQhqQRBqIAwpAwA3AwAgB0EIakEYaiALKQMANwMAIA\
dBCGpBIGogCCkDADcDACAHQQhqQTBqIA0pAwA3AwAgB0EIakE4aiAOKQMANwMAIAdBCGpBwABqIA8p\
AwA3AwAgB0EIakHIAGogECkDADcDACAHQQhqQdAAaiARKQMANwMAIAdBCGpB2ABqIBIpAwA3AwAgB0\
EIakHgAGogEykDADcDACAHIAcpA5gBNwMQIAcgBykDuAE3AzAgBy0A+gEhBCAHLQD5ASECIAcgBy0A\
+AEiAToAcCAHIAcpA5ABIgM3AwggByAEIAJFckECciIEOgBxIAdBgAJqQRhqIgIgCCkDADcDACAHQY\
ACakEQaiIAIAspAwA3AwAgB0GAAmpBCGoiCiAMKQMANwMAIAcgBykDmAE3A4ACIAdBgAJqIAdBMGog\
ASADIAQQGSAJQQV0IgRBIGohCCAEQWBGDQQgCCAGSw0FIAIoAgAhCCAAKAIAIQIgCigCACEBIAcoAp\
QCIQAgBygCjAIhBiAHKAKEAiEKIAcoAoACIQsgBSAEaiIEIAcoApwCNgAcIAQgCDYAGCAEIAA2ABQg\
BCACNgAQIAQgBjYADCAEIAE2AAggBCAKNgAEIAQgCzYAACAJQQFqIQkMCAtBwAAhCyAHQQhqQcAAai\
EKIAAgCCACIAMgBCAHQQhqQcAAEB0hCAsgASAJIAIgFCAEIAogCxAdIQkCQCAIQQFHDQAgBkE/TQ0F\
IAUgBykACDcAACAFQThqIAdBCGpBOGopAAA3AAAgBUEwaiAHQQhqQTBqKQAANwAAIAVBKGogB0EIak\
EoaikAADcAACAFQSBqIAdBCGpBIGopAAA3AAAgBUEYaiAHQQhqQRhqKQAANwAAIAVBEGogB0EIakEQ\
aikAADcAACAFQQhqIAdBCGpBCGopAAA3AABBAiEJDAcLIAkgCGpBBXQiCEGBAU8NBSAHQQhqIAggAi\
AEIAUgBhAsIQkMBgsgByAAQYAIajYCCEGQksAAIAdBCGpB8IXAAEH4hsAAEEAAC0GhjcAAQSNBtIPA\
ABBTAAtBYCAIQaCEwAAQSwALIAggBkGghMAAEEkAC0HAACAGQdCEwAAQSQALIAhBgAFBwITAABBJAA\
sgB0GgAmokACAJC80OAQd/IABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAAkAgAkEBcQ0AIAJBA3FF\
DQEgASgCACICIABqIQACQEEAKAKc2EAgASACayIBRw0AIAMoAgRBA3FBA0cNAUEAIAA2ApTYQCADIA\
MoAgRBfnE2AgQgASAAQQFyNgIEIAEgAGogADYCAA8LAkACQCACQYACSQ0AIAEoAhghBAJAAkAgASgC\
DCIFIAFHDQAgAUEUQRAgASgCFCIFG2ooAgAiAg0BQQAhBQwDCyABKAIIIgIgBTYCDCAFIAI2AggMAg\
sgAUEUaiABQRBqIAUbIQYDQCAGIQcCQCACIgVBFGoiBigCACICDQAgBUEQaiEGIAUoAhAhAgsgAg0A\
CyAHQQA2AgAMAQsCQCABQQxqKAIAIgUgAUEIaigCACIGRg0AIAYgBTYCDCAFIAY2AggMAgtBAEEAKA\
KE1UBBfiACQQN2d3E2AoTVQAwBCyAERQ0AAkACQCABKAIcQQJ0QZTXwABqIgIoAgAgAUYNACAEQRBB\
FCAEKAIQIAFGG2ogBTYCACAFRQ0CDAELIAIgBTYCACAFDQBBAEEAKAKI1UBBfiABKAIcd3E2AojVQA\
wBCyAFIAQ2AhgCQCABKAIQIgJFDQAgBSACNgIQIAIgBTYCGAsgASgCFCICRQ0AIAVBFGogAjYCACAC\
IAU2AhgLAkACQCADKAIEIgJBAnFFDQAgAyACQX5xNgIEIAEgAEEBcjYCBCABIABqIAA2AgAMAQsCQA\
JAAkACQAJAAkACQEEAKAKg2EAgA0YNAEEAKAKc2EAgA0cNAUEAIAE2ApzYQEEAQQAoApTYQCAAaiIA\
NgKU2EAgASAAQQFyNgIEIAEgAGogADYCAA8LQQAgATYCoNhAQQBBACgCmNhAIABqIgA2ApjYQCABIA\
BBAXI2AgQgAUEAKAKc2EBGDQEMBQsgAkF4cSIFIABqIQAgBUGAAkkNASADKAIYIQQCQAJAIAMoAgwi\
BSADRw0AIANBFEEQIAMoAhQiBRtqKAIAIgINAUEAIQUMBAsgAygCCCICIAU2AgwgBSACNgIIDAMLIA\
NBFGogA0EQaiAFGyEGA0AgBiEHAkAgAiIFQRRqIgYoAgAiAg0AIAVBEGohBiAFKAIQIQILIAINAAsg\
B0EANgIADAILQQBBADYClNhAQQBBADYCnNhADAMLAkAgA0EMaigCACIFIANBCGooAgAiA0YNACADIA\
U2AgwgBSADNgIIDAILQQBBACgChNVAQX4gAkEDdndxNgKE1UAMAQsgBEUNAAJAAkAgAygCHEECdEGU\
18AAaiICKAIAIANGDQAgBEEQQRQgBCgCECADRhtqIAU2AgAgBUUNAgwBCyACIAU2AgAgBQ0AQQBBAC\
gCiNVAQX4gAygCHHdxNgKI1UAMAQsgBSAENgIYAkAgAygCECICRQ0AIAUgAjYCECACIAU2AhgLIAMo\
AhQiA0UNACAFQRRqIAM2AgAgAyAFNgIYCyABIABBAXI2AgQgASAAaiAANgIAIAFBACgCnNhARw0BQQ\
AgADYClNhADAILQQAoArzYQCICIABPDQFBACgCoNhAIgBFDQECQEEAKAKY2EAiBUEpSQ0AQazYwAAh\
AQNAAkAgASgCACIDIABLDQAgAyABKAIEaiAASw0CCyABKAIIIgENAAsLAkACQEEAKAK02EAiAA0AQf\
8fIQEMAQtBACEBA0AgAUEBaiEBIAAoAggiAA0ACyABQf8fIAFB/x9LGyEBC0EAIAE2AsTYQCAFIAJN\
DQFBAEF/NgK82EAPCwJAAkACQCAAQYACSQ0AQR8hAwJAIABB////B0sNACAAQQYgAEEIdmciA2t2QQ\
FxIANBAXRrQT5qIQMLIAFCADcCECABQRxqIAM2AgAgA0ECdEGU18AAaiECAkACQAJAAkACQAJAQQAo\
AojVQCIFQQEgA3QiBnFFDQAgAigCACIFKAIEQXhxIABHDQEgBSEDDAILQQAgBSAGcjYCiNVAIAIgAT\
YCACABQRhqIAI2AgAMAwsgAEEAQRkgA0EBdmtBH3EgA0EfRht0IQIDQCAFIAJBHXZBBHFqQRBqIgYo\
AgAiA0UNAiACQQF0IQIgAyEFIAMoAgRBeHEgAEcNAAsLIAMoAggiACABNgIMIAMgATYCCCABQRhqQQ\
A2AgAgASADNgIMIAEgADYCCAwCCyAGIAE2AgAgAUEYaiAFNgIACyABIAE2AgwgASABNgIIC0EAQQAo\
AsTYQEF/aiIBNgLE2EAgAQ0DQQAoArTYQCIADQFB/x8hAQwCCyAAQQN2IgNBA3RBjNXAAGohAAJAAk\
BBACgChNVAIgJBASADdCIDcUUNACAAKAIIIQMMAQtBACACIANyNgKE1UAgACEDCyAAIAE2AgggAyAB\
NgIMIAEgADYCDCABIAM2AggPC0EAIQEDQCABQQFqIQEgACgCCCIADQALIAFB/x8gAUH/H0sbIQELQQ\
AgATYCxNhADwsLlQwBGH8jACECIAAoAgAhAyAAKAIIIQQgACgCDCEFIAAoAgQhBiACQcAAayICQRhq\
IgdCADcDACACQSBqIghCADcDACACQThqIglCADcDACACQTBqIgpCADcDACACQShqIgtCADcDACACQQ\
hqIgwgASkACDcDACACQRBqIg0gASkAEDcDACAHIAEoABgiDjYCACAIIAEoACAiDzYCACACIAEpAAA3\
AwAgAiABKAAcIhA2AhwgAiABKAAkIhE2AiQgCyABKAAoIhI2AgAgAiABKAAsIgs2AiwgCiABKAAwIh\
M2AgAgAiABKAA0Igo2AjQgCSABKAA4IhQ2AgAgAiABKAA8IhU2AjwgACADIBMgCyASIBEgDyAQIA4g\
BiAEIAUgBiADIAYgBHFqIAUgBkF/c3FqIAIoAgAiFmpBA3ciAXFqIAQgAUF/c3FqIAIoAgQiF2pBB3\
ciByABcWogBiAHQX9zcWogDCgCACIMakELdyIIIAdxaiABIAhBf3NxaiACKAIMIhhqQRN3IgkgCHEg\
AWogByAJQX9zcWogDSgCACINakEDdyIBIAlxIAdqIAggAUF/c3FqIAIoAhQiGWpBB3ciAiABcSAIai\
AJIAJBf3NxampBC3ciByACcSAJaiABIAdBf3NxampBE3ciCCAHcSABaiACIAhBf3NxampBA3ciASAI\
cSACaiAHIAFBf3NxampBB3ciAiABcSAHaiAIIAJBf3NxampBC3ciByACcSAIaiABIAdBf3NxampBE3\
ciCCAHcSABaiACIAhBf3NxampBA3ciASAUIAEgCiABIAhxIAJqIAcgAUF/c3FqakEHdyIJcSAHaiAI\
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\
aiACQRBqKQMANwMAIAMgAikDCDcDACADQegAakEAOgAADBQLIAMoAgQiA0IANwMAIAMgAykDcDcDCC\
ADQSBqIANBiAFqKQMANwMAIANBGGogA0GAAWopAwA3AwAgA0EQaiADQfgAaikDADcDACADQShqQQBB\
wgAQOhogAygCkAFFDRMgA0EANgKQAQwTCyADKAIEQQBByAEQOkHYAmpBADoAAAwSCyADKAIEQQBByA\
EQOkHQAmpBADoAAAwRCyADKAIEQQBByAEQOkGwAmpBADoAAAwQCyADKAIEQQBByAEQOkGQAmpBADoA\
AAwPCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQdgAakEAOgAAIANBEGpC/rnrxemOlZkQNw\
MADA4LIAMoAgQiA0KBxpS6lvHq5m83AwggA0IANwMAIANB2ABqQQA6AAAgA0EQakL+uevF6Y6VmRA3\
AwAMDQsgAygCBCIDQgA3AwAgA0HgAGpBADoAACADQQApA9iNQDcDCCADQRBqQQApA+CNQDcDACADQR\
hqQQAoAuiNQDYCAAwMCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQeAAakEAOgAAIANBGGpB\
8MPLnnw2AgAgA0EQakL+uevF6Y6VmRA3AwAMCwsgAygCBEEAQcgBEDpB2AJqQQA6AAAMCgsgAygCBE\
EAQcgBEDpB0AJqQQA6AAAMCQsgAygCBEEAQcgBEDpBsAJqQQA6AAAMCAsgAygCBEEAQcgBEDpBkAJq\
QQA6AAAMBwsgAygCBCIDQgA3AwAgA0HoAGpBADoAACADQQApA5COQDcDCCADQRBqQQApA5iOQDcDAC\
ADQRhqQQApA6COQDcDACADQSBqQQApA6iOQDcDAAwGCyADKAIEIgNCADcDACADQegAakEAOgAAIANB\
ACkD8I1ANwMIIANBEGpBACkD+I1ANwMAIANBGGpBACkDgI5ANwMAIANBIGpBACkDiI5ANwMADAULIA\
MoAgQiA0IANwNAIANBACkD8I5ANwMAIANByABqQgA3AwAgA0E4akEAKQOoj0A3AwAgA0EwakEAKQOg\
j0A3AwAgA0EoakEAKQOYj0A3AwAgA0EgakEAKQOQj0A3AwAgA0EYakEAKQOIj0A3AwAgA0EQakEAKQ\
OAj0A3AwAgA0EIakEAKQP4jkA3AwAgA0HQAWpBADoAAAwECyADKAIEIgNCADcDQCADQQApA7COQDcD\
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\
EzcDACACQcgAaiASNwMAQgAhEiACQgA3AwAgCEEEciEJIAJBCGohBAwBCyACQRBqIAFBEGopAwA3Aw\
AgAkEYaiABQRhqKQMANwMAIAJBIGogAUEgaikDADcDACACQTBqIAFBMGopAwA3AwAgAkE4aiABQThq\
KQMANwMAIAJBwABqIAFBwABqKQMANwMAIAJByABqIAFByABqKQMANwMAIAJB0ABqIAFB0ABqKQMANw\
MAIAJB2ABqIAFB2ABqKQMANwMAIAJB4ABqIAFB4ABqKQMANwMAIAIgASkDCDcDCCACIAEpAyg3Aygg\
AS0AaiEIIAIgASkDACISNwMAIAggBEVyQQJyIQkgAkEIaiEEIAMhBgsgAiAJOgBpIAIgBToAaAJAAk\
AgBkUNACABQfAAaiEKIAJBKGohB0EBIAZrIQsgCEEEciEIIAZBBXQgAWpB9ABqIQEgBkF/aiADTyEM\
A0AgDA0CIAJB8ABqQRhqIgYgBEEYaiINKQIANwMAIAJB8ABqQRBqIg4gBEEQaiIPKQIANwMAIAJB8A\
BqQQhqIhAgBEEIaiIRKQIANwMAIAIgBCkCADcDcCACQfAAaiAHIAUgEiAJEBkgECkDACETIA4pAwAh\
FCAGKQMAIRUgAikDcCEWIAdBGGogAUEYaikCADcCACAHQRBqIAFBEGopAgA3AgAgB0EIaiABQQhqKQ\
IANwIAIAcgASkCADcCACAEIAopAwA3AwAgESAKQQhqKQMANwMAIA8gCkEQaikDADcDACANIApBGGop\
AwA3AwBCACESIAJCADcDACACIBU3A2AgAiAUNwNYIAIgEzcDUCACIBY3A0ggAiAIOgBpQcAAIQUgAk\
HAADoAaCABQWBqIQEgCCEJIAtBAWoiC0EBRw0ACwsgACACQfAAEDkaDAILQQAgC2sgA0HQhcAAEE0A\
CyAAIAEpAwg3AwggACABKQMoNwMoIABBEGogAUEQaikDADcDACAAQRhqIAFBGGopAwA3AwAgAEEgai\
ABQSBqKQMANwMAIABBMGogAUEwaikDADcDACAAQThqIAFBOGopAwA3AwAgAEHAAGogAUHAAGopAwA3\
AwAgAEHIAGogAUHIAGopAwA3AwAgAEHQAGogAUHQAGopAwA3AwAgAEHYAGogAUHYAGopAwA3AwAgAE\
HgAGogAUHgAGopAwA3AwAgAUHpAGotAAAhBCABLQBqIQcgACABLQBoOgBoIAAgASkDADcDACAAIAcg\
BEVyQQJyOgBpCyAAQQA6AHAgAkGQAWokAA8LIAYgA0HAhcAAEE0AC6cIAgF/KX4gACkDwAEhAiAAKQ\
OYASEDIAApA3AhBCAAKQNIIQUgACkDICEGIAApA7gBIQcgACkDkAEhCCAAKQNoIQkgACkDQCEKIAAp\
AxghCyAAKQOwASEMIAApA4gBIQ0gACkDYCEOIAApAzghDyAAKQMQIRAgACkDqAEhESAAKQOAASESIA\
ApA1ghEyAAKQMwIRQgACkDCCEVIAApA6ABIRYgACkDeCEXIAApA1AhGCAAKQMoIRkgACkDACEaQcB+\
IQEDQCAMIA0gDiAPIBCFhYWFIhtCAYkgFiAXIBggGSAahYWFhSIchSIdIBSFIR4gAiAHIAggCSAKIA\
uFhYWFIh8gHEIBiYUiHIUhICACIAMgBCAFIAaFhYWFIiFCAYkgG4UiGyAKhUI3iSIiIB9CAYkgESAS\
IBMgFCAVhYWFhSIKhSIfIBCFQj6JIiNCf4WDIB0gEYVCAokiJIUhAiAiICEgCkIBiYUiECAXhUIpiS\
IhIAQgHIVCJ4kiJUJ/hYOFIREgGyAHhUI4iSImIB8gDYVCD4kiB0J/hYMgHSAThUIKiSInhSENICcg\
ECAZhUIkiSIoQn+FgyAGIByFQhuJIimFIRcgECAWhUISiSIGIB8gD4VCBokiFiAdIBWFQgGJIipCf4\
WDhSEEIAMgHIVCCIkiAyAbIAmFQhmJIglCf4WDIBaFIRMgBSAchUIUiSIcIBsgC4VCHIkiC0J/hYMg\
HyAMhUI9iSIPhSEFIAsgD0J/hYMgHSAShUItiSIdhSEKIBAgGIVCA4kiFSAPIB1Cf4WDhSEPIB0gFU\
J/hYMgHIUhFCALIBUgHEJ/hYOFIRkgGyAIhUIViSIdIBAgGoUiHCAgQg6JIhtCf4WDhSELIBsgHUJ/\
hYMgHyAOhUIriSIfhSEQIB0gH0J/hYMgHkIsiSIdhSEVIAFBoJHAAGopAwAgHCAfIB1Cf4WDhYUhGi\
AJIBZCf4WDICqFIh8hGCAlICJCf4WDICOFIiIhFiAoIAcgJ0J/hYOFIichEiAJIAYgA0J/hYOFIh4h\
DiAkICFCf4WDICWFIiUhDCAqIAZCf4WDIAOFIiohCSApICZCf4WDIAeFIiAhCCAhICMgJEJ/hYOFIi\
MhByAdIBxCf4WDIBuFIh0hBiAmICggKUJ/hYOFIhwhAyABQQhqIgENAAsgACAiNwOgASAAIBc3A3gg\
ACAfNwNQIAAgGTcDKCAAIBo3AwAgACARNwOoASAAICc3A4ABIAAgEzcDWCAAIBQ3AzAgACAVNwMIIA\
AgJTcDsAEgACANNwOIASAAIB43A2AgACAPNwM4IAAgEDcDECAAICM3A7gBIAAgIDcDkAEgACAqNwNo\
IAAgCjcDQCAAIAs3AxggACACNwPAASAAIBw3A5gBIAAgBDcDcCAAIAU3A0ggACAdNwMgC+8IAQp/IA\
AoAhAhAwJAAkACQAJAIAAoAggiBEEBRg0AIANBAUYNASAAKAIYIAEgAiAAQRxqKAIAKAIMEQgAIQMM\
AwsgA0EBRw0BCyABIAJqIQUCQAJAAkAgAEEUaigCACIGDQBBACEHIAEhAwwBC0EAIQcgASEDA0AgAy\
IIIAVGDQIgCEEBaiEDAkAgCCwAACIJQX9KDQAgCUH/AXEhCQJAAkAgAyAFRw0AQQAhCiAFIQMMAQsg\
CEECaiEDIAgtAAFBP3EhCgsgCUHgAUkNAAJAAkAgAyAFRw0AQQAhCyAFIQwMAQsgA0EBaiEMIAMtAA\
BBP3EhCwsCQCAJQfABTw0AIAwhAwwBCwJAAkAgDCAFRw0AQQAhDCAFIQMMAQsgDEEBaiEDIAwtAABB\
P3EhDAsgCkEMdCAJQRJ0QYCA8ABxciALQQZ0ciAMckGAgMQARg0DCyAHIAhrIANqIQcgBkF/aiIGDQ\
ALCyADIAVGDQACQCADLAAAIghBf0oNAAJAAkAgA0EBaiAFRw0AQQAhAyAFIQYMAQsgA0ECaiEGIAMt\
AAFBP3FBBnQhAwsgCEH/AXFB4AFJDQACQAJAIAYgBUcNAEEAIQYgBSEJDAELIAZBAWohCSAGLQAAQT\
9xIQYLIAhB/wFxQfABSQ0AIAhB/wFxIQggBiADciEDAkACQCAJIAVHDQBBACEFDAELIAktAABBP3Eh\
BQsgA0EGdCAIQRJ0QYCA8ABxciAFckGAgMQARg0BCwJAAkACQCAHDQBBACEIDAELAkAgByACSQ0AQQ\
AhAyACIQggByACRg0BDAILQQAhAyAHIQggASAHaiwAAEFASA0BCyAIIQcgASEDCyAHIAIgAxshAiAD\
IAEgAxshAQsgBEEBRg0AIAAoAhggASACIABBHGooAgAoAgwRCAAPCyAAQQxqKAIAIQYCQAJAIAINAE\
EAIQgMAQsgAkEDcSEHAkACQCACQX9qQQNPDQBBACEIIAEhAwwBC0EAIQhBACACQXxxayEFIAEhAwNA\
IAggAywAAEG/f0pqIANBAWosAABBv39KaiADQQJqLAAAQb9/SmogA0EDaiwAAEG/f0pqIQggA0EEai\
EDIAVBBGoiBQ0ACwsgB0UNAANAIAggAywAAEG/f0pqIQggA0EBaiEDIAdBf2oiBw0ACwsCQCAGIAhN\
DQBBACEDIAYgCGsiByEGAkACQAJAQQAgAC0AICIIIAhBA0YbQQNxDgMCAAECC0EAIQYgByEDDAELIA\
dBAXYhAyAHQQFqQQF2IQYLIANBAWohAyAAQRxqKAIAIQcgACgCBCEIIAAoAhghBQJAA0AgA0F/aiID\
RQ0BIAUgCCAHKAIQEQYARQ0AC0EBDwtBASEDIAhBgIDEAEYNASAFIAEgAiAHKAIMEQgADQFBACEDA0\
ACQCAGIANHDQAgBiAGSQ8LIANBAWohAyAFIAggBygCEBEGAEUNAAsgA0F/aiAGSQ8LIAAoAhggASAC\
IABBHGooAgAoAgwRCAAPCyADC6sIAQp/QQAhAgJAIAFBzP97Sw0AQRAgAUELakF4cSABQQtJGyEDIA\
BBfGoiBCgCACIFQXhxIQYCQAJAAkACQAJAAkACQCAFQQNxRQ0AIABBeGohByAGIANPDQFBACgCoNhA\
IAcgBmoiCEYNAkEAKAKc2EAgCEYNAyAIKAIEIgVBAnENBiAFQXhxIgkgBmoiCiADTw0EDAYLIANBgA\
JJDQUgBiADQQRySQ0FIAYgA2tBgYAITw0FDAQLIAYgA2siAUEQSQ0DIAQgBUEBcSADckECcjYCACAH\
IANqIgIgAUEDcjYCBCACIAFBBHJqIgMgAygCAEEBcjYCACACIAEQIAwDC0EAKAKY2EAgBmoiBiADTQ\
0DIAQgBUEBcSADckECcjYCACAHIANqIgEgBiADayICQQFyNgIEQQAgAjYCmNhAQQAgATYCoNhADAIL\
QQAoApTYQCAGaiIGIANJDQICQAJAIAYgA2siAUEPSw0AIAQgBUEBcSAGckECcjYCACAGIAdqQQRqIg\
EgASgCAEEBcjYCAEEAIQFBACECDAELIAQgBUEBcSADckECcjYCACAHIANqIgIgAUEBcjYCBCACIAFq\
IgMgATYCACADQQRqIgMgAygCAEF+cTYCAAtBACACNgKc2EBBACABNgKU2EAMAQsgCiADayELAkACQA\
JAIAlBgAJJDQAgCCgCGCEJAkACQCAIKAIMIgIgCEcNACAIQRRBECAIKAIUIgIbaigCACIBDQFBACEC\
DAMLIAgoAggiASACNgIMIAIgATYCCAwCCyAIQRRqIAhBEGogAhshBgNAIAYhBQJAIAEiAkEUaiIGKA\
IAIgENACACQRBqIQYgAigCECEBCyABDQALIAVBADYCAAwBCwJAIAhBDGooAgAiASAIQQhqKAIAIgJG\
DQAgAiABNgIMIAEgAjYCCAwCC0EAQQAoAoTVQEF+IAVBA3Z3cTYChNVADAELIAlFDQACQAJAIAgoAh\
xBAnRBlNfAAGoiASgCACAIRg0AIAlBEEEUIAkoAhAgCEYbaiACNgIAIAJFDQIMAQsgASACNgIAIAIN\
AEEAQQAoAojVQEF+IAgoAhx3cTYCiNVADAELIAIgCTYCGAJAIAgoAhAiAUUNACACIAE2AhAgASACNg\
IYCyAIKAIUIgFFDQAgAkEUaiABNgIAIAEgAjYCGAsCQCALQRBJDQAgBCAEKAIAQQFxIANyQQJyNgIA\
IAcgA2oiASALQQNyNgIEIAEgC0EEcmoiAiACKAIAQQFyNgIAIAEgCxAgDAELIAQgBCgCAEEBcSAKck\
ECcjYCACAHIApBBHJqIgEgASgCAEEBcjYCAAsgACECDAELIAEQFiIDRQ0AIAMgACABQXxBeCAEKAIA\
IgJBA3EbIAJBeHFqIgIgAiABSxsQOSEBIAAQHiABDwsgAguDBwIEfwJ+IwBB0AFrIgMkACABIAFBwA\
BqLQAAIgRqIgVBgAE6AAAgACkDAEIJhiAErUIDhoQiB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0Io\
iEKA/gODIAdCOIiEhCEIIAdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgI\
CAgPAfg4SEIQcCQCAEQT9zIgZFDQAgBUEBakEAIAYQOhoLIAcgCIQhBwJAAkAgBEE4cUE4Rg0AIAFB\
OGogBzcAACAAQQhqIAFBARAQDAELIABBCGoiBCABQQEQECADQcAAakEMakIANwIAIANBwABqQRRqQg\
A3AgAgA0HAAGpBHGpCADcCACADQcAAakEkakIANwIAIANBwABqQSxqQgA3AgAgA0HAAGpBNGpCADcC\
ACADQfwAakIANwIAIANCADcCRCADQcAANgJAIANBiAFqIANBwABqQcQAEDkaIANBMGogA0GIAWpBNG\
opAgA3AwAgA0EoaiADQYgBakEsaikCADcDACADQSBqIANBiAFqQSRqKQIANwMAIANBGGogA0GIAWpB\
HGopAgA3AwAgA0EQaiADQYgBakEUaikCADcDACADQQhqIANBiAFqQQxqKQIANwMAIAMgAykCjAE3Aw\
AgAyAHNwM4IAQgA0EBEBALIAFBwABqQQA6AAAgAiAAKAIIIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA\
/gNxIAFBGHZycjYAACACIABBDGooAgAiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNg\
AEIAIgAEEQaigCACIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnI2AAggAiAAQRRqKAIA\
IgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYADCACIABBGGooAgAiAUEYdCABQQh0QY\
CA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAQIAIgAEEcaigCACIBQRh0IAFBCHRBgID8B3FyIAFBCHZB\
gP4DcSABQRh2cnI2ABQgAiAAQSBqKAIAIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycj\
YAGCACIABBJGooAgAiAEEYdCAAQQh0QYCA/AdxciAAQQh2QYD+A3EgAEEYdnJyNgAcIANB0AFqJAAL\
ogYCA38CfiMAQfABayIDJAAgACkDACEGIAEgAUHAAGotAAAiBGoiBUGAAToAACADQQhqQRBqIABBGG\
ooAgA2AgAgA0EQaiAAQRBqKQIANwMAIAMgACkCCDcDCCAGQgmGIAStQgOGhCIGQgiIQoCAgPgPgyAG\
QhiIQoCA/AeDhCAGQiiIQoD+A4MgBkI4iISEIQcgBkI4hiAGQiiGQoCAgICAgMD/AIOEIAZCGIZCgI\
CAgIDgP4MgBkIIhkKAgICA8B+DhIQhBgJAIARBP3MiAEUNACAFQQFqQQAgABA6GgsgBiAHhCEGAkAC\
QCAEQThxQThGDQAgAUE4aiAGNwAAIANBCGogAUEBEBQMAQsgA0EIaiABQQEQFCADQeAAakEMakIANw\
IAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQgA3AgAg\
A0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQcAANgJgIANBqAFqIANB4ABqQcQAEDkaIA\
NB0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIA\
NwMAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQ\
IANwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgakEBEBQLIAFBwABqQQA6AAAgAiADKAIIIgFB\
GHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYAACACIAMoAgwiAUEYdCABQQh0QYCA/Adxci\
ABQQh2QYD+A3EgAUEYdnJyNgAEIAIgAygCECIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2\
cnI2AAggAiADKAIUIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYADCACIAMoAhgiAU\
EYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAQIANB8AFqJAALsgYBFX8jAEGwAWsiAiQA\
AkACQAJAIAAoApABIgMgAXunIgRNDQAgAEHwAGohBSACQShqIQYgAkEIaiEHIAJB8ABqQSBqIQggA0\
F/aiEJIANBBXQgAGpB1ABqIQogA0F+akE3SSELA0AgACAJNgKQASAJRQ0CIAAgCUF/aiIMNgKQASAA\
LQBqIQ0gAkHwAGpBGGoiAyAKQRhqIg4pAAA3AwAgAkHwAGpBEGoiDyAKQRBqIhApAAA3AwAgAkHwAG\
pBCGoiESAKQQhqIhIpAAA3AwAgCCAKQSBqKQAANwAAIAhBCGogCkEoaikAADcAACAIQRBqIApBMGop\
AAA3AAAgCEEYaiAKQThqKQAANwAAIAcgBSkDADcDACAHQQhqIAVBCGoiEykDADcDACAHQRBqIAVBEG\
oiFCkDADcDACAHQRhqIAVBGGoiFSkDADcDACACIAopAAA3A3AgBkE4aiACQfAAakE4aikDADcAACAG\
QTBqIAJB8ABqQTBqKQMANwAAIAZBKGogAkHwAGpBKGopAwA3AAAgBkEgaiAIKQMANwAAIAZBGGogAy\
kDADcAACAGQRBqIA8pAwA3AAAgBkEIaiARKQMANwAAIAYgAikDcDcAACACQcAAOgBoIAIgDUEEciIN\
OgBpIAJCADcDACADIBUpAgA3AwAgDyAUKQIANwMAIBEgEykCADcDACACIAUpAgA3A3AgAkHwAGogBk\
HAAEIAIA0QGSADKAIAIQMgDygCACEPIBEoAgAhESACKAKMASENIAIoAoQBIRMgAigCfCEUIAIoAnQh\
FSACKAJwIRYgC0UNAyAKIBY2AgAgCkEcaiANNgIAIA4gAzYCACAKQRRqIBM2AgAgECAPNgIAIApBDG\
ogFDYCACASIBE2AgAgCkEEaiAVNgIAIAAgCTYCkAEgCkFgaiEKIAwhCSAMIARPDQALCyACQbABaiQA\
DwtBoJHAAEErQZCFwAAQUwALIAIgDTYCjAEgAiADNgKIASACIBM2AoQBIAIgDzYCgAEgAiAUNgJ8IA\
IgETYCeCACIBU2AnQgAiAWNgJwQZCSwAAgAkHwAGpBgIbAAEH4hsAAEEAAC4IFAQd/IAAoAgAiBUEB\
cSIGIARqIQcCQAJAIAVBBHENAEEAIQEMAQsCQAJAIAINAEEAIQgMAQsCQCACQQNxIgkNAAwBC0EAIQ\
ggASEKA0AgCCAKLAAAQb9/SmohCCAKQQFqIQogCUF/aiIJDQALCyAIIAdqIQcLQStBgIDEACAGGyEG\
AkACQCAAKAIIQQFGDQBBASEKIAAgBiABIAIQUg0BIAAoAhggAyAEIABBHGooAgAoAgwRCAAPCwJAAk\
ACQAJAAkAgAEEMaigCACIIIAdNDQAgBUEIcQ0EQQAhCiAIIAdrIgkhBUEBIAAtACAiCCAIQQNGG0ED\
cQ4DAwECAwtBASEKIAAgBiABIAIQUg0EIAAoAhggAyAEIABBHGooAgAoAgwRCAAPC0EAIQUgCSEKDA\
ELIAlBAXYhCiAJQQFqQQF2IQULIApBAWohCiAAQRxqKAIAIQkgACgCBCEIIAAoAhghBwJAA0AgCkF/\
aiIKRQ0BIAcgCCAJKAIQEQYARQ0AC0EBDwtBASEKIAhBgIDEAEYNASAAIAYgASACEFINASAHIAMgBC\
AJKAIMEQgADQFBACEKAkADQAJAIAUgCkcNACAFIQoMAgsgCkEBaiEKIAcgCCAJKAIQEQYARQ0ACyAK\
QX9qIQoLIAogBUkhCgwBCyAAKAIEIQUgAEEwNgIEIAAtACAhC0EBIQogAEEBOgAgIAAgBiABIAIQUg\
0AIAggB2tBAWohCiAAQRxqKAIAIQggACgCGCEJAkADQCAKQX9qIgpFDQEgCUEwIAgoAhARBgBFDQAL\
QQEPC0EBIQogCSADIAQgCCgCDBEIAA0AIAAgCzoAICAAIAU2AgRBAA8LIAoLjwUBCn8jAEEwayIDJA\
AgA0EkaiABNgIAIANBAzoAKCADQoCAgICABDcDCCADIAA2AiBBACEEIANBADYCGCADQQA2AhACQAJA\
AkACQCACKAIIIgUNACACQRRqKAIAIgZFDQEgAigCACEBIAIoAhAhACAGQQN0QXhqQQN2QQFqIgQhBg\
NAAkAgAUEEaigCACIHRQ0AIAMoAiAgASgCACAHIAMoAiQoAgwRCAANBAsgACgCACADQQhqIABBBGoo\
AgARBgANAyAAQQhqIQAgAUEIaiEBIAZBf2oiBg0ADAILCyACQQxqKAIAIgBFDQAgAEEFdCIIQWBqQQ\
V2QQFqIQQgAigCACEBQQAhBgNAAkAgAUEEaigCACIARQ0AIAMoAiAgASgCACAAIAMoAiQoAgwRCAAN\
AwsgAyAFIAZqIgBBHGotAAA6ACggAyAAQQRqKQIAQiCJNwMIIABBGGooAgAhCSACKAIQIQpBACELQQ\
AhBwJAAkACQCAAQRRqKAIADgMBAAIBCyAJQQN0IQxBACEHIAogDGoiDCgCBEEFRw0BIAwoAgAoAgAh\
CQtBASEHCyADIAk2AhQgAyAHNgIQIABBEGooAgAhBwJAAkACQCAAQQxqKAIADgMBAAIBCyAHQQN0IQ\
kgCiAJaiIJKAIEQQVHDQEgCSgCACgCACEHC0EBIQsLIAMgBzYCHCADIAs2AhggCiAAKAIAQQN0aiIA\
KAIAIANBCGogACgCBBEGAA0CIAFBCGohASAIIAZBIGoiBkcNAAsLQQAhACAEIAIoAgRJIgFFDQEgAy\
gCICACKAIAIARBA3RqQQAgARsiASgCACABKAIEIAMoAiQoAgwRCABFDQELQQEhAAsgA0EwaiQAIAAL\
jwQBCX8jAEEwayIGJABBACEHIAZBADYCCAJAIAFBQHEiCEUNAEEBIQcgBkEBNgIIIAYgADYCACAIQc\
AARg0AQQIhByAGQQI2AgggBiAAQcAAajYCBCAIQYABRg0AIAYgAEGAAWo2AhBBkJLAACAGQRBqQZCG\
wABB+IbAABBAAAsgAUE/cSEJAkAgBUEFdiIBIAcgByABSxsiAUUNACADQQRyIQogAUEFdCELQQAhAS\
AGIQMDQCADKAIAIQcgBkEQakEYaiIMIAJBGGopAgA3AwAgBkEQakEQaiINIAJBEGopAgA3AwAgBkEQ\
akEIaiIOIAJBCGopAgA3AwAgBiACKQIANwMQIAZBEGogB0HAAEIAIAoQGSAEIAFqIgdBGGogDCkDAD\
cAACAHQRBqIA0pAwA3AAAgB0EIaiAOKQMANwAAIAcgBikDEDcAACADQQRqIQMgCyABQSBqIgFHDQAL\
IAYoAgghBwsCQAJAAkACQCAJRQ0AIAdBBXQiAiAFSw0BIAUgAmsiAUEfTQ0CIAlBIEcNAyAEIAJqIg\
IgACAIaiIBKQAANwAAIAJBGGogAUEYaikAADcAACACQRBqIAFBEGopAAA3AAAgAkEIaiABQQhqKQAA\
NwAAIAdBAWohBwsgBkEwaiQAIAcPCyACIAVBsITAABBKAAtBICABQbCEwAAQSQALQSAgCUHki8AAEE\
wAC4EEAgN/An4jAEHwAWsiAyQAIAApAwAhBiABIAFBwABqLQAAIgRqIgVBgAE6AAAgA0EIakEQaiAA\
QRhqKAIANgIAIANBEGogAEEQaikCADcDACADIAApAgg3AwggBkIJhiEGIAStQgOGIQcCQCAEQT9zIg\
BFDQAgBUEBakEAIAAQOhoLIAYgB4QhBgJAAkAgBEE4cUE4Rg0AIAFBOGogBjcAACADQQhqIAEQEgwB\
CyADQQhqIAEQEiADQeAAakEMakIANwIAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAak\
EkakIANwIAIANB4ABqQSxqQgA3AgAgA0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQcAA\
NgJgIANBqAFqIANB4ABqQcQAEDkaIANB0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQ\
IANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEU\
aikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgahASCy\
ACIAMoAgg2AAAgAiADKQIMNwAEIAIgAykCFDcADCABQcAAakEAOgAAIANB8AFqJAAL8AMCA38CfiMA\
QfABayIDJAAgAUHAAGotAAAhBCAAKQMAIQYgA0EQaiAAQRBqKQIANwMAIAMgACkCCDcDCCABIARqIg\
BBgAE6AAAgBkIJhiEGIAStQgOGIQcgAyADQQhqNgIcAkAgBEE/cyIFRQ0AIABBAWpBACAFEDoaCyAH\
IAaEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgA0EcaiABEBwMAQsgA0EcaiABEBwgA0HgAGpBDG\
pCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpBJGpCADcCACADQeAAakEsakIA\
NwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0HAADYCYCADQagBaiADQeAAakHEAB\
A5GiADQdAAaiADQagBakE0aikCADcDACADQcgAaiADQagBakEsaikCADcDACADQcAAaiADQagBakEk\
aikCADcDACADQThqIANBqAFqQRxqKQIANwMAIANBMGogA0GoAWpBFGopAgA3AwAgA0EoaiADQagBak\
EMaikCADcDACADIAMpAqwBNwMgIAMgBjcDWCADQRxqIANBIGoQHAsgAUHAAGpBADoAACACIAMpAwg3\
AAAgAiADKQMQNwAIIANB8AFqJAAL2QMCA38CfiMAQeABayIDJAAgACkDACEGIAEgAUHAAGotAAAiBG\
oiBUGAAToAACADQQhqIABBEGopAgA3AwAgAyAAKQIINwMAIAZCCYYhBiAErUIDhiEHAkAgBEE/cyIA\
RQ0AIAVBAWpBACAAEDoaCyAHIAaEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgAyABEB8MAQsgAy\
ABEB8gA0HQAGpBDGpCADcCACADQdAAakEUakIANwIAIANB0ABqQRxqQgA3AgAgA0HQAGpBJGpCADcC\
ACADQdAAakEsakIANwIAIANB0ABqQTRqQgA3AgAgA0GMAWpCADcCACADQgA3AlQgA0HAADYCUCADQZ\
gBaiADQdAAakHEABA5GiADQcAAaiADQZgBakE0aikCADcDACADQThqIANBmAFqQSxqKQIANwMAIANB\
MGogA0GYAWpBJGopAgA3AwAgA0EoaiADQZgBakEcaikCADcDACADQSBqIANBmAFqQRRqKQIANwMAIA\
NBGGogA0GYAWpBDGopAgA3AwAgAyADKQKcATcDECADIAY3A0ggAyADQRBqEB8LIAIgAykDADcAACAC\
IAMpAwg3AAggAUHAAGpBADoAACADQeABaiQAC9QDAgR/An4jAEHQAWsiAyQAIAEgAUHAAGotAAAiBG\
oiBUEBOgAAIAApAwBCCYYhByAErUIDhiEIAkAgBEE/cyIGRQ0AIAVBAWpBACAGEDoaCyAHIAiEIQcC\
QAJAIARBOHFBOEYNACABQThqIAc3AAAgAEEIaiABQQEQFwwBCyAAQQhqIgQgAUEBEBcgA0HAAGpBDG\
pCADcCACADQcAAakEUakIANwIAIANBwABqQRxqQgA3AgAgA0HAAGpBJGpCADcCACADQcAAakEsakIA\
NwIAIANBwABqQTRqQgA3AgAgA0H8AGpCADcCACADQgA3AkQgA0HAADYCQCADQYgBaiADQcAAakHEAB\
A5GiADQTBqIANBiAFqQTRqKQIANwMAIANBKGogA0GIAWpBLGopAgA3AwAgA0EgaiADQYgBakEkaikC\
ADcDACADQRhqIANBiAFqQRxqKQIANwMAIANBEGogA0GIAWpBFGopAgA3AwAgA0EIaiADQYgBakEMai\
kCADcDACADIAMpAowBNwMAIAMgBzcDOCAEIANBARAXCyABQcAAakEAOgAAIAIgACkDCDcAACACIABB\
EGopAwA3AAggAiAAQRhqKQMANwAQIANB0AFqJAALlwMBBX8jAEGQBGsiAyQAIABByAFqIQQCQAJAAk\
ACQAJAIABB8AJqLQAAIgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEDkgBmohASACIAZrIQILIAIg\
AkGoAW4iBUGoAWwiB0kNASACIAdrIQYCQCAFQagBbCICRQ0AIAEhBQNAIANB4AJqIABBqAEQORogAB\
AkIAUgA0HgAmpBqAEQOUGoAWohBSACQdh+aiICDQALCwJAIAYNAEEAIQYMBAsgA0EANgKwASADQbAB\
akEEckEAQagBEDoaIANBqAE2ArABIANB4AJqIANBsAFqQawBEDkaIANBCGogA0HgAmpBBHJBqAEQOR\
ogA0HgAmogAEGoARA5GiAAECQgA0EIaiADQeACakGoARA5GiAGQakBTw0CIAEgB2ogA0EIaiAGEDka\
IAQgA0EIakGoARA5GgwDCyABIAQgBWogAhA5GiAFIAJqIQYMAgtBoY3AAEEjQcSNwAAQUwALIAZBqA\
FBxIzAABBJAAsgAEHwAmogBjoAACADQZAEaiQAC5cDAQV/IwBBsANrIgMkACAAQcgBaiEEAkACQAJA\
AkACQCAAQdACai0AACIFRQ0AQYgBIAVrIgYgAksNASABIAQgBWogBhA5IAZqIQEgAiAGayECCyACIA\
JBiAFuIgVBiAFsIgdJDQEgAiAHayEGAkAgBUGIAWwiAkUNACABIQUDQCADQaACaiAAQYgBEDkaIAAQ\
JCAFIANBoAJqQYgBEDlBiAFqIQUgAkH4fmoiAg0ACwsCQCAGDQBBACEGDAQLIANBADYCkAEgA0GQAW\
pBBHJBAEGIARA6GiADQYgBNgKQASADQaACaiADQZABakGMARA5GiADQQhqIANBoAJqQQRyQYgBEDka\
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\
BHJBqAEQOSABLQCoAToAqAEgAkHgAmokAAtyAQJ/IwBBoAFrIgIkAEEAIQMgAkEANgIAA0AgAiADak\
EEaiABIANqKAAANgIAIANBBGoiA0HIAEcNAAsgAkHIADYCACACQdAAaiACQcwAEDkaIAAgAkHQAGpB\
BHJByAAQOSABLQBIOgBIIAJBoAFqJAALcgECfyMAQeABayICJABBACEDIAJBADYCAANAIAIgA2pBBG\
ogASADaigAADYCACADQQRqIgNB6ABHDQALIAJB6AA2AgAgAkHwAGogAkHsABA5GiAAIAJB8ABqQQRy\
QegAEDkgAS0AaDoAaCACQeABaiQAC3QBAn8jAEGwAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIA\
EgA2ooAAA2AgAgA0EEaiIDQZABRw0ACyACQZABNgIAIAJBmAFqIAJBlAEQORogACACQZgBakEEckGQ\
ARA5IAEtAJABOgCQASACQbACaiQAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2Ag\
AgA0EsakEDNgIAIANCAjcCDCADQciKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyAD\
NgIgIANBCGogAhBWAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAz\
YCACADQgI3AgwgA0GoisAANgIIIANBAzYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhq\
IAIQVgALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNw\
IMIANB/IrAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEFYAC2wB\
AX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAzcCDCADQcyLwA\
A2AgggA0EDNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhBWAAtsAQF/IwBBMGsi\
AyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GEiMAANgIIIANBAz\
YCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQVgALdQECf0EBIQBBAEEAKAKA1UAi\
AUEBajYCgNVAAkACQEEAKALI2EBBAUcNAEEAKALM2EBBAWohAAwBC0EAQQE2AsjYQAtBACAANgLM2E\
ACQCABQQBIDQAgAEECSw0AQQAoAvzUQEF/TA0AIABBAUsNABBzAAsAC5oBACMAQTBrGiAAQgA3A0Ag\
AEE4akL5wvibkaOz8NsANwMAIABBMGpC6/qG2r+19sEfNwMAIABBKGpCn9j52cKR2oKbfzcDACAAQt\
GFmu/6z5SH0QA3AyAgAELx7fT4paf9p6V/NwMYIABCq/DT9K/uvLc8NwMQIABCu86qptjQ67O7fzcD\
CCAAIAGtQoiS95X/zPmE6gCFNwMAC1UBAn8CQAJAIABFDQAgACgCAA0BIABBADYCACAAKAIIIQEgAC\
gCBCECIAAQHgJAIAJBBEcNACABKAKQAUUNACABQQA2ApABCyABEB4PCxBuAAsQbwALSgEDf0EAIQMC\
QCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIA\
VrIQMLIAMLVAEBfwJAAkACQCABQYCAxABGDQBBASEEIAAoAhggASAAQRxqKAIAKAIQEQYADQELIAIN\
AUEAIQQLIAQPCyAAKAIYIAIgAyAAQRxqKAIAKAIMEQgAC0cBAX8jAEEgayIDJAAgA0EUakEANgIAIA\
NBoJHAADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEFYACzkAAkACQCABRQ0A\
IAEoAgANASABQX82AgAgAUEEaiACEDYgAUEANgIAIABCADcDAA8LEG4ACxBvAAtSACAAQsfMo9jW0O\
uzu383AwggAEIANwMAIABBIGpCq7OP/JGjs/DbADcDACAAQRhqQv+kuYjFkdqCm383AwAgAEEQakLy\
5rvjo6f9p6V/NwMACzQBAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQcCHwAA2AgQgAkGgkcAANg\
IAIAIQZwALIwACQCAAQXxLDQACQCAADQBBBA8LIAAQFiIARQ0AIAAPCwALJQACQCAADQBBsI/AAEEw\
EHAACyAAIAIgAyAEIAUgASgCEBEMAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEKAA\
sjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEJAAsjAAJAIAANAEGwj8AAQTAQcAALIAAg\
AiADIAQgASgCEBEKAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEJAAsjAAJAIAANAE\
Gwj8AAQTAQcAALIAAgAiADIAQgASgCEBEJAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgC\
EBEVAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEWAAshAAJAIAANAEGwj8AAQTAQcA\
ALIAAgAiADIAEoAhARBwALHgAgAEEUaigCABoCQCAAQQRqKAIADgIAAAALEE4ACxwAAkACQCABQXxL\
DQAgACACECYiAQ0BCwALIAELHwACQCAADQBBsI/AAEEwEHAACyAAIAIgASgCEBEGAAsaAAJAIAANAE\
GgkcAAQStB6JHAABBTAAsgAAsUACAAKAIAIAEgACgCBCgCDBEGAAsQACABIAAoAgAgACgCBBAlCw4A\
IAAoAggQZCAAEHEACw4AAkAgAUUNACAAEB4LCxEAQYKCwABBEUGUgsAAEFMACxEAQaSCwABBL0Gkg8\
AAEFMACw0AIAAoAgAaA38MAAsLCwAgACMAaiQAIwALCwAgADUCACABEDQLDABByNLAAEEbEHAACw0A\
QePSwABBzwAQcAALCQAgACABEAsACwkAIAAgARBhAAsMAEKl8JbP5f/ppVYLAwAACwIACwIACwv+1I\
CAAAEAQYCAwAAL9FT0BRAAUAAAAJUAAAAJAAAAQkxBS0UyQkJMQUtFMkItMjU2QkxBS0UyQi0zODRC\
TEFLRTJTQkxBS0UzS0VDQ0FLLTIyNEtFQ0NBSy0yNTZLRUNDQUstMzg0S0VDQ0FLLTUxMk1ENE1ENV\
JJUEVNRC0xNjBTSEEtMVNIQS0yMjRTSEEtMjU2U0hBLTM4NFNIQS01MTJUSUdFUnVuc3VwcG9ydGVk\
IGFsZ29yaXRobW5vbi1kZWZhdWx0IGxlbmd0aCBzcGVjaWZpZWQgZm9yIG5vbi1leHRlbmRhYmxlIG\
FsZ29yaXRobWxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNjYXBhY2l0eSBvdmVyZmxvdwDmABAA\
HAAAADICAAAFAAAAQXJyYXlWZWM6IGNhcGFjaXR5IGV4Y2VlZGVkIGluIGV4dGVuZC9mcm9tX2l0ZX\
J+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2FycmF5dmVj\
LTAuNy4yL3NyYy9hcnJheXZlYy5ycwBTARAAUAAAAAEEAAAFAAAAVAYQAE0AAAABBgAACQAAAH4vLm\
NhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYmxha2UzLTEuMy4w\
L3NyYy9saWIucnMAAADEARAASQAAALkBAAAJAAAAxAEQAEkAAABfAgAACgAAAMQBEABJAAAAjQIAAA\
kAAADEARAASQAAAN0CAAAKAAAAxAEQAEkAAADWAgAACQAAAMQBEABJAAAAAQMAABkAAADEARAASQAA\
AAMDAAAJAAAAxAEQAEkAAAADAwAAOAAAAMQBEABJAAAA+AMAADIAAADEARAASQAAAKoEAAAWAAAAxA\
EQAEkAAAC8BAAAFgAAAMQBEABJAAAA7QQAABIAAADEARAASQAAAPcEAAASAAAAxAEQAEkAAABpBQAA\
IQAAABEAAAAEAAAABAAAABIAAAARAAAAIAAAAAEAAAATAAAAEQAAAAQAAAAEAAAAEgAAAH4vLmNhcm\
dvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYXJyYXl2ZWMtMC43LjIv\
c3JjL2FycmF5dmVjX2ltcGwucnMAAAAgAxAAVQAAACcAAAAgAAAAQ2FwYWNpdHlFcnJvcgAAAIgDEA\
ANAAAAaW5zdWZmaWNpZW50IGNhcGFjaXR5AAAAoAMQABUAAAARAAAAAAAAAAEAAAAUAAAAaW5kZXgg\
b3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAAANADEAAgAAAA8AMQAB\
IAAAA6IAAAoAgQAAAAAAAUBBAAAgAAACkwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2\
MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NT\
Q2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3\
NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OXJhbmdlIHN0YX\
J0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCAAAADxBBAAEgAAAAMFEAAi\
AAAAcmFuZ2UgZW5kIGluZGV4IDgFEAAQAAAAAwUQACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIG\
J1dCBlbmRzIGF0IABYBRAAFgAAAG4FEAANAAAAc291cmNlIHNsaWNlIGxlbmd0aCAoKSBkb2VzIG5v\
dCBtYXRjaCBkZXN0aW5hdGlvbiBzbGljZSBsZW5ndGggKIwFEAAVAAAAoQUQACsAAAAoBBAAAQAAAF\
QGEABNAAAAEAwAAA0AAAB+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRi\
OWVjODIzL2Jsb2NrLWJ1ZmZlci0wLjEwLjAvc3JjL2xpYi5yc/QFEABQAAAA/AAAACcAAAAvcnVzdG\
MvZjFlZGQwNDI5NTgyZGQyOWNjY2FjYWY1MGZkMTM0YjA1NTkzYmQ5Yy9saWJyYXJ5L2NvcmUvc3Jj\
L3NsaWNlL21vZC5yc2Fzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpVAYQAE0AAAAfBg\
AACQAAAAAAAAABI0VniavN7/7cuph2VDIQ8OHSwwAAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur\
2YMfGc3gW9ieBcEH1Xw2F91wMDlZDvcxC8D/ERVYaKeP+WSkT/q+CMm882fmCWo7p8qEha5nuyv4lP\
5y82488TYdXzr1T6XRguatf1IOUR9sPiuMaAWba71B+6vZgx95IX4TGc3gW9ieBcFdnbvLB9V8Niop\
mmIX3XAwWgFZkTlZDvfY7C8VMQvA/2cmM2cRFVhoh0q0jqeP+WQNLgzbpE/6vh1ItUdjbG9zdXJlIG\
ludm9rZWQgcmVjdXJzaXZlbHkgb3IgZGVzdHJveWVkIGFscmVhZHkBAAAAAAAAAIKAAAAAAAAAioAA\
AAAAAIAAgACAAAAAgIuAAAAAAAAAAQAAgAAAAACBgACAAAAAgAmAAAAAAACAigAAAAAAAACIAAAAAA\
AAAAmAAIAAAAAACgAAgAAAAACLgACAAAAAAIsAAAAAAACAiYAAAAAAAIADgAAAAAAAgAKAAAAAAACA\
gAAAAAAAAIAKgAAAAAAAAAoAAIAAAACAgYAAgAAAAICAgAAAAAAAgAEAAIAAAAAACIAAgAAAAIBjYW\
xsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbGlicmFyeS9zdGQvc3JjL3Bh\
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\
AAAAHAAAACAAAAAwAAAAQAAAABAAAAAQAAAAFAAAABQAAAAcAAAAIAAAADAAAABAAAAAHAAAACAAAA\
AwAAAAQAAAACAAAABAAAAAGAAAAEAAAAAgAAAAMAAAACAAAAAgAAAAHAAAACAAAAAwAAAAQAAAABAA\
AAAQAAAAFAAAABQAAAAcAAAAIAAAADAAAABAAAAAHAAAACAAAAAwAAAAQAAAACAAAABAAAAAGAAAAA\
Cnt4CAAARuYW1lAZy3gIAAdgBFanNfc3lzOjpUeXBlRXJyb3I6Om5ldzo6X193YmdfbmV3X2E0YjYx\
YTBmNTQ4MjRjZmQ6OmgzNzE2N2VmMDcyNjZmMmQ1ATt3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fb2\
JqZWN0X2Ryb3BfcmVmOjpoNzkzYmExMTZkNzVlMjJhMAJVanNfc3lzOjpVaW50OEFycmF5OjpieXRl\
X2xlbmd0aDo6X193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3OjpoMTNkMDIzOGI2ODlhOT\
YwYwNVanNfc3lzOjpVaW50OEFycmF5OjpieXRlX29mZnNldDo6X193YmdfYnl0ZU9mZnNldF80MjA0\
ZWNiMjRhNmU1ZGY5OjpoOGY0YmM4MWQ5MGE4MjMzZQRManNfc3lzOjpVaW50OEFycmF5OjpidWZmZX\
I6Ol9fd2JnX2J1ZmZlcl9mYWNmMDM5OGEyODFjODViOjpoMGZiNjA5YTUxNjQ3NmU5MgV5anNfc3lz\
OjpVaW50OEFycmF5OjpuZXdfd2l0aF9ieXRlX29mZnNldF9hbmRfbGVuZ3RoOjpfX3diZ19uZXd3aX\
RoYnl0ZW9mZnNldGFuZGxlbmd0aF80YjliOGM0ZTNmNWFkYmZmOjpoYzI4MjE3ODU0OTVlMmE2MgZM\
anNfc3lzOjpVaW50OEFycmF5OjpsZW5ndGg6Ol9fd2JnX2xlbmd0aF8xZWI4ZmM2MDhhMGQ0Y2RiOj\
poNzNkYzkyYWJjODFkM2ZhNwcyd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX21lbW9yeTo6aDRjOWRj\
YzlmYzQzMmZlMmMIVWpzX3N5czo6V2ViQXNzZW1ibHk6Ok1lbW9yeTo6YnVmZmVyOjpfX3diZ19idW\
ZmZXJfMzk3ZWFhNGQ3MmVlOTRkZDo6aDM5ZDIzMjAwNzgzMjBiYzAJRmpzX3N5czo6VWludDhBcnJh\
eTo6bmV3OjpfX3diZ19uZXdfYTdjZTQ0N2YxNWZmNDk2Zjo6aDZjZjg5NDdiODY4ZmRlZWYKRmpzX3\
N5czo6VWludDhBcnJheTo6c2V0OjpfX3diZ19zZXRfOTY5YWQwYTYwZTUxZDMyMDo6aDUxN2Q1OGEy\
M2QyYjc4MTkLMXdhc21fYmluZGdlbjo6X193YmluZGdlbl90aHJvdzo6aDY5MTE5ZDhjZWJhYTQ0M2\
YMQGRlbm9fc3RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OmRpZ2VzdDo6aDgyOGE3MDEx\
NDE1ZjA1MjANLHNoYTI6OnNoYTUxMjo6Y29tcHJlc3M1MTI6Omg2YjEwYzMzYWQwNWMzNWY2DkpkZW\
5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpkaWdlc3RfYW5kX3Jlc2V0OjpoZjlk\
NDIwYzUyNDhhOTJmNg9AZGVub19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6dXBkYX\
RlOjpoMWFhNzQ2YmE5ZTJlMTdhNRAsc2hhMjo6c2hhMjU2Ojpjb21wcmVzczI1Njo6aGU4NzgwMjlj\
Y2ZkZDNkZjQRM2JsYWtlMjo6Qmxha2UyYlZhckNvcmU6OmNvbXByZXNzOjpoOWY4N2E3NmE4ZmJlZT\
IyYhIpcmlwZW1kOjpjMTYwOjpjb21wcmVzczo6aDE4OWM0NzlmYmQ2N2FmYWQTM2JsYWtlMjo6Qmxh\
a2Uyc1ZhckNvcmU6OmNvbXByZXNzOjpoOWRkYTljMmEyYjYxNzY4ORQrc2hhMTo6Y29tcHJlc3M6Om\
NvbXByZXNzOjpoNTBlNWQ4M2U5MWQ2NTRhYRU7ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENv\
bnRleHQ6Om5ldzo6aGY0NjA2NTg2NmYzZDY2NjAWOmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2\
M8QT46Om1hbGxvYzo6aDJhMjcyMDdlZTlhZjdmZTkXLHRpZ2VyOjpjb21wcmVzczo6Y29tcHJlc3M6\
Omg2ZDI1OGZiZjc1NDhiZmUxGC1ibGFrZTM6Ok91dHB1dFJlYWRlcjo6ZmlsbDo6aGE5YzI3MGM5Yj\
dmZjQxZWUZNmJsYWtlMzo6cG9ydGFibGU6OmNvbXByZXNzX2luX3BsYWNlOjpoYzRhZDc0NzdjYmY1\
MmYwZRoTZGlnZXN0Y29udGV4dF9jbG9uZRtlPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcm\
VXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aGU3N2Fm\
YjMxMmY4OGY0MzccaDxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdX\
RDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6e3tjbG9zdXJlfX06Omg3OThjNzA3YzdjZGEzNTky\
HTBibGFrZTM6OmNvbXByZXNzX3N1YnRyZWVfd2lkZTo6aDk5NWY5MmEwOTlkOTg2MzQeOGRsbWFsbG\
9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6OmhjYjc5NDdhOWE3ZTI4MmNhHyBtZDQ6OmNv\
bXByZXNzOjpoOTBkNTQwMzZjYTYzM2UzYyBBZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPj\
o6ZGlzcG9zZV9jaHVuazo6aDJmOTBiZGRmYWI5ZmRhZjkhE2RpZ2VzdGNvbnRleHRfcmVzZXQicjxz\
aGEyOjpjb3JlX2FwaTo6U2hhNTEyVmFyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpWYXJpYWJsZU\
91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9jb3JlOjpoOWVhNGEyMTU4ZTA3MDMzYiMvYmxh\
a2UzOjpIYXNoZXI6OmZpbmFsaXplX3hvZjo6aGI4ODNlNmM1YzRlNWQ0MGIkIGtlY2Nhazo6ZjE2MD\
A6OmhhODI1NzkwY2YyNWE1ZjVlJSxjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkOjpoNDlkMmNmY2Nh\
ZmJiZGU0ZCYOX19ydXN0X3JlYWxsb2MncjxzaGEyOjpjb3JlX2FwaTo6U2hhMjU2VmFyQ29yZSBhcy\
BkaWdlc3Q6OmNvcmVfYXBpOjpWYXJpYWJsZU91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9j\
b3JlOjpoMDNhOTMwYjhjNzRjOWVkNShdPHNoYTE6OlNoYTFDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcG\
k6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhiNWQ5ZWM3MDI0OGUxODIw\
KTFibGFrZTM6Okhhc2hlcjo6bWVyZ2VfY3Zfc3RhY2s6Omg0N2I2ZTI0ZTY3ZTIxNjViKjVjb3JlOj\
pmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjpoYzY2OTQ3YjFkZWQ1NzhhYSsjY29yZTo6Zm10\
Ojp3cml0ZTo6aGJiYWYzOWYwOWJmNDllZmIsNGJsYWtlMzo6Y29tcHJlc3NfcGFyZW50c19wYXJhbG\
xlbDo6aGEwNzMyZmFjYjEyNzY5YmItZDxyaXBlbWQ6OlJpcGVtZDE2MENvcmUgYXMgZGlnZXN0Ojpj\
b3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGRlOGZjMmFmNz\
ExZjE4NWYuWzxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3Jl\
Pjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDBiMzAwM2U0ODQyOWFjM2QvWzxtZDQ6Ok1kNENvcmUgYX\
MgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6\
aDNlMmIzMDA3MzBhYThhZjAwXzx0aWdlcjo6VGlnZXJDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6Ok\
ZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg0NTczYTQwZWJjNTRjYTUzMWU8\
ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZG\
lnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjpoZTUwZWUyZjliMmYyYmQ0YTJlPGRpZ2VzdDo6Y29yZV9h\
cGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZG\
VyPjo6cmVhZDo6aDZkN2E3MzhlNTE0MWViZTAzLWJsYWtlMzo6Q2h1bmtTdGF0ZTo6dXBkYXRlOjpo\
YzU4OGE4Y2Q3YzI2Y2VmNTQvY29yZTo6Zm10OjpudW06OmltcDo6Zm10X3U2NDo6aDY2MjhhM2U3Mj\
I3ZTg1NTM1BmRpZ2VzdDY+ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6OnVwZGF0\
ZTo6aDEzYWE5MGI2YzVlZGM0ODY3WzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZS\
xLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDU2ZDNhMWQ5YzZmOTE3YmU4G2Rp\
Z2VzdGNvbnRleHRfZGlnZXN0QW5kRHJvcDkGbWVtY3B5OgZtZW1zZXQ7P3dhc21fYmluZGdlbjo6Y2\
9udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoZDk2N2Y0MzRjNzJmNGU0MjwRZGlnZXN0Y29u\
dGV4dF9uZXc9FGRpZ2VzdGNvbnRleHRfZGlnZXN0Pi1qc19zeXM6OlVpbnQ4QXJyYXk6OnRvX3ZlYz\
o6aDYzOWJmOTBlOTEwZTgxZDQ/HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXRALmNvcmU6OnJl\
c3VsdDo6dW53cmFwX2ZhaWxlZDo6aGQ1ODRlZmI3Yjg0YmYzMjZBUDxhcnJheXZlYzo6ZXJyb3JzOj\
pDYXBhY2l0eUVycm9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg4Y2EzNjljOTgxMGMy\
MjI5QlA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYn\
VnPjo6Zm10OjpoYWJkMmI2NDNkZDBlY2QyY0NbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8Qmxv\
Y2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMDhkN2U1MzhlNjI5MD\
QzOERbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNs\
b25lOjpDbG9uZT46OmNsb25lOjpoODc3ODZlMzY2MmMyNmQ2NEVbPGJsb2NrX2J1ZmZlcjo6QmxvY2\
tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoNWEx\
YTExYjkwNmU5M2QwM0ZbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IG\
FzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoNDUyMGIyMWMwYzI5ODk4Y0dbPGJsb2NrX2J1\
ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46Om\
Nsb25lOjpoYzQ4ZjUyNTk0NDZjMmVlY0hbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tT\
aXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMWM0ZTBjNjhlY2Q2NmI1NE\
k/Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6OmhjM2UwZGNmNmQ4\
NjZlMWJlSkFjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsOjpoNm\
MxMDlhYzg1ODdmMjkxMUs9Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWls\
OjpoZDI3ZGMzODVhN2VjMTNjMUxOY29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbG\
ljZTo6bGVuX21pc21hdGNoX2ZhaWw6OmhlZGQxMGM1YmNjMDI2MTBjTTZjb3JlOjpwYW5pY2tpbmc6\
OnBhbmljX2JvdW5kc19jaGVjazo6aGNlMDUwMmY2MzcxMWZhZDhON3N0ZDo6cGFuaWNraW5nOjpydX\
N0X3BhbmljX3dpdGhfaG9vazo6aDYwNmQ3YzdmN2E0MjNiOThPOmJsYWtlMjo6Qmxha2UyYlZhckNv\
cmU6Om5ld193aXRoX3BhcmFtczo6aDU4N2Y5YTcyNzlmMzcxNmRQGF9fd2JnX2RpZ2VzdGNvbnRleH\
RfZnJlZVEGbWVtY21wUkNjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjp3cml0ZV9w\
cmVmaXg6OmhhYTBhZGYwMGNiNjdkZWQ3Uyljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoZWMxZmMwNT\
diZDBiYWYwYlQUZGlnZXN0Y29udGV4dF91cGRhdGVVOmJsYWtlMjo6Qmxha2Uyc1ZhckNvcmU6Om5l\
d193aXRoX3BhcmFtczo6aDVmZjQ1OWYyMzFhYjhkNjhWLWNvcmU6OnBhbmlja2luZzo6cGFuaWNfZm\
10OjpoNjMxNGI1YzkxYWJlNzM0OVcRX193YmluZGdlbl9tYWxsb2NYP3dhc21fYmluZGdlbjo6Y29u\
dmVydDo6Y2xvc3VyZXM6Omludm9rZTRfbXV0OjpoMDhiMDAxNWQ0NTZmMjBjN1k/d2FzbV9iaW5kZ2\
VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgzYWI0ZThkMTgzNDk0OWU4Wj93YXNt\
X2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDBlZmUyNDJjN2Q3ZmU2MG\
VbP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoYzRhYTBlM2Vm\
MWQ2ZDdhMVw/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Omg3OT\
lhYmFiYmRjZDEyZmEzXT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211\
dDo6aGE5NDFjMTBjNDA4ODhjNTBeP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm\
9rZTNfbXV0OjpoMTE4OWQ1YjVlY2U4MjQxYV8/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJl\
czo6aW52b2tlM19tdXQ6OmhiZGM0ZjBhM2ViZGQ5MDg2YD93YXNtX2JpbmRnZW46OmNvbnZlcnQ6Om\
Nsb3N1cmVzOjppbnZva2UyX211dDo6aGE2NDc2YjFhNTZlZDFhYjZhQ3N0ZDo6cGFuaWNraW5nOjpi\
ZWdpbl9wYW5pY19oYW5kbGVyOjp7e2Nsb3N1cmV9fTo6aDliOTg1YTI5M2FhYzRjZTFiEl9fd2Jpbm\
RnZW5fcmVhbGxvY2M/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMV9tdXQ6\
OmgwNzE4MzRjY2I3MGRmNzI1ZDJjb3JlOjpvcHRpb246Ok9wdGlvbjxUPjo6dW53cmFwOjpoNWE3ZG\
Y5MWI1ZDYwOTBjYmUwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgwZDljZDYyNmRhYmFh\
MWVmZjI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoZDMwM2JjMTZhZWU1NTkxMGcRcn\
VzdF9iZWdpbl91bndpbmRoD19fd2JpbmRnZW5fZnJlZWk0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5\
X292ZXJmbG93OjpoNGI0OTAxNDgzMGNhZmU2M2ozYXJyYXl2ZWM6OmFycmF5dmVjOjpleHRlbmRfcG\
FuaWM6OmgzN2Q1OThkNzVkMGQyZTZmazljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxf\
b25jZTo6aDJhYjg2NzY3ZWMxN2M1MGRsH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXJtTm\
NvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10\
OjpoMDQ2ZWNjNWVhYWIzNGNkNW4xd2FzbV9iaW5kZ2VuOjpfX3J0Ojp0aHJvd19udWxsOjpoM2Q3Yj\
Q3NDgzNGRkZjJkOW8yd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aGU1Njk3Y2E4ZTIx\
ZWQ1YTVwKndhc21fYmluZGdlbjo6dGhyb3dfc3RyOjpoNWViNDYxODBmZTVlMWQxYXFJc3RkOjpzeX\
NfY29tbW9uOjpiYWNrdHJhY2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoYTAzYWJlZjAy\
YThiNzBmZHIxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoYTBjNDQ5MjIxNmQ0ZDJlN3\
MKcnVzdF9wYW5pY3Q3c3RkOjphbGxvYzo6ZGVmYXVsdF9hbGxvY19lcnJvcl9ob29rOjpoZjljMzkz\
YmEzY2QyODdlMXVvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZjb3JlOjppdGVyOjphZGFwdGVycz\
o6Y29waWVkOjpDb3BpZWQ8Y29yZTo6c2xpY2U6Oml0ZXI6Okl0ZXI8dTg+Pj46Omg2M2MyZTE0OTdi\
NTJmM2Q3AO+AgIAACXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdG\
MdMS41Ny4wIChmMWVkZDA0MjkgMjAyMS0xMS0yOSkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4G\
MC4yLjgx\
");
    const wasmModule = new WebAssembly.Module(wasmBytes);
    return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function _uint8ArrayToBuffer(chunk) {
    return Buffer1.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
_arch();
Deno.chdir;
Deno.cwd;
const nextTick1 = nextTick;
const OBJECT_PROTO_PROP_NAMES = Object.getOwnPropertyNames(Object.prototype);
new Proxy(Object(), {
    get: (target, prop)=>{
        if (typeof prop === "symbol") {
            return target[prop];
        }
        const envValue = Deno.env.get(prop);
        if (envValue) {
            return envValue;
        }
        if (OBJECT_PROTO_PROP_NAMES.includes(prop)) {
            return target[prop];
        }
        return envValue;
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject()),
    getOwnPropertyDescriptor: (_target, name)=>{
        const e = Deno.env.toObject();
        if (name in Deno.env.toObject()) {
            const o = {
                enumerable: true,
                configurable: true
            };
            if (typeof name === "string") {
                o.value = e[name];
            }
            return o;
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return value;
    },
    has: (_target, prop)=>Reflect.ownKeys(Deno.env.toObject()).includes(prop)
});
Deno.pid;
isWindows1 ? "win32" : Deno.build.os;
({
    node: "16.11.1",
    uv: "1.42.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.17.2",
    modules: "93",
    nghttp2: "1.45.1",
    napi: "8",
    llhttp: "6.0.4",
    openssl: "1.1.1l",
    cldr: "39.0",
    icu: "69.1",
    tz: "2021a",
    unicode: "13.0",
    ...Deno.version
});
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
const validateAbortSignal1 = (signal, name)=>{
    if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
};
function isStream(obj) {
    return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal(signal, stream) {
    validateAbortSignal1(signal, "signal");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
    }
    const onAbort = ()=>{
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, ()=>signal.removeEventListener("abort", onAbort));
    }
    return stream;
}
const kDestroy = Symbol("kDestroy");
const kConstruct = Symbol("kConstruct");
function checkError(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy1(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }
    return this;
}
function _destroy(self1, err, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self1._readableState;
        const w = self1._writableState;
        checkError(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick(emitErrorCloseNT, self1, err);
        } else {
            nextTick(emitCloseNT, self1);
        }
    }
    try {
        const result = self1._destroy(err || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick(onDestroy, null);
                }, function(err) {
                    nextTick(onDestroy, err);
                });
            }
        }
    } catch (err1) {
        onDestroy(err1);
    }
}
function emitErrorCloseNT(self1, err) {
    emitErrorNT(self1, err);
    emitCloseNT(self1);
}
function emitCloseNT(self1) {
    const r = self1._readableState;
    const w = self1._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self1.emit("close");
    }
}
function emitErrorNT(self1, err) {
    const r = self1._readableState;
    const w = self1._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self1.emit("error", err);
}
function undestroy() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = false;
        r.endEmitted = false;
    }
    if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.ended = false;
        w.ending = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.finished = false;
    }
}
function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w && w.destroyed || r && r.destroyed) {
        return this;
    }
    if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err);
    } else if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}
function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
        return;
    }
    const r = stream._readableState;
    const w = stream._writableState;
    if (r) {
        r.constructed = false;
    }
    if (w) {
        w.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
        return;
    }
    nextTick(constructNT, stream);
}
function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
        if (called) {
            errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
            r.constructed = true;
        }
        if (w) {
            w.constructed = true;
        }
        if (s.destroyed) {
            stream.emit(kDestroy, err);
        } else if (err) {
            errorOrDestroy(stream, err, true);
        } else {
            nextTick(emitConstructNT, stream);
        }
    }
    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick(onConstruct, null);
                }, function(err) {
                    nextTick(onConstruct, err);
                });
            }
        }
    } catch (err) {
        onConstruct(err);
    }
}
function emitConstructNT(stream) {
    stream.emit(kConstruct);
}
function isRequest1(stream) {
    return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err) {
    if (!stream) return;
    if (isRequest1(stream)) return stream.abort();
    if (isRequest1(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === "function") return stream.destroy(err);
    if (typeof stream.close === "function") return stream.close();
}
const __default1 = {
    construct,
    destroyer,
    destroy: destroy1,
    undestroy,
    errorOrDestroy
};
const kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isIterable(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === "function";
    if (isAsync === false) return typeof obj[Symbol.iterator] === "function";
    return typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableEnded1(stream) {
    if (!isReadableNodeStream(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== "boolean") return null;
    return rState.ended;
}
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
    return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable1(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}
const stdio = {};
function isBlob(object) {
    return object instanceof Blob;
}
function _from1(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer1) {
        return new Readable({
            objectMode: true,
            ...opts,
            read () {
                this.push(iterable);
                this.push(null);
            }
        });
    }
    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", [
            "Iterable"
        ], iterable);
    }
    const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        ...opts
    });
    let reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    readable._destroy = function(error, cb) {
        close(error).then(()=>nextTick1(cb, error), (e)=>nextTick1(cb, e || error));
    };
    async function close(error) {
        const hadError = error !== undefined && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
            const { value , done  } = await iterator.throw(error);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === "function") {
            const { value: value1  } = await iterator.return();
            await value1;
        }
    }
    async function next() {
        for(;;){
            try {
                const { value , done  } = isAsync ? await iterator.next() : iterator.next();
                if (done) {
                    readable.push(null);
                } else {
                    const res = value && typeof value.then === "function" ? await value : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err) {
                readable.destroy(err);
            }
            break;
        }
    }
    return readable;
}
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    return getDefaultHighWaterMark(state.objectMode);
}
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once1;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
function checkListener(listener) {
    validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
EventEmitter.setMaxListeners = function(n = defaultMaxListeners, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n;
    } else {
        for(let i = 0; i < eventTargets.length; i++){
            const target = eventTargets[i];
            if (target instanceof EventTarget) {
                target[kMaxEventTargetListeners] = n;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
};
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr(ee, err, type, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err, type, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
    let doError = type === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events[type];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i = 0; i < len; ++i){
            const result1 = listeners[i].apply(this, args);
            if (result1 !== undefined && result1 !== null) {
                addCatch(this, result1, type, args);
            }
        }
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    let m;
    let events;
    let existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    const state = {
        fired: false,
        wrapFn: undefined,
        target,
        type,
        listener
    };
    const wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type];
            if (events.removeListener) {
                this.emit("removeListener", type, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                position = i;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne(list, position);
        }
        if (list.length === 1) {
            events[type] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type];
    if (typeof listeners === "function") {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        for(let i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
    }
    return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret = arrayClone(arr);
    for(let i = 0; i < ret.length; ++i){
        const orig = ret[i].listener;
        if (typeof orig === "function") {
            ret[i] = orig;
        }
    }
    return ret;
}
function getEventListeners(emitterOrTarget, type) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type);
    }
    if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once1(emitter, name, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve(args);
        };
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error = null;
    let finished = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error) {
                const p = Promise.reject(error);
                error = null;
                return p;
            }
            if (finished) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve, reject) {
                unconsumedPromises.push({
                    resolve,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
            }
            error = err;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error = err;
        }
        iterator.return();
    }
}
function Stream(opts) {
    EventEmitter.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, "error") === 0) {
            this.emit("error", er);
        }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
};
function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
    }
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [
            fn,
            emitter._events[event]
        ];
    }
}
var NotImplemented;
(function(NotImplemented) {
    NotImplemented[NotImplemented["ascii"] = 0] = "ascii";
    NotImplemented[NotImplemented["latin1"] = 1] = "latin1";
    NotImplemented[NotImplemented["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding3(enc) {
    const encoding = normalizeEncoding2(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented1(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function utf8CheckByte(__byte) {
    if (__byte <= 0x7f) return 0;
    else if (__byte >> 5 === 0x06) return 2;
    else if (__byte >> 4 === 0x0e) return 3;
    else if (__byte >> 3 === 0x1e) return 4;
    return __byte >> 6 === 0x02 ? -1 : -2;
}
function utf8CheckIncomplete(self1, buf, i) {
    let j = buf.length - 1;
    if (j < i) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self1.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self1.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self1.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self1, buf) {
    if ((buf[0] & 0xc0) !== 0x80) {
        self1.lastNeed = 0;
        return "\ufffd";
    }
    if (self1.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xc0) !== 0x80) {
            self1.lastNeed = 1;
            return "\ufffd";
        }
        if (self1.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xc0) !== 0x80) {
                self1.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
    const total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
function utf8End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
}
function base64Text(buf, i) {
    const n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    lastChar;
    lastNeed;
    lastTotal;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer1.allocUnsafe(nb);
    }
    encoding;
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding3(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding3(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding3(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        let decoder;
        switch(encoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
class BufferList {
    constructor(){
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(v) {
        const entry = {
            data: v,
            next: null
        };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }
    unshift(v) {
        const entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }
    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    join(s) {
        if (this.length === 0) {
            return "";
        }
        let p = this.head;
        let ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    }
    concat(n) {
        if (this.length === 0) {
            return Buffer1.alloc(0);
        }
        const ret = Buffer1.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while(p){
            ret.set(p.data, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    }
    consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
            const slice = data.slice(0, n);
            this.head.data = data.slice(n);
            return slice;
        }
        if (n === data.length) {
            return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
        return this.head.data;
    }
    *[Symbol.iterator]() {
        for(let p = this.head; p; p = p.next){
            yield p.data;
        }
    }
    _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
            const str = p.data;
            if (n > str.length) {
                ret += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret += str;
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n);
                    this.head = p;
                    p.data = str.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    _getBuffer(n) {
        const ret = Buffer1.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
            const buf = p.data;
            if (n > buf.length) {
                ret.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret.set(buf, retLen - n);
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
                    this.head = p;
                    p.data = buf.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    [inspect.custom](_, options) {
        return inspect(this, {
            ...options,
            depth: 0,
            customInspect: false
        });
    }
}
let debug = debuglog("stream", (fn)=>{
    debug = fn;
});
const kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
const nop1 = ()=>{};
const { errorOrDestroy: errorOrDestroy1  } = __default1;
function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = stream instanceof Stream.Duplex;
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.constructed = true;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused] = null;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.destroyed = false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;
    this.readingMore = false;
    this.dataEmitted = false;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    if (!(this instanceof Readable)) {
        return new Readable(options);
    }
    const isDuplex = this instanceof Stream.Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
        if (typeof options.read === "function") {
            this._read = options.read;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default1.construct(this, ()=>{
        if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
        }
    });
}
Readable.prototype.destroy = __default1.destroy;
Readable.prototype._undestroy = __default1.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
Readable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state = stream._readableState;
    let err;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (state.encoding !== encoding) {
                if (addToFront && state.encoding) {
                    chunk = Buffer1.from(chunk, encoding).toString(state.encoding);
                } else {
                    chunk = Buffer1.from(chunk, encoding);
                    encoding = "";
                }
            }
        } else if (chunk instanceof Buffer1) {
            encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "";
        } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    if (err) {
        errorOrDestroy1(stream, err);
    } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
            if (state.endEmitted) {
                errorOrDestroy1(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            } else {
                addChunk(stream, state, chunk, true);
            }
        } else if (state.ended) {
            errorOrDestroy1(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
            return false;
        } else {
            state.reading = false;
            if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) {
                    addChunk(stream, state, chunk, false);
                } else {
                    maybeReadMore(stream, state);
                }
            } else {
                addChunk(stream, state, chunk, false);
            }
        }
    } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
    } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state.buffer.unshift(chunk);
        } else {
            state.buffer.push(chunk);
        }
        if (state.needReadable) {
            emitReadable(stream);
        }
    }
    maybeReadMore(stream, state);
}
Readable.prototype.isPaused = function() {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer = this._readableState.buffer;
    let content = "";
    for (const data of buffer){
        content += decoder.write(data);
    }
    buffer.clear();
    if (content !== "") {
        buffer.push(content);
    }
    this._readableState.length = content.length;
    return this;
};
const MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= 0x40000000) {
        n = MAX_HWM;
    } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) {
        return 0;
    }
    if (state.objectMode) {
        return 1;
    }
    if (Number.isNaN(n)) {
        if (state.flowing && state.length) {
            return state.buffer.first().length;
        }
        return state.length;
    }
    if (n <= state.length) {
        return n;
    }
    return state.ended ? state.length : 0;
}
Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
        n = NaN;
    } else if (!Number.isInteger(n)) {
        n = Number.parseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;
    if (n > state.highWaterMark) {
        state.highWaterMark = computeNewHighWaterMark(n);
    }
    if (n !== 0) {
        state.emittedReadable = false;
    }
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) {
            endReadable(this);
        } else {
            emitReadable(this);
        }
        return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
        if (state.length === 0) {
            endReadable(this);
        }
        return null;
    }
    let doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) {
            state.needReadable = true;
        }
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) {
            n = howMuchToRead(nOrig, state);
        }
    }
    let ret;
    if (n > 0) {
        ret = fromList(n, state);
    } else {
        ret = null;
    }
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
    }
    if (state.length === 0) {
        if (!state.ended) {
            state.needReadable = true;
        }
        if (nOrig !== n && state.ended) {
            endReadable(this);
        }
    }
    if (ret !== null) {
        state.dataEmitted = true;
        this.emit("data", ret);
    }
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) {
        emitReadable(stream);
    } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
    }
}
function emitReadable(stream) {
    const state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    const state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) {
            break;
        }
    }
    state.readingMore = false;
}
Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state = this._readableState;
    if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
            state.multiAwaitDrain = true;
            state.awaitDrainWriters = new Set(state.awaitDrainWriters ? [
                state.awaitDrainWriters
            ] : []);
        }
    }
    state.pipes.push(dest);
    debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) {
        nextTick(endFn);
    } else {
        src.once("end", endFn);
    }
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
            dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
            ondrain();
        }
    }
    function pause() {
        if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest) {
                debug("false write response, pause", 0);
                state.awaitDrainWriters = dest;
                state.multiAwaitDrain = false;
            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
                debug("false write response, pause", state.awaitDrainWriters.size);
                state.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            ondrain = pipeOnDrain(src, dest);
            dest.on("drain", ondrain);
        }
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            pause();
        }
    }
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EventEmitter.listenerCount(dest, "error") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
                errorOrDestroy1(dest, er);
            } else {
                dest.emit("error", er);
            }
        }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
        if (state.flowing) {
            pause();
        }
    } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
            debug("pipeOnDrain", 1);
            state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
            debug("pipeOnDrain", state.awaitDrainWriters.size);
            state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && EventEmitter.listenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    const state = this._readableState;
    const unpipeInfo = {
        hasUnpiped: false
    };
    if (state.pipes.length === 0) {
        return this;
    }
    if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for(let i = 0; i < dests.length; i++){
            dests[i].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    const index = state.pipes.indexOf(dest);
    if (index === -1) {
        return this;
    }
    state.pipes.splice(index, 1);
    if (state.pipes.length === 0) {
        this.pause();
    }
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;
    if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) {
            this.resume();
        }
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            } else if (!state.reading) {
                nextTick(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        nextTick(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        nextTick(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self1) {
    const state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
    } else if (self1.listenerCount("data") > 0) {
        self1.resume();
    } else if (!state.readableListening) {
        state.flowing = null;
    }
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
Readable.prototype.resume = function() {
    const state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state[kPaused] = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
        stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) {
        stream.read(0);
    }
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
};
function flow(stream) {
    const state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk)=>{
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });
    stream.on("end", ()=>{
        this.push(null);
    });
    stream.on("error", (err)=>{
        errorOrDestroy1(this, err);
    });
    stream.on("close", ()=>{
        this.destroy();
    });
    stream.on("destroy", ()=>{
        this.destroy();
    });
    this._read = ()=>{
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };
    const streamKeys = Object.keys(stream);
    for(let j = 1; j < streamKeys.length; j++){
        const i = streamKeys[j];
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = stream[i].bind(stream);
        }
    }
    return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
    return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
        validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
            objectMode: true
        });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
}
async function* createAsyncIterator(stream, options) {
    let callback = nop1;
    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options
    };
    function next(resolve) {
        if (this === stream) {
            callback();
            callback = nop1;
        } else {
            callback = resolve;
        }
    }
    const state = stream._readableState;
    let error = state.errored;
    let errorEmitted = state.errorEmitted;
    let endEmitted = state.endEmitted;
    let closeEmitted = state.closeEmitted;
    stream.on("readable", next).on("error", function(err) {
        error = err;
        errorEmitted = true;
        next.call(this);
    }).on("end", function() {
        endEmitted = true;
        next.call(this);
    }).on("close", function() {
        closeEmitted = true;
        next.call(this);
    });
    let errorThrown = false;
    try {
        while(true){
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err) {
        if (opts.destroyOnError) {
            __default1.destroyer(stream, err);
        }
        errorThrown = true;
        throw err;
    } finally{
        if (!errorThrown && opts.destroyOnReturn) {
            if (state.autoDestroy || !endEmitted) {
                __default1.destroyer(stream, null);
            }
        }
    }
}
Object.defineProperties(Readable.prototype, {
    readable: {
        get () {
            const r = this._readableState;
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set (val) {
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        }
    },
    readableDidRead: {
        enumerable: false,
        get: function() {
            return this._readableState.dataEmitted;
        }
    },
    readableAborted: {
        enumerable: false,
        get: function() {
            return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
        }
    },
    readableHighWaterMark: {
        enumerable: false,
        get: function() {
            return this._readableState.highWaterMark;
        }
    },
    readableBuffer: {
        enumerable: false,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    },
    readableFlowing: {
        enumerable: false,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(state) {
            if (this._readableState) {
                this._readableState.flowing = state;
            }
        }
    },
    readableLength: {
        enumerable: false,
        get () {
            return this._readableState.length;
        }
    },
    readableObjectMode: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.objectMode : false;
        }
    },
    readableEncoding: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.encoding : null;
        }
    },
    destroyed: {
        enumerable: false,
        get () {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set (value) {
            if (!this._readableState) {
                return;
            }
            this._readableState.destroyed = value;
        }
    },
    readableEnded: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.endEmitted : false;
        }
    }
});
Object.defineProperties(ReadableState.prototype, {
    pipesCount: {
        get () {
            return this.pipes.length;
        }
    },
    paused: {
        get () {
            return this[kPaused] !== false;
        },
        set (value) {
            this[kPaused] = !!value;
        }
    }
});
function fromList(n, state) {
    if (state.length === 0) {
        return null;
    }
    let ret;
    if (state.objectMode) {
        ret = state.buffer.shift();
    } else if (!n || n >= state.length) {
        if (state.decoder) {
            ret = state.buffer.join("");
        } else if (state.buffer.length === 1) {
            ret = state.buffer.first();
        } else {
            ret = state.buffer.concat(state.length);
        }
        state.buffer.clear();
    } else {
        ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
}
function endReadable(stream) {
    const state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
            const wState = stream._writableState;
            const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}
function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
        stream.end();
    }
}
function readableFrom(iterable, opts) {
    return _from1(Readable, iterable, opts);
}
function isReadableStream(object) {
    return object instanceof ReadableStream;
}
Readable.fromWeb = function(readableStream, options = {}) {
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("readableStream", "ReadableStream", readableStream);
    }
    validateObject(options, "options");
    const { highWaterMark , encoding , objectMode =false , signal ,  } = options;
    if (encoding !== undefined && !Buffer1.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    validateBoolean(objectMode, "options.objectMode");
    const reader = readableStream.getReader();
    let closed = false;
    const readable = new Readable({
        objectMode,
        highWaterMark,
        encoding,
        signal,
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    readable.push(null);
                } else {
                    readable.push(chunk.value);
                }
            }, (error)=>destroy.call(readable, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error1) {
                    process.nextTick(()=>{
                        throw error1;
                    });
                }
            }
            if (!closed) {
                reader.cancel(error).then(done, done);
                return;
            }
            done();
        }
    });
    reader.closed.then(()=>{
        closed = true;
        if (!isReadableEnded1(readable)) {
            readable.push(null);
        }
    }, (error)=>{
        closed = true;
        destroy.call(readable, error);
    });
    return readable;
};
function wrap(src, options) {
    return new Readable({
        objectMode: (src.readableObjectMode ?? src.objectMode) ?? true,
        ...options,
        destroy (err, callback) {
            __default1.destroyer(src, err);
            callback(err);
        }
    }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
const { errorOrDestroy: errorOrDestroy2  } = __default1;
function isDuplexStream(maybe_duplex) {
    const isReadable = Readable.prototype.isPrototypeOf(maybe_duplex);
    let prototype = maybe_duplex;
    let isDuplex = false;
    while(prototype?.constructor && prototype.constructor.name !== "Object"){
        if (prototype.constructor.name === "Duplex") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }
    return isReadable && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop2() {}
const kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = isDuplexStream(stream);
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
}
function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
    get () {
        return this.buffered.length - this.bufferedIndex;
    }
});
function Writable(options) {
    const isDuplex = isDuplexStream(this);
    if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
        if (typeof options.write === "function") {
            this._write = options.write;
        }
        if (typeof options.writev === "function") {
            this._writev = options.writev;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.final === "function") {
            this._final = options.final;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default1.construct(this, ()=>{
        const state = this._writableState;
        if (!state.writing) {
            clearBuffer(this, state);
        }
        finishMaybe(this, state);
    });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
    }
});
Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state.defaultEncoding;
        } else if (encoding !== "buffer" && !Buffer1.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING(encoding);
        }
        if (typeof cb !== "function") {
            cb = nop2;
        }
    }
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (!state.objectMode) {
        if (typeof chunk === "string") {
            if (state.decodeStrings !== false) {
                chunk = Buffer1.from(chunk, encoding);
                encoding = "buffer";
            }
        } else if (chunk instanceof Buffer1) {
            encoding = "buffer";
        } else if (isUint8Array(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
            encoding = "buffer";
        } else {
            throw new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    let err;
    if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
        nextTick(cb, err);
        errorOrDestroy2(stream, err, true);
        return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    const state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing) {
            clearBuffer(this, state);
        }
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};
function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    const ret = state.length < state.highWaterMark;
    if (!ret) {
        state.needDrain = true;
    }
    if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
            chunk,
            encoding,
            callback
        });
        if (state.allBuffers && encoding !== "buffer") {
            state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop2) {
            state.allNoop = false;
        }
    } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
    }
    return ret && !state.errored && !state.destroyed;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) {
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
    } else if (writev) {
        stream._writev(chunk, state.onwrite);
    } else {
        stream._write(chunk, encoding, state.onwrite);
    }
    state.sync = false;
}
function onwriteError(stream, state, er, cb) {
    --state.pendingcb;
    cb(er);
    errorBuffer(state);
    errorOrDestroy2(stream, er);
}
function onwrite(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;
    if (typeof cb !== "function") {
        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK());
        return;
    }
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
    if (er) {
        er.stack;
        if (!state.errored) {
            state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }
        if (sync) {
            nextTick(onwriteError, stream, state, er, cb);
        } else {
            onwriteError(stream, state, er, cb);
        }
    } else {
        if (state.buffered.length > state.bufferedIndex) {
            clearBuffer(stream, state);
        }
        if (sync) {
            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
                state.afterWriteTickInfo.count++;
            } else {
                state.afterWriteTickInfo = {
                    count: 1,
                    cb,
                    stream,
                    state
                };
                nextTick(afterWriteTick, state.afterWriteTickInfo);
            }
        } else {
            afterWrite(stream, state, 1, cb);
        }
    }
}
function afterWriteTick({ stream , state , count , cb  }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
}
function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
    if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
    while(count-- > 0){
        state.pendingcb--;
        cb();
    }
    if (state.destroyed) {
        errorBuffer(state);
    }
    finishMaybe(stream, state);
}
function errorBuffer(state) {
    if (state.writing) {
        return;
    }
    for(let n = state.bufferedIndex; n < state.buffered.length; ++n){
        const { chunk , callback  } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for(let i = 0; i < onfinishCallbacks.length; i++){
        onfinishCallbacks[i](new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state);
}
function clearBuffer(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
    }
    const { buffered , bufferedIndex , objectMode  } = state;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
        return;
    }
    let i = bufferedIndex;
    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop2 : (err)=>{
            for(let n = i; n < buffered.length; ++n){
                buffered[n].callback(err);
            }
        };
        const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
    } else {
        do {
            const { chunk , encoding , callback: callback1  } = buffered[i];
            buffered[i++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, callback1);
        }while (i < buffered.length && !state.writing)
        if (i === buffered.length) {
            resetBuffer(state);
        } else if (i > 256) {
            buffered.splice(0, i);
            state.bufferedIndex = 0;
        } else {
            state.bufferedIndex = i;
        }
    }
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
        this._writev([
            {
                chunk,
                encoding
            }
        ], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    const state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error) {
            err = ret;
        }
    }
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    if (err) {} else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
    } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
        if (err || state.finished) {
            nextTick1(cb, err);
        } else {
            state[kOnFinished].push(cb);
        }
    }
    return this;
};
function needFinish(state) {
    return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal(stream, state) {
    let called = false;
    function onFinish(err) {
        if (called) {
            errorOrDestroy2(stream, err ?? ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
            const onfinishCallbacks = state[kOnFinished].splice(0);
            for(let i = 0; i < onfinishCallbacks.length; i++){
                onfinishCallbacks[i](err);
            }
            errorOrDestroy2(stream, err, state.sync);
        } else if (needFinish(state)) {
            state.prefinished = true;
            stream.emit("prefinish");
            state.pendingcb++;
            nextTick(finish, stream, state);
        }
    }
    state.sync = true;
    state.pendingcb++;
    try {
        const result = stream._final(onFinish);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick(onFinish, null);
                }, function(err) {
                    nextTick(onFinish, err);
                });
            }
        }
    } catch (err) {
        onFinish(stream, state, err);
    }
    state.sync = false;
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.finalCalled = true;
            callFinal(stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0 && needFinish(state)) {
            state.pendingcb++;
            if (sync) {
                nextTick(finish, stream, state);
            } else {
                finish(stream, state);
            }
        }
    }
}
function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for(let i = 0; i < onfinishCallbacks.length; i++){
        onfinishCallbacks[i]();
    }
    stream.emit("finish");
    if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
            stream.destroy();
        }
    }
}
Object.defineProperties(Writable.prototype, {
    destroyed: {
        get () {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set (value) {
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        }
    },
    writable: {
        get () {
            const w = this._writableState;
            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set (val) {
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        }
    },
    writableFinished: {
        get () {
            return this._writableState ? this._writableState.finished : false;
        }
    },
    writableObjectMode: {
        get () {
            return this._writableState ? this._writableState.objectMode : false;
        }
    },
    writableBuffer: {
        get () {
            return this._writableState && this._writableState.getBuffer();
        }
    },
    writableEnded: {
        get () {
            return this._writableState ? this._writableState.ending : false;
        }
    },
    writableNeedDrain: {
        get () {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        }
    },
    writableHighWaterMark: {
        get () {
            return this._writableState && this._writableState.highWaterMark;
        }
    },
    writableCorked: {
        get () {
            return this._writableState ? this._writableState.corked : 0;
        }
    },
    writableLength: {
        get () {
            return this._writableState && this._writableState.length;
        }
    }
});
const destroy2 = __default1.destroy;
Writable.prototype.destroy = function(err, cb) {
    const state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        nextTick1(errorBuffer, state);
    }
    destroy2.call(this, err, cb);
    return this;
};
Writable.prototype._undestroy = __default1.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};
Writable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Writable.WritableState = WritableState;
function isWritableStream(object) {
    return object instanceof WritableStream;
}
Writable.fromWeb = function(writableStream, options = {}) {
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("writableStream", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { highWaterMark , decodeStrings =true , objectMode =false , signal ,  } = options;
    validateBoolean(objectMode, "options.objectMode");
    validateBoolean(decodeStrings, "options.decodeStrings");
    const writer = writableStream.getWriter();
    let closed = false;
    const writable = new Writable({
        highWaterMark,
        objectMode,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error1) {
                    nextTick1(()=>destroy2.call(writable, error1));
                }
            }
            writer.ready.then(()=>Promise.All(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer1.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    destroy2(this, duplex, error1);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error1) {
                    nextTick1(()=>{
                        throw error1;
                    });
                }
            }
            if (!closed) {
                if (error != null) {
                    writer.abort(error).then(done, done);
                } else {
                    writer.close().then(done, done);
                }
                return;
            }
            done();
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    nextTick1(()=>destroy2.call(writable, error1));
                }
            }
            if (!closed) {
                writer.close().then(done, done);
            }
        }
    });
    writer.closed.then(()=>{
        closed = true;
        if (!isWritableEnded(writable)) {
            destroy2.call(writable, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        closed = true;
        destroy2.call(writable, error);
    });
    return writable;
};
Writable.Writable = Writable;
Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);
{
    for (const method of Object.keys(Writable.prototype)){
        if (!Duplex.prototype[method]) {
            Duplex.prototype[method] = Writable.prototype[method];
        }
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) {
        return new Duplex(options);
    }
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }
        if (options.writable === false) {
            this.writable = false;
        }
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}
Object.defineProperties(Duplex.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable.prototype, "writable"),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
    writableObjectMode: Object.getOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
    writableBuffer: Object.getOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
    writableLength: Object.getOwnPropertyDescriptor(Writable.prototype, "writableLength"),
    writableFinished: Object.getOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
    writableCorked: Object.getOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
    writableEnded: Object.getOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
    writableNeedDrain: Object.getOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
    destroyed: {
        get () {
            if (this._readableState === undefined || this._writableState === undefined) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set (value) {
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        }
    }
});
function isReadableStream1(object) {
    return object instanceof ReadableStream;
}
function isWritableStream1(object) {
    return object instanceof WritableStream;
}
Duplex.fromWeb = function(pair, options) {
    validateObject(pair, "pair");
    const { readable: readableStream , writable: writableStream ,  } = pair;
    if (!isReadableStream1(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
    }
    if (!isWritableStream1(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { allowHalfOpen =false , objectMode =false , encoding , decodeStrings =true , highWaterMark , signal ,  } = options;
    validateBoolean(objectMode, "options.objectMode");
    if (encoding !== undefined && !Buffer1.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    const writer = writableStream.getWriter();
    const reader = readableStream.getReader();
    let writableClosed = false;
    let readableClosed = false;
    const duplex1 = new Duplex({
        allowHalfOpen,
        highWaterMark,
        objectMode,
        encoding,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error1) {
                    nextTick1(()=>destroy(duplex1, error1));
                }
            }
            writer.ready.then(()=>Promise.All(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer1.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    destroy(duplex1, error1);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    nextTick1(()=>destroy(duplex1, error1));
                }
            }
            if (!writableClosed) {
                writer.close().then(done, done);
            }
        },
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    duplex1.push(null);
                } else {
                    duplex1.push(chunk.value);
                }
            }, (error)=>destroy(duplex1, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error1) {
                    nextTick1(()=>{
                        throw error1;
                    });
                }
            }
            async function closeWriter() {
                if (!writableClosed) {
                    await writer.abort(error);
                }
            }
            async function closeReader() {
                if (!readableClosed) {
                    await reader.cancel(error);
                }
            }
            if (!writableClosed || !readableClosed) {
                Promise.All([
                    closeWriter(),
                    closeReader(), 
                ]).then(done, done);
                return;
            }
            done();
        }
    });
    writer.closed.then(()=>{
        writableClosed = true;
        if (!isWritableEnded(duplex1)) {
            destroy(duplex1, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex1, error);
    });
    reader.closed.then(()=>{
        readableClosed = true;
        if (!isReadableEnded1(duplex1)) {
            duplex1.push(null);
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex1, error);
    });
    return duplex1;
};
class Duplexify extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function duplexify(body, name) {
    if (isDuplexNodeStream(body)) {
        return body;
    }
    if (isReadableNodeStream(body)) {
        return _duplexify({
            readable: body
        });
    }
    if (isWritableNodeStream(body)) {
        return _duplexify({
            writable: body
        });
    }
    if (isNodeStream(body)) {
        return _duplexify({
            writable: false,
            readable: false
        });
    }
    if (typeof body === "function") {
        const { value , write , final: __final , destroy: destroy1  } = fromAsyncGen(body);
        if (isIterable(value)) {
            return _from1(Duplexify, value, {
                objectMode: true,
                write,
                final: __final,
                destroy: destroy1
            });
        }
        const then = value?.then;
        if (typeof then === "function") {
            let d;
            const promise = then.call(value, (val)=>{
                if (val != null) {
                    throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
                }
            }, (err)=>{
                destroyer(d, err);
            });
            return d = new Duplexify({
                objectMode: true,
                readable: false,
                write,
                final (cb) {
                    __final(async ()=>{
                        try {
                            await promise;
                            nextTick1(cb, null);
                        } catch (err) {
                            nextTick1(cb, err);
                        }
                    });
                },
                destroy: destroy1
            });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
        return _from1(Duplexify, body, {
            objectMode: true,
            writable: false
        });
    }
    if (typeof body?.writable === "object" || typeof body?.readable === "object") {
        const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : undefined;
        const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : undefined;
        return _duplexify({
            readable,
            writable
        });
    }
    const then1 = body?.then;
    if (typeof then1 === "function") {
        let d1;
        then1.call(body, (val)=>{
            if (val != null) {
                d1.push(val);
            }
            d1.push(null);
        }, (err)=>{
            destroyer(d1, err);
        });
        return d1 = new Duplexify({
            objectMode: true,
            writable: false,
            read () {}
        });
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise", 
    ], body);
}
function fromAsyncGen(fn) {
    let { promise , resolve  } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(async function*() {
        while(true){
            const _promise = promise;
            promise = null;
            const { chunk , done , cb  } = await _promise;
            nextTick(cb);
            if (done) return;
            if (signal.aborted) throw new AbortError();
            ({ promise , resolve  } = createDeferredPromise());
            yield chunk;
        }
    }(), {
        signal
    });
    return {
        value,
        write (chunk, encoding, cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({
                chunk,
                done: false,
                cb
            });
        },
        final (cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({
                done: true,
                cb
            });
        },
        destroy (err, cb) {
            ac.abort();
            cb(err);
        }
    };
}
function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w = pair.writable;
    let readable = !!isReadable1(r);
    let writable = !!isWritable1(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    d = new Duplexify({
        readableObjectMode: !!r?.readableObjectMode,
        writableObjectMode: !!w?.writableObjectMode,
        readable,
        writable
    });
    if (writable) {
        eos(w, (err)=>{
            writable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            w.end();
            onfinish = callback;
        };
        w.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        w.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        eos(r, (err)=>{
            readable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        r.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        r.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = r.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(w, err);
            destroyer(r, err);
        }
    };
    return d;
}
function duplexFrom(body) {
    return duplexify(body, "body");
}
Duplex.from = duplexFrom;
Duplex.duplexify = duplexify;
Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);
const kCallback = Symbol("kCallback");
function Transform(options) {
    if (!(this instanceof Transform)) {
        return new Transform(options);
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
        if (typeof options.transform === "function") {
            this._transform = options.transform;
        }
        if (typeof options.flush === "function") {
            this._flush = options.flush;
        }
    }
    this.on("prefinish", prefinish1);
}
function __final(cb) {
    let called = false;
    if (typeof this._flush === "function" && !this.destroyed) {
        const result = this._flush((er, data)=>{
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }
            if (data != null) {
                this.push(data);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === "function") {
                    then.call(result, (data)=>{
                        if (called) {
                            return;
                        }
                        if (data != null) {
                            this.push(data);
                        }
                        this.push(null);
                        if (cb) {
                            nextTick(cb);
                        }
                    }, (err)=>{
                        if (cb) {
                            nextTick(cb, err);
                        } else {
                            nextTick(()=>this.destroy(err));
                        }
                    });
                }
            } catch (err) {
                nextTick(()=>this.destroy(err));
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}
function prefinish1() {
    if (this._final !== __final) {
        __final.call(this);
    }
}
Transform.prototype._final = __final;
Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    let called = false;
    const result = this._transform(chunk, encoding, (err, val)=>{
        called = true;
        if (err) {
            callback(err);
            return;
        }
        if (val != null) {
            this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            callback();
        } else {
            this[kCallback] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, (val)=>{
                    if (called) {
                        return;
                    }
                    if (val != null) {
                        this.push(val);
                    }
                    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
                        nextTick1(callback);
                    } else {
                        this[kCallback] = callback;
                    }
                }, (err)=>{
                    nextTick1(callback, err);
                });
            }
        } catch (err) {
            nextTick1(callback, err);
        }
    }
};
Transform.prototype._read = function() {
    if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
    }
};
Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) {
        return new PassThrough(options);
    }
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};
function destroyer1(stream, reading, writing, callback) {
    callback = once(callback);
    let finished = false;
    stream.on("close", ()=>{
        finished = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, (err)=>{
        finished = !err;
        const rState = stream._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            stream.once("end", callback).once("error", callback);
        } else {
            callback(err);
        }
    });
    return (err)=>{
        if (finished) return;
        finished = true;
        __default1.destroyer(stream, err);
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function popCallback(streams) {
    validateCallback(streams[streams.length - 1]);
    return streams.pop();
}
function makeAsyncIterable(val) {
    if (isIterable(val)) {
        return val;
    } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE("val", [
        "Readable",
        "Iterable",
        "AsyncIterable"
    ], val);
}
async function* fromReadable(val) {
    yield* Readable.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish) {
    let error;
    let onresolve = null;
    const resume = (err)=>{
        if (err) {
            error = err;
        }
        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };
    const wait = ()=>new Promise((resolve, reject)=>{
            if (error) {
                reject(error);
            } else {
                onresolve = ()=>{
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                };
            }
        });
    writable.on("drain", resume);
    const cleanup = eos(writable, {
        readable: false
    }, resume);
    try {
        if (writable.writableNeedDrain) {
            await wait();
        }
        for await (const chunk of iterable){
            if (!writable.write(chunk)) {
                await wait();
            }
        }
        writable.end();
        await wait();
        finish();
    } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally{
        cleanup();
        writable.off("drain", resume);
    }
}
function pipeline(...streams) {
    const callback = once(popCallback(streams));
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }
    return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
        finishImpl(new AbortError());
    }
    outerSignal?.addEventListener("abort", abort);
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish(err) {
        finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, __final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error = err;
        }
        if (!error && !__final) {
            return;
        }
        while(destroys.length){
            destroys.shift()(error);
        }
        outerSignal?.removeEventListener("abort", abort);
        ac.abort();
        if (__final) {
            callback(error, value);
        }
    }
    let ret;
    for(let i = 0; i < streams.length; i++){
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        if (isNodeStream(stream)) {
            finishCount++;
            destroys.push(destroyer1(stream, reading, writing, finish));
        }
        if (i === 0) {
            if (typeof stream === "function") {
                ret = stream({
                    signal
                });
                if (!isIterable(ret)) {
                    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
                }
            } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                ret = stream;
            } else {
                ret = Duplex.from(stream);
            }
        } else if (typeof stream === "function") {
            ret = makeAsyncIterable(ret);
            ret = stream(ret, {
                signal
            });
            if (reading) {
                if (!isIterable(ret, true)) {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
                }
            } else {
                const pt = new PassThrough({
                    objectMode: true
                });
                const then = ret?.then;
                if (typeof then === "function") {
                    then.call(ret, (val)=>{
                        value = val;
                        pt.end(val);
                    }, (err)=>{
                        pt.destroy(err);
                    });
                } else if (isIterable(ret, true)) {
                    finishCount++;
                    pump(ret, pt, finish);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
                }
                ret = pt;
                finishCount++;
                destroys.push(destroyer1(ret, false, true, finish));
            }
        } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret)) {
                ret.pipe(stream);
                if (stream === stdio.stdout || stream === stdio.stderr) {
                    ret.on("end", ()=>stream.end());
                }
            } else {
                ret = makeAsyncIterable(ret);
                finishCount++;
                pump(ret, stream, finish);
            }
            ret = stream;
        } else {
            ret = Duplex.from(stream);
        }
    }
    if (signal?.aborted || outerSignal?.aborted) {
        nextTick(abort);
    }
    return ret;
}
class ComposeDuplex extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function compose1(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
        return Duplex.from(streams[0]);
    }
    const orgStreams = [
        ...streams
    ];
    if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
    }
    for(let n = 0; n < streams.length; ++n){
        if (!isNodeStream(streams[n])) {
            continue;
        }
        if (n < streams.length - 1 && !isReadable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !isWritable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!isWritable1(head);
    const readable = !!isReadable1(tail);
    d = new ComposeDuplex({
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable
    });
    if (writable) {
        d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            head.end();
            onfinish = callback;
        };
        head.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        tail.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        tail.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        tail.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = tail.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(tail, err);
        }
    };
    return d;
}
function pipeline1(...streams) {
    return new Promise((resolve, reject)=>{
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }
        pipelineImpl(streams, (err, value)=>{
            if (err) {
                reject(err);
            } else {
                resolve(value);
            }
        }, {
            signal,
            end
        });
    });
}
function finished(stream, opts) {
    return new Promise((resolve, reject)=>{
        eos(stream, opts, (err)=>{
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}
const __default2 = {
    finished,
    pipeline: pipeline1
};
const { custom: customPromisify  } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose1;
Object.defineProperty(Stream, "promises", {
    configurable: true,
    enumerable: true,
    get () {
        return __default2;
    }
});
Object.defineProperty(pipeline, customPromisify, {
    enumerable: true,
    get () {
        return __default2.pipeline;
    }
});
Object.defineProperty(eos, customPromisify, {
    enumerable: true,
    get () {
        return __default2.finished;
    }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
const hexTable1 = new TextEncoder().encode("0123456789abcdef");
function encode4(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i = 0; i < dst.length; i++){
        const v = src[i];
        dst[i * 2] = hexTable1[v >> 4];
        dst[i * 2 + 1] = hexTable1[v & 0x0f];
    }
    return dst;
}
const coerceToBytes = (data)=>{
    if (data instanceof Uint8Array) {
        return data;
    } else if (typeof data === "string") {
        return new TextEncoder().encode(data);
    } else if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    } else {
        throw new TypeError("expected data to be string | BufferSource");
    }
};
class Hash extends Transform {
    #context;
    constructor(algorithm, _opts){
        super({
            transform (chunk, _encoding, callback) {
                context.update(coerceToBytes(chunk));
                callback();
            },
            flush (callback) {
                this.push(context.digest(undefined));
                callback();
            }
        });
        if (typeof algorithm === "string") {
            algorithm = algorithm.toUpperCase();
            if (opensslToWebCryptoDigestNames[algorithm]) {
                algorithm = opensslToWebCryptoDigestNames[algorithm];
            }
            this.#context = new (instantiate()).DigestContext(algorithm);
        } else {
            this.#context = algorithm;
        }
        const context = this.#context;
    }
    copy() {
        return new Hash(this.#context.clone());
    }
    update(data, _encoding) {
        let bytes;
        if (typeof data === "string") {
            data = new TextEncoder().encode(data);
            bytes = coerceToBytes(data);
        } else {
            bytes = coerceToBytes(data);
        }
        this.#context.update(bytes);
        return this;
    }
    digest(encoding) {
        const digest = this.#context.digest(undefined);
        if (encoding === undefined) {
            return Buffer1.from(digest);
        }
        switch(encoding){
            case "hex":
                return new TextDecoder().decode(encode4(new Uint8Array(digest)));
            case "binary":
                return String.fromCharCode(...digest);
            case "base64":
                return encode2(digest);
            default:
                throw new Error(`The output encoding for hash digest is not implemented: ${encoding}`);
        }
    }
}
const opensslToWebCryptoDigestNames = {
    BLAKE2B512: "BLAKE2B",
    BLAKE2S256: "BLAKE2S",
    RIPEMD160: "RIPEMD-160",
    RMD160: "RIPEMD-160",
    SHA1: "SHA-1",
    SHA224: "SHA-224",
    SHA256: "SHA-256",
    SHA384: "SHA-384",
    SHA512: "SHA-512"
};
function createHash1(algorithm, opts) {
    return new Hash(algorithm, opts);
}
const MAX_ALLOC = Math.pow(2, 30) - 1;
const createHasher = (algorithm)=>(value)=>Buffer1.from(createHash1(algorithm).update(value).digest());
function getZeroes(zeros) {
    return Buffer1.alloc(zeros);
}
const sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
};
function toBuffer(bufferable) {
    if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
        return Buffer1.from(bufferable);
    } else {
        return Buffer1.from(bufferable.buffer);
    }
}
class Hmac {
    hash;
    ipad1;
    opad;
    alg;
    blocksize;
    size;
    ipad2;
    constructor(alg, key, saltLen){
        this.hash = createHasher(alg);
        const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
            key = this.hash(key);
        } else if (key.length < blocksize) {
            key = Buffer1.concat([
                key,
                getZeroes(blocksize - key.length)
            ], blocksize);
        }
        const ipad = Buffer1.allocUnsafe(blocksize + sizes[alg]);
        const opad = Buffer1.allocUnsafe(blocksize + sizes[alg]);
        for(let i = 0; i < blocksize; i++){
            ipad[i] = key[i] ^ 0x36;
            opad[i] = key[i] ^ 0x5c;
        }
        const ipad1 = Buffer1.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.size = sizes[alg];
    }
    run(data, ipad) {
        data.copy(ipad, this.blocksize);
        const h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
    }
}
function pbkdf2Sync(password, salt, iterations, keylen, digest = "sha1") {
    if (typeof iterations !== "number" || iterations < 0) {
        throw new TypeError("Bad iterations");
    }
    if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError("Bad key length");
    }
    const bufferedPassword = toBuffer(password);
    const bufferedSalt = toBuffer(salt);
    const hmac = new Hmac(digest, bufferedPassword, bufferedSalt.length);
    const DK = Buffer1.allocUnsafe(keylen);
    const block1 = Buffer1.allocUnsafe(bufferedSalt.length + 4);
    bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
    let destPos = 0;
    const hLen = sizes[digest];
    const l = Math.ceil(keylen / hLen);
    for(let i = 1; i <= l; i++){
        block1.writeUInt32BE(i, bufferedSalt.length);
        const T = hmac.run(block1, hmac.ipad1);
        let U = T;
        for(let j = 1; j < iterations; j++){
            U = hmac.run(U, hmac.ipad2);
            for(let k = 0; k < hLen; k++)T[k] ^= U[k];
        }
        T.copy(DK, destPos);
        destPos += hLen;
    }
    return DK;
}
const encrypt = function(self1, block) {
    return self1._cipher.encryptBlock(block);
};
const decrypt = function(self1, block) {
    return self1._cipher.decryptBlock(block);
};
const mod3 = {
    encrypt: encrypt,
    decrypt: decrypt
};
function xor(a, b) {
    const length = Math.min(a.length, b.length);
    const buffer = Buffer1.allocUnsafe(length);
    for(let i = 0; i < length; ++i){
        buffer[i] = a[i] ^ b[i];
    }
    return buffer;
}
const encrypt1 = function(self1, block) {
    const data = xor(block, self1._prev);
    self1._prev = self1._cipher.encryptBlock(data);
    return self1._prev;
};
const decrypt1 = function(self1, block) {
    const pad = self1._prev;
    self1._prev = block;
    const out = self1._cipher.decryptBlock(block);
    return xor(out, pad);
};
const mod4 = {
    encrypt: encrypt1,
    decrypt: decrypt1
};
function encryptStart(self1, data, decrypt) {
    const len = data.length;
    const out = xor(data, self1._cache);
    self1._cache = self1._cache.slice(len);
    self1._prev = Buffer1.concat([
        self1._prev,
        decrypt ? data : out
    ]);
    return out;
}
const encrypt2 = function(self1, data, decrypt) {
    let out = Buffer1.allocUnsafe(0);
    let len;
    while(data.length){
        if (self1._cache.length === 0) {
            self1._cache = self1._cipher.encryptBlock(self1._prev);
            self1._prev = Buffer1.allocUnsafe(0);
        }
        if (self1._cache.length <= data.length) {
            len = self1._cache.length;
            out = Buffer1.concat([
                out,
                encryptStart(self1, data.slice(0, len), decrypt), 
            ]);
            data = data.slice(len);
        } else {
            out = Buffer1.concat([
                out,
                encryptStart(self1, data, decrypt)
            ]);
            break;
        }
    }
    return out;
};
const mod5 = {
    encrypt: encrypt2
};
function encryptByte(self1, byteParam, decrypt) {
    const pad = self1._cipher.encryptBlock(self1._prev);
    const out = pad[0] ^ byteParam;
    self1._prev = Buffer1.concat([
        self1._prev.slice(1),
        Buffer1.from([
            decrypt ? byteParam : out
        ]), 
    ]);
    return out;
}
const encrypt3 = function(self1, chunk, decrypt) {
    const len = chunk.length;
    const out = Buffer1.allocUnsafe(len);
    let i = -1;
    while(++i < len){
        out[i] = encryptByte(self1, chunk[i], decrypt);
    }
    return out;
};
const mod6 = {
    encrypt: encrypt3
};
function encryptByte1(self1, byteParam, decrypt) {
    let pad;
    let i = -1;
    let out = 0;
    let bit, value;
    while(++i < 8){
        pad = self1._cipher.encryptBlock(self1._prev);
        bit = byteParam & 1 << 7 - i ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += (value & 0x80) >> i % 8;
        self1._prev = shiftIn(self1._prev, decrypt ? bit : value);
    }
    return out;
}
function shiftIn(buffer, value) {
    const len = buffer.length;
    let i = -1;
    const out = Buffer1.allocUnsafe(buffer.length);
    buffer = Buffer1.concat([
        buffer,
        Buffer1.from([
            value
        ])
    ]);
    while(++i < len){
        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
    }
    return out;
}
const encrypt4 = function(self1, chunk, decrypt) {
    const len = chunk.length;
    const out = Buffer1.allocUnsafe(len);
    let i = -1;
    while(++i < len){
        out[i] = encryptByte1(self1, chunk[i], decrypt);
    }
    return out;
};
const mod7 = {
    encrypt: encrypt4
};
function getBlock(self1) {
    self1._prev = self1._cipher.encryptBlock(self1._prev);
    return self1._prev;
}
const encrypt5 = function(self1, chunk) {
    while(self1._cache.length < chunk.length){
        self1._cache = Buffer1.concat([
            self1._cache,
            getBlock(self1)
        ]);
    }
    const pad = self1._cache.slice(0, chunk.length);
    self1._cache = self1._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod8 = {
    encrypt: encrypt5
};
function incr32(iv) {
    let len = iv.length;
    let item;
    while(len--){
        item = iv.readUInt8(len);
        if (item === 255) {
            iv.writeUInt8(0, len);
        } else {
            item++;
            iv.writeUInt8(item, len);
            break;
        }
    }
}
function getBlock1(self1) {
    const out = self1._cipher.encryptBlockRaw(self1._prev);
    incr32(self1._prev);
    return out;
}
const blockSize = 16;
const encrypt6 = function(self1, chunk) {
    const chunkNum = Math.ceil(chunk.length / 16);
    const start = self1._cache.length;
    self1._cache = Buffer1.concat([
        self1._cache,
        Buffer1.allocUnsafe(chunkNum * blockSize), 
    ]);
    for(let i = 0; i < chunkNum; i++){
        const out = getBlock1(self1);
        const offset = start + i * 16;
        self1._cache.writeUInt32BE(out[0], offset + 0);
        self1._cache.writeUInt32BE(out[1], offset + 4);
        self1._cache.writeUInt32BE(out[2], offset + 8);
        self1._cache.writeUInt32BE(out[3], offset + 12);
    }
    const pad = self1._cache.slice(0, chunk.length);
    self1._cache = self1._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod9 = {
    encrypt: encrypt6
};
const modeModules = {
    ECB: mod3,
    CBC: mod4,
    CFB: mod5,
    CFB8: mod6,
    CFB1: mod7,
    OFB: mod8,
    CTR: mod9,
    GCM: mod9
};
const MODES = {
    "aes-128-ecb": {
        "cipher": "AES",
        "key": 128,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-192-ecb": {
        "cipher": "AES",
        "key": 192,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-256-ecb": {
        "cipher": "AES",
        "key": 256,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-128-cbc": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-192-cbc": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-256-cbc": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes128": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes192": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes256": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-128-cfb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-192-cfb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-256-cfb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-128-cfb8": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-192-cfb8": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-256-cfb8": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-128-cfb1": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-192-cfb1": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-256-cfb1": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-128-ofb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-192-ofb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-256-ofb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-128-ctr": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-192-ctr": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-256-ctr": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-128-gcm": {
        "cipher": "AES",
        "key": 128,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-192-gcm": {
        "cipher": "AES",
        "key": 192,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-256-gcm": {
        "cipher": "AES",
        "key": 256,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    }
};
for (const mode of Object.values(MODES)){
    mode.module = modeModules[mode.mode];
}
function asUInt32Array(buf) {
    if (!Buffer1.isBuffer(buf)) buf = Buffer1.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);
    for(var i = 0; i < len; i++){
        out[i] = buf.readUInt32BE(i * 4);
    }
    return out;
}
function scrubVec(v) {
    for(var i = 0; i < v.length; v++){
        v[i] = 0;
    }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for(var round = 1; round < nRounds; round++){
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [
        t0,
        t1,
        t2,
        t3
    ];
}
var RCON = [
    0x00,
    0x01,
    0x02,
    0x04,
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
    0x1b,
    0x36
];
var G = function() {
    var d = new Array(256);
    for(var j = 0; j < 256; j++){
        if (j < 128) {
            d[j] = j << 1;
        } else {
            d[j] = j << 1 ^ 0x11b;
        }
    }
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var INV_SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var x = 0;
    var xi = 0;
    for(var i = 0; i < 256; ++i){
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
            x = xi = 1;
        } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
        }
    }
    return {
        SBOX: SBOX,
        INV_SBOX: INV_SBOX,
        SUB_MIX: SUB_MIX,
        INV_SUB_MIX: INV_SUB_MIX
    };
}();
function AES(key) {
    this._key = asUInt32Array(key);
    this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for(var k = 0; k < keySize; k++){
        keySchedule[k] = keyWords[k];
    }
    for(k = keySize; k < ksRows; k++){
        var t = keySchedule[k - 1];
        if (k % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
            t ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) {
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
        }
        keySchedule[k] = keySchedule[k - keySize] ^ t;
    }
    var invKeySchedule = [];
    for(var ik = 0; ik < ksRows; ik++){
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
        } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
        }
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
    M = asUInt32Array(M);
    return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
};
AES.prototype.decryptBlock = function(M) {
    M = asUInt32Array(M);
    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
};
AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
};
function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
    } else {
        this.final = this._finalOrDigest;
    }
    if (this._final) {
        this.__final = this._final;
        this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
}
CipherBase.prototype = Object.create(Transform.prototype, {
    constructor: {
        value: CipherBase,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
    if (typeof data === "string") {
        data = Buffer1.from(data, inputEnc);
    }
    var outData = this._update(data);
    if (this.hashMode) return this;
    if (outputEnc) {
        outData = this._toString(outData, outputEnc);
    }
    return outData;
};
CipherBase.prototype.setAutoPadding = function() {};
CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _, next) {
    var err;
    try {
        if (this.hashMode) {
            this._update(data);
        } else {
            this.push(this._update(data));
        }
    } catch (e) {
        err = e;
    } finally{
        next(err);
    }
};
CipherBase.prototype._flush = function(done) {
    var err;
    try {
        this.push(this.__final());
    } catch (e) {
        err = e;
    }
    done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer1.alloc(0);
    if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
    }
    return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) {
        out += this._decoder.end();
    }
    return out;
};
var ZEROES = Buffer1.alloc(16, 0);
function toArray(buf) {
    return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12), 
    ];
}
function fromArray(out) {
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
}
function GHASH(key) {
    this.h = key;
    this.state = Buffer1.alloc(16, 0);
    this.cache = Buffer1.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
    var i = -1;
    while(++i < block.length){
        this.state[i] ^= block[i];
    }
    this._multiply();
};
GHASH.prototype._multiply = function() {
    var Vi = toArray(this.h);
    var Zi = [
        0,
        0,
        0,
        0
    ];
    var j, xi, lsbVi;
    var i = -1;
    while(++i < 128){
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for(j = 3; j > 0; j--){
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
            Vi[0] = Vi[0] ^ 0xe1 << 24;
        }
    }
    this.state = fromArray(Zi);
};
GHASH.prototype.update = function(buf) {
    this.cache = Buffer1.concat([
        this.cache,
        buf
    ]);
    var chunk;
    while(this.cache.length >= 16){
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
    }
};
GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) {
        this.ghash(Buffer1.concat([
            this.cache,
            ZEROES
        ], 16));
    }
    this.ghash(fromArray([
        0,
        abl,
        0,
        bl
    ]));
    return this.state;
};
function xorTest(a, b) {
    var out = 0;
    if (a.length !== b.length) out++;
    var len = Math.min(a.length, b.length);
    for(var i = 0; i < len; ++i){
        out += a[i] ^ b[i];
    }
    return out;
}
function calcIv(self1, iv, ck) {
    if (iv.length === 12) {
        self1._finID = Buffer1.concat([
            iv,
            Buffer1.from([
                0,
                0,
                0,
                1
            ])
        ]);
        return Buffer1.concat([
            iv,
            Buffer1.from([
                0,
                0,
                0,
                2
            ])
        ]);
    }
    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);
    if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer1.alloc(toPad, 0));
    }
    ghash.update(Buffer1.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer1.alloc(8);
    tail.writeUIntBE(ivBits, 2, 6);
    ghash.update(tail);
    self1._finID = ghash.state;
    var out = Buffer1.from(self1._finID);
    incr32(out);
    return out;
}
function StreamCipher(mode, key, iv, decrypt) {
    CipherBase.call(this);
    var h = Buffer1.alloc(4, 0);
    this._cipher = new AES(key);
    var ck = this._cipher.encryptBlock(h);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer1.from(iv);
    this._cache = Buffer1.allocUnsafe(0);
    this._secCache = Buffer1.allocUnsafe(0);
    this._decrypt = decrypt;
    this._alen = 0;
    this._len = 0;
    this._mode = mode;
    this._authTag = null;
    this._called = false;
}
StreamCipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
            rump = Buffer1.alloc(rump, 0);
            this._ghash.update(rump);
        }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) {
        this._ghash.update(chunk);
    } else {
        this._ghash.update(out);
    }
    this._len += chunk.length;
    return out;
};
StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag, this._authTag)) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    this._authTag = tag;
    this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer1.isBuffer(this._authTag)) {
        throw new Error("Attempting to get auth tag in unsupported state");
    }
    return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!this._decrypt) {
        throw new Error("Attempting to set auth tag in unsupported state");
    }
    this._authTag = tag;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) {
        throw new Error("Attempting to set AAD in unsupported state");
    }
    this._ghash.update(buf);
    this._alen += buf.length;
};
function StreamCipher1(mode, key, iv, decrypt) {
    CipherBase.call(this);
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._cache = Buffer1.allocUnsafe(0);
    this._secCache = Buffer1.allocUnsafe(0);
    this._decrypt = decrypt;
    this._mode = mode;
}
StreamCipher1.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher1.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher1.prototype._final = function() {
    this._cipher.scrub();
};
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer1.isBuffer(password)) password = Buffer1.from(password, "binary");
    if (salt) {
        if (!Buffer1.isBuffer(salt)) salt = Buffer1.from(salt, "binary");
        if (salt.length !== 8) {
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
    }
    let keyLen = keyBits / 8;
    const key = Buffer1.alloc(keyLen);
    const iv = Buffer1.alloc(ivLen || 0);
    let tmp = Buffer1.alloc(0);
    while(keyLen > 0 || ivLen > 0){
        const hash = createHash1("md5");
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        let used = 0;
        if (keyLen > 0) {
            const keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
            const ivStart = iv.length - ivLen;
            const length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
        }
    }
    tmp.fill(0);
    return {
        key,
        iv
    };
}
function Cipher(mode, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter();
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
Cipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Cipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Cipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get()){
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
    }
    return Buffer1.concat(out);
};
var PADDING = Buffer1.alloc(16, 0x10);
Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
    }
    if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
    }
};
Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter() {
    this.cache = Buffer1.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
    this.cache = Buffer1.concat([
        this.cache,
        data
    ]);
};
Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
        const out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
    }
    return null;
};
Splitter.prototype.flush = function() {
    var len = 16 - this.cache.length;
    var padBuff = Buffer1.allocUnsafe(len);
    var i = -1;
    while(++i < len){
        padBuff.writeUInt8(len, i);
    }
    return Buffer1.concat([
        this.cache,
        padBuff
    ]);
};
function Decipher(mode, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter1();
    this._last = void 0;
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
Decipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Decipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Decipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get(this._autopadding)){
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
    }
    return Buffer1.concat(out);
};
Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
    } else if (chunk) {
        throw new Error("data not multiple of block length");
    }
};
Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter1() {
    this.cache = Buffer1.allocUnsafe(0);
}
Splitter1.prototype.add = function(data) {
    this.cache = Buffer1.concat([
        this.cache,
        data
    ]);
};
Splitter1.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
        if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    } else {
        if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    }
    return null;
};
Splitter1.prototype.flush = function() {
    if (this.cache.length) return this.cache;
};
function unpad(last) {
    var padded = last[15];
    if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
    }
    var i = -1;
    while(++i < padded){
        if (last[i + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
        }
    }
    if (padded === 16) return;
    return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer1.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) {
        throw new TypeError("invalid iv length " + iv.length);
    }
    if (typeof password === "string") password = Buffer1.from(password);
    if (password.length !== config.key / 8) {
        throw new TypeError("invalid key length " + password.length);
    }
    if (config.type === "stream") {
        return new StreamCipher1(config.module, password, iv, true);
    } else if (config.type === "auth") {
        return new StreamCipher(config.module, password, iv, true);
    }
    return new Decipher(config.module, password, iv);
}
function toBuf(val, encoding) {
    if (typeof val === "string") {
        if (encoding === "buffer") {
            encoding = "utf8";
        }
        return Buffer1.from(val, encoding);
    }
    return val;
}
const validateByteSource = hideStackFrames((val, name)=>{
    val = toBuf(val);
    if (isAnyArrayBuffer1(val) || isArrayBufferView(val)) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "string",
        "ArrayBuffer",
        "TypedArray",
        "DataView",
        "Buffer"
    ], val);
});
function createSecretKey(_key, _encoding) {
    notImplemented1("crypto.createSecretKey");
}
hideStackFrames((hash, key, salt, info, length)=>{
    key = prepareKey(key);
    salt = toBuf(salt);
    info = toBuf(info);
    validateString(hash, "digest");
    validateByteSource(salt, "salt");
    validateByteSource(info, "info");
    validateInteger(length, "length", 0, 2147483647);
    if (info.byteLength > 1024) {
        throw new ERR_OUT_OF_RANGE("info", "must not contain more than 1024 bytes", info.byteLength);
    }
    return {
        hash,
        key,
        salt,
        info,
        length
    };
});
function prepareKey(key) {
    if (isKeyObject(key)) {
        return key;
    }
    if (isAnyArrayBuffer1(key)) {
        return createSecretKey(new Uint8Array(key));
    }
    key = toBuf(key);
    if (!isArrayBufferView(key)) {
        throw new ERR_INVALID_ARG_TYPE("ikm", [
            "string",
            "SecretKeyObject",
            "ArrayBuffer",
            "TypedArray",
            "DataView",
            "Buffer", 
        ], key);
    }
    return createSecretKey(key);
}
function assert3(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
}
function BN(number, base, endian) {
    if (BN.isBN(number)) {
        return number;
    }
    this.negative = 0;
    this.words = null;
    this.length = 0;
    this.red = null;
    if (number !== null) {
        if (base === "le" || base === "be") {
            endian = base;
            base = 10;
        }
        this._init(number || 0, base || 10, endian || "be");
    }
}
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
    if (num instanceof BN) {
        return true;
    }
    return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
};
BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
};
BN.prototype._init = function init(number, base, endian) {
    if (typeof number === "number") {
        return this._initNumber(number, base, endian);
    }
    if (typeof number === "object") {
        return this._initArray(number, base, endian);
    }
    if (base === "hex") {
        base = 16;
    }
    assert3(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, "");
    var start = 0;
    if (number[0] === "-") {
        start++;
        this.negative = 1;
    }
    if (start < number.length) {
        if (base === 16) {
            this._parseHex(number, start, endian);
        } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
            }
        }
    }
};
BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
        this.negative = 1;
        number = -number;
    }
    if (number < 0x4000000) {
        this.words = [
            number & 0x3ffffff
        ];
        this.length = 1;
    } else if (number < 0x10000000000000) {
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff, 
        ];
        this.length = 2;
    } else {
        assert3(number < 0x20000000000000);
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff,
            1, 
        ];
        this.length = 3;
    }
    if (endian !== "le") return;
    this._initArray(this.toArray(), base, endian);
};
BN.prototype._initArray = function _initArray(number, base, endian) {
    assert3(typeof number.length === "number");
    if (number.length <= 0) {
        this.words = [
            0
        ];
        this.length = 1;
        return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        this.words[i] = 0;
    }
    var j, w;
    var off = 0;
    if (endian === "be") {
        for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    } else if (endian === "le") {
        for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    }
    return this._strip();
};
function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index);
    if (c >= 48 && c <= 57) {
        return c - 48;
    } else if (c >= 65 && c <= 70) {
        return c - 55;
    } else if (c >= 97 && c <= 102) {
        return c - 87;
    } else {
        assert3(false, "Invalid character in " + string);
    }
}
function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
}
BN.prototype._parseHex = function _parseHex(number, start, endian) {
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        this.words[i] = 0;
    }
    var off = 0;
    var j = 0;
    var w;
    if (endian === "be") {
        for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    } else {
        var parseLength = number.length - start;
        for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    }
    this._strip();
};
function parseBase(str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for(var i = start; i < len; i++){
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
            b = c - 49 + 0xa;
        } else if (c >= 17) {
            b = c - 17 + 0xa;
        } else {
            b = c;
        }
        assert3(c >= 0 && b < mul, "Invalid character");
        r += b;
    }
    return r;
}
BN.prototype._parseBase = function _parseBase(number, base, start) {
    this.words = [
        0
    ];
    this.length = 1;
    for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base){
        limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;
    for(var i = start; i < end; i += limbLen){
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for(i = 0; i < mod; i++){
            pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    this._strip();
};
BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
};
function move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
    move(dest, this);
};
BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
};
BN.prototype._expand = function _expand(size) {
    while(this.length < size){
        this.words[this.length++] = 0;
    }
    return this;
};
BN.prototype._strip = function strip() {
    while(this.length > 1 && this.words[this.length - 1] === 0){
        this.length--;
    }
    return this._normSign();
};
BN.prototype._normSign = function _normSign() {
    if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
    }
    return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
    try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect1;
    } catch (e) {
        BN.prototype.inspect = inspect1;
    }
} else {
    BN.prototype.inspect = inspect1;
}
function inspect1() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000", 
];
var groupSizes = [
    0,
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5, 
];
var groupBases = [
    0,
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    10000000,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64000000,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    24300000,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176, 
];
BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;
    if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;
            if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
            } else {
                out = word + out;
            }
            off += 2;
            if (off >= 26) {
                off -= 26;
                i--;
            }
        }
        if (carry !== 0) {
            out = carry.toString(16) + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while(!c.isZero()){
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
            } else {
                out = r + out;
            }
        }
        if (this.isZero()) {
            out = "0" + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    assert3(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];
    if (this.length === 2) {
        ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
        assert3(false, "Number can only safely store up to 53 bits");
    }
    return this.negative !== 0 ? -ret : ret;
};
BN.prototype.toJSON = function toJSON() {
    return this.toString(16, 2);
};
if (Buffer1) {
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer1, endian, length);
    };
}
BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    this._strip();
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert3(byteLength <= reqLength, "byte array longer than desired length");
    assert3(reqLength > 0, "Requested array length <= 0");
    var res = allocate(ArrayType, reqLength);
    var postfix = endian === "le" ? "LE" : "BE";
    this["_toArrayLike" + postfix](res, byteLength);
    return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
    var position = 0;
    var carry = 0;
    for(var i = 0, shift = 0; i < this.length; i++){
        var word = this.words[i] << shift | carry;
        res[position++] = word & 0xff;
        if (position < res.length) {
            res[position++] = word >> 8 & 0xff;
        }
        if (position < res.length) {
            res[position++] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position < res.length) {
                res[position++] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position < res.length) {
        res[position++] = carry;
        while(position < res.length){
            res[position++] = 0;
        }
    }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
    var position = res.length - 1;
    var carry = 0;
    for(var i = 0, shift = 0; i < this.length; i++){
        var word = this.words[i] << shift | carry;
        res[position--] = word & 0xff;
        if (position >= 0) {
            res[position--] = word >> 8 & 0xff;
        }
        if (position >= 0) {
            res[position--] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position >= 0) {
                res[position--] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position >= 0) {
        res[position--] = carry;
        while(position >= 0){
            res[position--] = 0;
        }
    }
};
if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
} else {
    BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
}
BN.prototype._zeroBits = function _zeroBits(w) {
    if (w === 0) return 26;
    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
    }
    if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
    }
    if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
    }
    if ((t & 0x1) === 0) {
        r++;
    }
    return r;
};
BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
};
function toBitArray(num) {
    var w = new Array(num.bitLength());
    for(var bit = 0; bit < w.length; bit++){
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 0x01;
    }
    return w;
}
BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;
    for(var i = 0; i < this.length; i++){
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) break;
    }
    return r;
};
BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
};
BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
};
BN.prototype.neg = function neg() {
    return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
        this.negative ^= 1;
    }
    return this;
};
BN.prototype.iuor = function iuor(num) {
    while(this.length < num.length){
        this.words[this.length++] = 0;
    }
    for(var i = 0; i < num.length; i++){
        this.words[i] = this.words[i] | num.words[i];
    }
    return this._strip();
};
BN.prototype.ior = function ior(num) {
    assert3((this.negative | num.negative) === 0);
    return this.iuor(num);
};
BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
    var b;
    if (this.length > num.length) {
        b = num;
    } else {
        b = this;
    }
    for(var i = 0; i < b.length; i++){
        this.words[i] = this.words[i] & num.words[i];
    }
    this.length = b.length;
    return this._strip();
};
BN.prototype.iand = function iand(num) {
    assert3((this.negative | num.negative) === 0);
    return this.iuand(num);
};
BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
    var a;
    var b;
    if (this.length > num.length) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    for(var i = 0; i < b.length; i++){
        this.words[i] = a.words[i] ^ b.words[i];
    }
    if (this !== a) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    this.length = a.length;
    return this._strip();
};
BN.prototype.ixor = function ixor(num) {
    assert3((this.negative | num.negative) === 0);
    return this.iuxor(num);
};
BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
    assert3(typeof width === "number" && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;
    this._expand(bytesNeeded);
    if (bitsLeft > 0) {
        bytesNeeded--;
    }
    for(var i = 0; i < bytesNeeded; i++){
        this.words[i] = ~this.words[i] & 0x3ffffff;
    }
    if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    }
    return this._strip();
};
BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
    assert3(typeof bit === "number" && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    this._expand(off + 1);
    if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
    } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this._strip();
};
BN.prototype.iadd = function iadd(num) {
    var r;
    if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
    } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
    }
    var a, b;
    if (this.length > num.length) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    var carry = 0;
    for(var i = 0; i < b.length; i++){
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    for(; carry !== 0 && i < a.length; i++){
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    this.length = a.length;
    if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
    } else if (a !== this) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    return this;
};
BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
    } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
    }
    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
    if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
    } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
    }
    var cmp = this.cmp(num);
    if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
    }
    var a, b;
    if (cmp > 0) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    var carry = 0;
    for(var i = 0; i < b.length; i++){
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
    }
    for(; carry !== 0 && i < a.length; i++){
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
    }
    if (carry === 0 && i < a.length && a !== this) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    this.length = Math.max(this.length, i);
    if (a !== this) {
        this.negative = 1;
    }
    return this._strip();
};
BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
};
function smallMulTo(self1, num, out) {
    out.negative = num.negative ^ self1.negative;
    var len = self1.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;
    var a = self1.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;
    for(var k = 1; k < len; k++){
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for(var j = Math.max(0, k - self1.length + 1); j <= maxJ; j++){
            var i = k - j | 0;
            a = self1.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
    }
    if (carry !== 0) {
        out.words[k] = carry | 0;
    } else {
        out.length--;
    }
    return out._strip();
}
var comb10MulTo = function comb10MulTo(self1, num, out) {
    var a = self1.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self1.negative ^ num.negative;
    out.length = 19;
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
        o[19] = c;
        out.length++;
    }
    return out;
};
if (!Math.imul) {
    comb10MulTo = smallMulTo;
}
function bigMulTo(self1, num, out) {
    out.negative = num.negative ^ self1.negative;
    out.length = self1.length + num.length;
    var carry = 0;
    var hncarry = 0;
    for(var k = 0; k < out.length - 1; k++){
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for(var j = Math.max(0, k - self1.length + 1); j <= maxJ; j++){
            var i = k - j;
            var a = self1.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
    }
    if (carry !== 0) {
        out.words[k] = carry;
    } else {
        out.length--;
    }
    return out._strip();
}
function jumboMulTo(self1, num, out) {
    return bigMulTo(self1, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
    } else if (len < 63) {
        res = smallMulTo(this, num, out);
    } else if (len < 1024) {
        res = bigMulTo(this, num, out);
    } else {
        res = jumboMulTo(this, num, out);
    }
    return res;
};
function FFTM(x, y) {
    this.x = x;
    this.y = y;
}
FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for(var i = 0; i < N; i++){
        t[i] = this.revBin(i, l, N);
    }
    return t;
};
FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;
    for(var i = 0; i < l; i++){
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
    }
    return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for(var i = 0; i < N; i++){
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
    }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);
    for(var s = 1; s < N; s <<= 1){
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for(var p = 0; p < N; p += l){
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for(var j = 0; j < s; j++){
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                    rtwdf_ = rx;
                }
            }
        }
    }
};
FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for(N = N / 2 | 0; N; N = N >>> 1){
        i++;
    }
    return 1 << i + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;
    for(var i = 0; i < N / 2; i++){
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
    }
};
FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for(var i = 0; i < N / 2; i++){
        var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 0x3ffffff;
        if (w < 0x4000000) {
            carry = 0;
        } else {
            carry = w / 0x4000000 | 0;
        }
    }
    return ws;
};
FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for(var i = 0; i < len; i++){
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 0x1fff;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 0x1fff;
        carry = carry >>> 13;
    }
    for(i = 2 * len; i < N; ++i){
        rws[i] = 0;
    }
    assert3(carry === 0);
    assert3((carry & ~0x1fff) === 0);
};
FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for(var i = 0; i < N; i++){
        ph[i] = 0;
    }
    return ph;
};
FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);
    var _ = this.stub(N);
    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);
    for(var i = 0; i < N; i++){
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
    }
    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
};
BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert3(typeof num === "number");
    assert3(num < 0x4000000);
    var carry = 0;
    for(var i = 0; i < this.length; i++){
        var w = (this.words[i] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += w / 0x4000000 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
    }
    if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
    }
    return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
    return this.mul(this);
};
BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);
    var res = this;
    for(var i = 0; i < w.length; i++, res = res.sqr()){
        if (w[i] !== 0) break;
    }
    if (++i < w.length) {
        for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
    }
    return res;
};
BN.prototype.iushln = function iushln(bits) {
    assert3(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;
    if (r !== 0) {
        var carry = 0;
        for(i = 0; i < this.length; i++){
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
        }
        if (carry) {
            this.words[i] = carry;
            this.length++;
        }
    }
    if (s !== 0) {
        for(i = this.length - 1; i >= 0; i--){
            this.words[i + s] = this.words[i];
        }
        for(i = 0; i < s; i++){
            this.words[i] = 0;
        }
        this.length += s;
    }
    return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
    assert3(this.negative === 0);
    return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert3(typeof bits === "number" && bits >= 0);
    var h;
    if (hint) {
        h = (hint - hint % 26) / 26;
    } else {
        h = 0;
    }
    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h);
    if (maskedWords) {
        for(var i = 0; i < s; i++){
            maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
    }
    if (s === 0) {} else if (this.length > s) {
        this.length -= s;
        for(i = 0; i < this.length; i++){
            this.words[i] = this.words[i + s];
        }
    } else {
        this.words[0] = 0;
        this.length = 1;
    }
    var carry = 0;
    for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
    }
    if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
    }
    return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    assert3(this.negative === 0);
    return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
    assert3(typeof bit === "number" && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) return false;
    var w = this.words[s];
    return !!(w & q);
};
BN.prototype.imaskn = function imaskn(bits) {
    assert3(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert3(this.negative === 0, "imaskn works only with positive numbers");
    if (this.length <= s) {
        return this;
    }
    if (r !== 0) {
        s++;
    }
    this.length = Math.min(s, this.length);
    if (r !== 0) {
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        this.words[this.length - 1] &= mask;
    }
    return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
    assert3(typeof num === "number");
    assert3(num < 0x4000000);
    if (num < 0) return this.isubn(-num);
    if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
    }
    return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;
    for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
        this.words[i] -= 0x4000000;
        if (i === this.length - 1) {
            this.words[i + 1] = 1;
        } else {
            this.words[i + 1]++;
        }
    }
    this.length = Math.max(this.length, i + 1);
    return this;
};
BN.prototype.isubn = function isubn(num) {
    assert3(typeof num === "number");
    assert3(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);
    if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
    } else {
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
    }
    return this._strip();
};
BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
};
BN.prototype.abs = function abs() {
    return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;
    this._expand(len);
    var w;
    var carry = 0;
    for(i = 0; i < num.length; i++){
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - (right / 0x4000000 | 0);
        this.words[i + shift] = w & 0x3ffffff;
    }
    for(; i < this.length - shift; i++){
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
    }
    if (carry === 0) return this._strip();
    assert3(carry === -1);
    carry = 0;
    for(i = 0; i < this.length; i++){
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;
    return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num;
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
    }
    var m = a.length - b.length;
    var q;
    if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for(var i = 0; i < q.length; i++){
            q.words[i] = 0;
        }
    }
    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
        a = diff;
        if (q) {
            q.words[m] = 1;
        }
    }
    for(var j = m - 1; j >= 0; j--){
        var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 0x3ffffff);
        a._ishlnsubmul(b, qj, j);
        while(a.negative !== 0){
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
                a.negative ^= 1;
            }
        }
        if (q) {
            q.words[j] = qj;
        }
    }
    if (q) {
        q._strip();
    }
    a._strip();
    if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
    }
    return {
        div: q || null,
        mod: a
    };
};
BN.prototype.divmod = function divmod(num, mode, positive) {
    assert3(!num.isZero());
    if (this.isZero()) {
        return {
            div: new BN(0),
            mod: new BN(0)
        };
    }
    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
            div = res.div.neg();
        }
        if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
                mod.iadd(num);
            }
        }
        return {
            div: div,
            mod: mod
        };
    }
    if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
            div = res.div.neg();
        }
        return {
            div: div,
            mod: res.mod
        };
    }
    if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
                mod.isub(num);
            }
        }
        return {
            div: res.div,
            mod: mod
        };
    }
    if (num.length > this.length || this.cmp(num) < 0) {
        return {
            div: new BN(0),
            mod: this
        };
    }
    if (num.length === 1) {
        if (mode === "div") {
            return {
                div: this.divn(num.words[0]),
                mod: null
            };
        }
        if (mode === "mod") {
            return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
        };
    }
    return this._wordDiv(num, mode);
};
BN.prototype.div = function div(num) {
    return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod(num) {
    return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
    return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);
    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert3(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;
    for(var i = this.length - 1; i >= 0; i--){
        acc = (p * acc + (this.words[i] | 0)) % num;
    }
    return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
    return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert3(num <= 0x3ffffff);
    var carry = 0;
    for(var i = this.length - 1; i >= 0; i--){
        var w = (this.words[i] | 0) + carry * 0x4000000;
        this.words[i] = w / num | 0;
        carry = w % num;
    }
    this._strip();
    return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p) {
    assert3(p.negative === 0);
    assert3(!p.isZero());
    var x = this;
    var y = p.clone();
    if (x.negative !== 0) {
        x = x.umod(p);
    } else {
        x = x.clone();
    }
    var A = new BN(1);
    var B = new BN(0);
    var C = new BN(0);
    var D = new BN(1);
    var g = 0;
    while(x.isEven() && y.isEven()){
        x.iushrn(1);
        y.iushrn(1);
        ++g;
    }
    var yp = y.clone();
    var xp = x.clone();
    while(!x.isZero()){
        for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
            x.iushrn(i);
            while(i-- > 0){
                if (A.isOdd() || B.isOdd()) {
                    A.iadd(yp);
                    B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            y.iushrn(j);
            while(j-- > 0){
                if (C.isOdd() || D.isOdd()) {
                    C.iadd(yp);
                    D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
            }
        }
        if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
        } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
        }
    }
    return {
        a: C,
        b: D,
        gcd: y.iushln(g)
    };
};
BN.prototype._invmp = function _invmp(p) {
    assert3(p.negative === 0);
    assert3(!p.isZero());
    var a = this;
    var b = p.clone();
    if (a.negative !== 0) {
        a = a.umod(p);
    } else {
        a = a.clone();
    }
    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();
    while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
        for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
            a.iushrn(i);
            while(i-- > 0){
                if (x1.isOdd()) {
                    x1.iadd(delta);
                }
                x1.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            b.iushrn(j);
            while(j-- > 0){
                if (x2.isOdd()) {
                    x2.iadd(delta);
                }
                x2.iushrn(1);
            }
        }
        if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
        } else {
            b.isub(a);
            x2.isub(x1);
        }
    }
    var res;
    if (a.cmpn(1) === 0) {
        res = x1;
    } else {
        res = x2;
    }
    if (res.cmpn(0) < 0) {
        res.iadd(p);
    }
    return res;
};
BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;
    for(var shift = 0; a.isEven() && b.isEven(); shift++){
        a.iushrn(1);
        b.iushrn(1);
    }
    do {
        while(a.isEven()){
            a.iushrn(1);
        }
        while(b.isEven()){
            b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
            var t = a;
            a = b;
            b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
            break;
        }
        a.isub(b);
    }while (true)
    return b.iushln(shift);
};
BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
    assert3(typeof bit === "number");
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
    }
    var carry = q;
    for(var i = s; carry !== 0 && i < this.length; i++){
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
    }
    if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
    }
    return this;
};
BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this._strip();
    var res;
    if (this.length > 1) {
        res = 1;
    } else {
        if (negative) {
            num = -num;
        }
        assert3(num <= 0x3ffffff, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.ucmp = function ucmp(num) {
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;
    for(var i = this.length - 1; i >= 0; i--){
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;
        if (a < b) {
            res = -1;
        } else if (a > b) {
            res = 1;
        }
        break;
    }
    return res;
};
BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
};
BN.red = function red(num) {
    return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
    assert3(!this.red, "Already a number in reduction context");
    assert3(this.negative === 0, "red works only with positives");
    return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
    assert3(this.red, "fromRed works only with numbers in reduction context");
    return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
    assert3(!this.red, "Already a number in reduction context");
    return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
    assert3(this.red, "redAdd works only with red numbers");
    return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
    assert3(this.red, "redIAdd works only with red numbers");
    return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
    assert3(this.red, "redSub works only with red numbers");
    return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
    assert3(this.red, "redISub works only with red numbers");
    return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
    assert3(this.red, "redShl works only with red numbers");
    return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
    assert3(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
    assert3(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
    assert3(this.red, "redSqr works only with red numbers");
    this.red._verify1(this);
    return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
    assert3(this.red, "redISqr works only with red numbers");
    this.red._verify1(this);
    return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
    assert3(this.red, "redSqrt works only with red numbers");
    this.red._verify1(this);
    return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
    assert3(this.red, "redInvm works only with red numbers");
    this.red._verify1(this);
    return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
    assert3(this.red, "redNeg works only with red numbers");
    this.red._verify1(this);
    return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
    assert3(this.red && !num.red, "redPow(normalNum)");
    this.red._verify1(this);
    return this.red.pow(this, num);
};
var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
};
function MPrime(name, p) {
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
    var r = num;
    var rlen;
    do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
    }while (rlen > this.n)
    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
    } else if (cmp > 0) {
        r.isub(this.p);
    } else {
        if (r.strip !== undefined) {
            r.strip();
        } else {
            r._strip();
        }
    }
    return r;
};
MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
};
function K256() {
    MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits(K256, MPrime);
K256.prototype.split = function split(input, output) {
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);
    for(var i = 0; i < outLen; i++){
        output.words[i] = input.words[i];
    }
    output.length = outLen;
    if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
    }
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for(i = 10; i < input.length; i++){
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
        input.length -= 10;
    } else {
        input.length -= 9;
    }
};
K256.prototype.imulK = function imulK(num) {
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;
    var lo = 0;
    for(var i = 0; i < num.length; i++){
        var w = num.words[i] | 0;
        lo += w * 0x3d1;
        num.words[i] = lo & 0x3ffffff;
        lo = w * 0x40 + (lo / 0x4000000 | 0);
    }
    if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
            num.length--;
        }
    }
    return num;
};
function P224() {
    MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits(P224, MPrime);
function P192() {
    MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits(P192, MPrime);
function P25519() {
    MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits(P25519, MPrime);
P25519.prototype.imulK = function imulK(num) {
    var carry = 0;
    for(var i = 0; i < num.length; i++){
        var hi = (num.words[i] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
    }
    if (carry !== 0) {
        num.words[num.length++] = carry;
    }
    return num;
};
BN._prime = function prime(name) {
    if (primes[name]) return primes[name];
    var prime;
    if (name === "k256") {
        prime = new K256();
    } else if (name === "p224") {
        prime = new P224();
    } else if (name === "p192") {
        prime = new P192();
    } else if (name === "p25519") {
        prime = new P25519();
    } else {
        throw new Error("Unknown prime " + name);
    }
    primes[name] = prime;
    return prime;
};
function Red(m) {
    if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
    } else {
        assert3(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
    }
}
Red.prototype._verify1 = function _verify1(a) {
    assert3(a.negative === 0, "red works only with positives");
    assert3(a.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a, b) {
    assert3((a.negative | b.negative) === 0, "red works only with positives");
    assert3(a.red && a.red === b.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    move(a, a.umod(this.m)._forceRed(this));
    return a;
};
Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
        return a.clone();
    }
    return this.m.sub(a)._forceRed(this);
};
Red.prototype.add = function add(a, b) {
    this._verify2(a, b);
    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);
    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res;
};
Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);
    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);
    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res;
};
Red.prototype.shl = function shl(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
};
Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
};
Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
};
Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
};
Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
};
Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert3(mod3 % 2 === 1);
    if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
    }
    var q = this.m.subn(1);
    var s = 0;
    while(!q.isZero() && q.andln(1) === 0){
        s++;
        q.iushrn(1);
    }
    assert3(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);
    while(this.pow(z, lpow).cmp(nOne) !== 0){
        z.redIAdd(nOne);
    }
    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while(t.cmp(one) !== 0){
        var tmp = t;
        for(var i = 0; tmp.cmp(one) !== 0; i++){
            tmp = tmp.redSqr();
        }
        assert3(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
    }
    return r;
};
Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
    } else {
        return this.imod(inv);
    }
};
Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for(var i = 2; i < wnd.length; i++){
        wnd[i] = this.mul(wnd[i - 1], a);
    }
    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
        start = 26;
    }
    for(i = num.length - 1; i >= 0; i--){
        var word = num.words[i];
        for(var j = start - 1; j >= 0; j--){
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
                res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
        }
        start = 26;
    }
    return res;
};
Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
};
Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
};
BN.mont = function mont(num) {
    return new Mont(num);
};
function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
    }
    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
}
inherits(Mont, Red);
Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
};
Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
    }
    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.invm = function invm(a) {
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
};
function Reporter(options) {
    this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
    };
}
Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
};
Reporter.prototype.save = function save() {
    const state = this._reporterState;
    return {
        obj: state.obj,
        pathLen: state.path.length
    };
};
Reporter.prototype.restore = function restore(data) {
    const state = this._reporterState;
    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
};
Reporter.prototype.exitKey = function exitKey(index) {
    const state = this._reporterState;
    state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    const state = this._reporterState;
    this.exitKey(index);
    if (state.obj !== null) {
        state.obj[key] = value;
    }
};
Reporter.prototype.path = function path() {
    return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
    const state = this._reporterState;
    const prev = state.obj;
    state.obj = {};
    return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
    const state = this._reporterState;
    const now = state.obj;
    state.obj = prev;
    return now;
};
Reporter.prototype.error = function error(msg) {
    let err;
    const state = this._reporterState;
    const inherited = msg instanceof ReporterError;
    if (inherited) {
        err = msg;
    } else {
        err = new ReporterError(state.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
    }
    if (!state.options.partial) {
        throw err;
    }
    if (!inherited) {
        state.errors.push(err);
    }
    return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
    const state = this._reporterState;
    if (!state.options.partial) {
        return result;
    }
    return {
        result: this.isError(result) ? null : result,
        errors: state.errors
    };
};
function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
    constructor: {
        value: ReporterError,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ReporterError);
    }
    if (!this.stack) {
        try {
            throw new Error(this.message);
        } catch (e) {
            this.stack = e.stack;
        }
    }
    return this;
};
function DecoderBuffer(base, options) {
    Reporter.call(this, options);
    if (!Buffer1.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
    }
    this.base = base;
    this.offset = 0;
    this.length = base.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
    constructor: {
        value: DecoderBuffer,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
    if (data instanceof DecoderBuffer) {
        return true;
    }
    const isCompatible = typeof data === "object" && Buffer1.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
    return isCompatible;
};
DecoderBuffer.prototype.save = function save() {
    return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
    };
};
DecoderBuffer.prototype.restore = function restore(save) {
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length) {
        return this.base.readUInt8(this.offset++, true);
    } else {
        return this.error(fail || "DecoderBuffer overrun");
    }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail) {
    if (!(this.offset + bytes <= this.length)) {
        return this.error(fail || "DecoderBuffer overrun");
    }
    const res = new DecoderBuffer(this.base);
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
};
DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item)) {
                item = new EncoderBuffer(item, reporter);
            }
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === "number") {
        if (!(0 <= value && value <= 0xff)) {
            return reporter.error("non-byte EncoderBuffer value");
        }
        this.value = value;
        this.length = 1;
    } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer1.byteLength(value);
    } else if (Buffer1.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else {
        return reporter.error("Unsupported type: " + typeof value);
    }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
    if (data instanceof EncoderBuffer) {
        return true;
    }
    const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
    return isCompatible;
};
EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out) {
        out = Buffer1.alloc(this.length);
    }
    if (!offset) {
        offset = 0;
    }
    if (this.length === 0) {
        return out;
    }
    if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
        });
    } else {
        if (typeof this.value === "number") {
            out[offset] = this.value;
        } else if (typeof this.value === "string") {
            out.write(this.value, offset);
        } else if (Buffer1.isBuffer(this.value)) {
            this.value.copy(out, offset);
        }
        offset += this.length;
    }
    return out;
};
const tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr", 
];
const methods1 = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains", 
].concat(tags);
const overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool", 
];
function Node2(enc, parent, name) {
    const state = {};
    this._baseState = state;
    state.name = name;
    state.enc = enc;
    state.parent = parent || null;
    state.children = null;
    state.tag = null;
    state.args = null;
    state.reverseArgs = null;
    state.choice = null;
    state.optional = false;
    state.any = false;
    state.obj = false;
    state.use = null;
    state.useDecoder = null;
    state.key = null;
    state["default"] = null;
    state.explicit = null;
    state.implicit = null;
    state.contains = null;
    if (!state.parent) {
        state.children = [];
        this._wrap();
    }
}
const stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains", 
];
Node2.prototype.clone = function clone() {
    const state = this._baseState;
    const cstate = {};
    stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
    });
    const res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
};
Node2.prototype._wrap = function wrap() {
    const state = this._baseState;
    methods1.forEach(function(method) {
        this[method] = function _wrappedMethod() {
            const clone = new this.constructor(this);
            state.children.push(clone);
            return clone[method].apply(clone, arguments);
        };
    }, this);
};
Node2.prototype._init = function init(body) {
    const state = this._baseState;
    assert1(state.parent === null);
    body.call(this);
    state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
    }, this);
    assertEquals(state.children.length, 1, "Root node can have only one child");
};
Node2.prototype._useArgs = function useArgs(args) {
    const state = this._baseState;
    const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
        assert1(state.children === null);
        state.children = children;
        children.forEach(function(child) {
            child._baseState.parent = this;
        }, this);
    }
    if (args.length !== 0) {
        assert1(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object) {
                return arg;
            }
            const res = {};
            Object.keys(arg).forEach(function(key) {
                if (key == (key | 0)) {
                    key |= 0;
                }
                const value = arg[key];
                res[value] = key;
            });
            return res;
        });
    }
};
overrided.forEach(function(method) {
    Node2.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
    };
});
tags.forEach(function(tag) {
    Node2.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert1(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
    };
});
Node2.prototype.use = function use(item) {
    assert1(item);
    const state = this._baseState;
    assert1(state.use === null);
    state.use = item;
    return this;
};
Node2.prototype.optional = function optional() {
    const state = this._baseState;
    state.optional = true;
    return this;
};
Node2.prototype.def = function def(val) {
    const state = this._baseState;
    assert1(state["default"] === null);
    state["default"] = val;
    state.optional = true;
    return this;
};
Node2.prototype.explicit = function explicit(num) {
    const state = this._baseState;
    assert1(state.explicit === null && state.implicit === null);
    state.explicit = num;
    return this;
};
Node2.prototype.implicit = function implicit(num) {
    const state = this._baseState;
    assert1(state.explicit === null && state.implicit === null);
    state.implicit = num;
    return this;
};
Node2.prototype.obj = function obj() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    state.obj = true;
    if (args.length !== 0) {
        this._useArgs(args);
    }
    return this;
};
Node2.prototype.key = function key(newKey) {
    const state = this._baseState;
    assert1(state.key === null);
    state.key = newKey;
    return this;
};
Node2.prototype.any = function any() {
    const state = this._baseState;
    state.any = true;
    return this;
};
Node2.prototype.choice = function choice(obj) {
    const state = this._baseState;
    assert1(state.choice === null);
    state.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
    }));
    return this;
};
Node2.prototype.contains = function contains(item) {
    const state = this._baseState;
    assert1(state.use === null);
    state.contains = item;
    return this;
};
Node2.prototype._decode = function decode(input, options) {
    const state = this._baseState;
    if (state.parent === null) {
        return input.wrapResult(state.children[0]._decode(input, options));
    }
    let result = state["default"];
    let present = true;
    let prevKey = null;
    if (state.key !== null) {
        prevKey = input.enterKey(state.key);
    }
    if (state.optional) {
        let tag = null;
        if (state.explicit !== null) {
            tag = state.explicit;
        } else if (state.implicit !== null) {
            tag = state.implicit;
        } else if (state.tag !== null) {
            tag = state.tag;
        }
        if (tag === null && !state.any) {
            const save = input.save();
            try {
                if (state.choice === null) {
                    this._decodeGeneric(state.tag, input, options);
                } else {
                    this._decodeChoice(input, options);
                }
                present = true;
            } catch (_e) {
                present = false;
            }
            input.restore(save);
        } else {
            present = this._peekTag(input, tag, state.any);
            if (input.isError(present)) {
                return present;
            }
        }
    }
    let prevObj;
    if (state.obj && present) {
        prevObj = input.enterObject();
    }
    if (present) {
        if (state.explicit !== null) {
            const explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit)) {
                return explicit;
            }
            input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
            let save1;
            if (state.any) {
                save1 = input.save();
            }
            const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body)) {
                return body;
            }
            if (state.any) {
                result = input.raw(save1);
            } else {
                input = body;
            }
        }
        if (options && options.track && state.tag !== null) {
            options.track(input.path(), start, input.length, "tagged");
        }
        if (options && options.track && state.tag !== null) {
            options.track(input.path(), input.offset, input.length, "content");
        }
        if (state.any) {} else if (state.choice === null) {
            result = this._decodeGeneric(state.tag, input, options);
        } else {
            result = this._decodeChoice(input, options);
        }
        if (input.isError(result)) {
            return result;
        }
        if (!state.any && state.choice === null && state.children !== null) {
            state.children.forEach(function decodeChildren(child) {
                child._decode(input, options);
            });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            const data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
    }
    if (state.obj && present) {
        result = input.leaveObject(prevObj);
    }
    if (state.key !== null && (result !== null || present === true)) {
        input.leaveKey(prevKey, state.key, result);
    } else if (prevKey !== null) {
        input.exitKey(prevKey);
    }
    return result;
};
Node2.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
    const state = this._baseState;
    if (tag === "seq" || tag === "set") {
        return null;
    }
    if (tag === "seqof" || tag === "setof") {
        return this._decodeList(input, tag, state.args[0], options);
    } else if (/str$/.test(tag)) {
        return this._decodeStr(input, tag, options);
    } else if (tag === "objid" && state.args) {
        return this._decodeObjid(input, state.args[0], state.args[1], options);
    } else if (tag === "objid") {
        return this._decodeObjid(input, null, null, options);
    } else if (tag === "gentime" || tag === "utctime") {
        return this._decodeTime(input, tag, options);
    } else if (tag === "null_") {
        return this._decodeNull(input, options);
    } else if (tag === "bool") {
        return this._decodeBool(input, options);
    } else if (tag === "objDesc") {
        return this._decodeStr(input, tag, options);
    } else if (tag === "int" || tag === "enum") {
        return this._decodeInt(input, state.args && state.args[0], options);
    }
    if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
    } else {
        return input.error("unknown tag: " + tag);
    }
};
Node2.prototype._getUse = function _getUse(entity, obj) {
    const state = this._baseState;
    state.useDecoder = this._use(entity, obj);
    assert1(state.useDecoder._baseState.parent === null);
    state.useDecoder = state.useDecoder._baseState.children[0];
    if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
    }
    return state.useDecoder;
};
Node2.prototype._decodeChoice = function decodeChoice(input, options) {
    const state = this._baseState;
    let result = null;
    let match = false;
    Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
            const value = node._decode(input, options);
            if (input.isError(value)) {
                return false;
            }
            result = {
                type: key,
                value: value
            };
            match = true;
        } catch (_e) {
            input.restore(save);
            return false;
        }
        return true;
    }, this);
    if (!match) {
        return input.error("Choice not matched");
    }
    return result;
};
Node2.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
};
Node2.prototype._encode = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state["default"] !== null && state["default"] === data) {
        return;
    }
    const result = this._encodeValue(data, reporter, parent);
    if (result === undefined) {
        return;
    }
    if (this._skipDefault(result, reporter, parent)) {
        return;
    }
    return result;
};
Node2.prototype._encodeValue = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state.parent === null) {
        return state.children[0]._encode(data, reporter || new Reporter());
    }
    let result = null;
    this.reporter = reporter;
    if (state.optional && data === undefined) {
        if (state["default"] !== null) {
            data = state["default"];
        } else {
            return;
        }
    }
    let content = null;
    let primitive = false;
    if (state.any) {
        result = this._createEncoderBuffer(data);
    } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
    } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
    } else if (state.children) {
        content = state.children.map(function(child) {
            if (child._baseState.tag === "null_") {
                return child._encode(null, reporter, data);
            }
            if (child._baseState.key === null) {
                return reporter.error("Child should have a key");
            }
            const prevKey = reporter.enterKey(child._baseState.key);
            if (typeof data !== "object") {
                return reporter.error("Child expected, but input is not object");
            }
            const res = child._encode(data[child._baseState.key], reporter, data);
            reporter.leaveKey(prevKey);
            return res;
        }, this).filter(function(child) {
            return child;
        });
        content = this._createEncoderBuffer(content);
    } else {
        if (state.tag === "seqof" || state.tag === "setof") {
            if (!(state.args && state.args.length === 1)) {
                return reporter.error("Too many args for : " + state.tag);
            }
            if (!Array.isArray(data)) {
                return reporter.error("seqof/setof, but data is not Array");
            }
            const child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
                const state = this._baseState;
                return this._getUse(state.args[0], data)._encode(item, reporter);
            }, child));
        } else if (state.use !== null) {
            result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
            content = this._encodePrimitive(state.tag, data);
            primitive = true;
        }
    }
    if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
            if (state.use === null) {
                reporter.error("Tag could be omitted only for .use()");
            }
        } else {
            if (state.use === null) {
                result = this._encodeComposite(tag, primitive, cls, content);
            }
        }
    }
    if (state.explicit !== null) {
        result = this._encodeComposite(state.explicit, false, "context", result);
    }
    return result;
};
Node2.prototype._encodeChoice = function encodeChoice(data, reporter) {
    const state = this._baseState;
    const node = state.choice[data.type];
    if (!node) {
        assert1(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
    }
    return node._encode(data.value, reporter);
};
Node2.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    const state = this._baseState;
    if (/str$/.test(tag)) {
        return this._encodeStr(data, tag);
    } else if (tag === "objid" && state.args) {
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
    } else if (tag === "objid") {
        return this._encodeObjid(data, null, null);
    } else if (tag === "gentime" || tag === "utctime") {
        return this._encodeTime(data, tag);
    } else if (tag === "null_") {
        return this._encodeNull();
    } else if (tag === "int" || tag === "enum") {
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
    } else if (tag === "bool") {
        return this._encodeBool(data);
    } else if (tag === "objDesc") {
        return this._encodeStr(data, tag);
    } else {
        throw new Error("Unsupported tag: " + tag);
    }
};
Node2.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
};
Node2.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key) {
        if ((key | 0) == key) {
            key = key | 0;
        }
        const value = map[key];
        res[value] = key;
    });
    return res;
}
const tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
};
const tagClassByName = reverse(tagClass);
const tag = {
    0x00: "end",
    0x01: "bool",
    0x02: "int",
    0x03: "bitstr",
    0x04: "octstr",
    0x05: "null_",
    0x06: "objid",
    0x07: "objDesc",
    0x08: "external",
    0x09: "real",
    0x0a: "enum",
    0x0b: "embed",
    0x0c: "utf8str",
    0x0d: "relativeOid",
    0x10: "seq",
    0x11: "set",
    0x12: "numstr",
    0x13: "printstr",
    0x14: "t61str",
    0x15: "videostr",
    0x16: "ia5str",
    0x17: "utctime",
    0x18: "gentime",
    0x19: "graphstr",
    0x1a: "iso646str",
    0x1b: "genstr",
    0x1c: "unistr",
    0x1d: "charstr",
    0x1e: "bmpstr"
};
const tagByName = reverse(tag);
const mod10 = {
    tagClass: tagClass,
    tagClassByName: tagClassByName,
    tag: tag,
    tagByName: tagByName
};
function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode(data, reporter) {
    return this.tree._encode(data, reporter).join();
};
function DERNode(parent) {
    Node2.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node2.prototype, {
    constructor: {
        value: DERNode,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
    if (content.length < 0x80) {
        const header = Buffer1.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([
            header,
            content
        ]);
    }
    let lenOctets = 1;
    for(let i = content.length; i >= 0x100; i >>= 8){
        lenOctets++;
    }
    const header1 = Buffer1.alloc(1 + 1 + lenOctets);
    header1[0] = encodedTag;
    header1[1] = 0x80 | lenOctets;
    for(let i1 = 1 + lenOctets, j = content.length; j > 0; i1--, j >>= 8){
        header1[i1] = j & 0xff;
    }
    return this._createEncoderBuffer([
        header1,
        content
    ]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === "bitstr") {
        return this._createEncoderBuffer([
            str.unused | 0,
            str.data
        ]);
    } else if (tag === "bmpstr") {
        const buf = Buffer1.alloc(str.length * 2);
        for(let i = 0; i < str.length; i++){
            buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
    } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports " + "only digits and space");
        }
        return this._createEncoderBuffer(str);
    } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports " + "only latin upper and lower case letters, " + "digits, space, apostrophe, left and rigth " + "parenthesis, plus sign, comma, hyphen, " + "dot, slash, colon, equal sign, " + "question mark");
        }
        return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
    } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
    } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
    if (typeof id === "string") {
        if (!values) {
            return this.reporter.error("string objid given, but no values map found");
        }
        if (!values.hasOwnProperty(id)) {
            return this.reporter.error("objid not found in values map");
        }
        id = values[id].split(/[\s.]+/g);
        for(let i = 0; i < id.length; i++){
            id[i] |= 0;
        }
    } else if (Array.isArray(id)) {
        id = id.slice();
        for(let i1 = 0; i1 < id.length; i1++){
            id[i1] |= 0;
        }
    }
    if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, " + "got: " + JSON.stringify(id));
    }
    if (!relative) {
        if (id[1] >= 40) {
            return this.reporter.error("Second objid identifier OOB");
        }
        id.splice(0, 2, id[0] * 40 + id[1]);
    }
    let size = 0;
    for(let i2 = 0; i2 < id.length; i2++){
        let ident = id[i2];
        for(size++; ident >= 0x80; ident >>= 7){
            size++;
        }
    }
    const objid = Buffer1.alloc(size);
    let offset = objid.length - 1;
    for(let i3 = id.length - 1; i3 >= 0; i3--){
        let ident1 = id[i3];
        objid[offset--] = ident1 & 0x7f;
        while((ident1 >>= 7) > 0){
            objid[offset--] = 0x80 | ident1 & 0x7f;
        }
    }
    return this._createEncoderBuffer(objid);
};
function two(num) {
    if (num < 10) {
        return "0" + num;
    } else {
        return num;
    }
}
DERNode.prototype._encodeTime = function encodeTime(time, tag) {
    let str;
    const date = new Date(time);
    if (tag === "gentime") {
        str = [
            two(date.getUTCFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z", 
        ].join("");
    } else if (tag === "utctime") {
        str = [
            two(date.getUTCFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z", 
        ].join("");
    } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
    }
    return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
    if (typeof num === "string") {
        if (!values) {
            return this.reporter.error("String int or enum given, but no values map");
        }
        if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
    }
    if (typeof num !== "number" && !Buffer1.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 0x80) {
            numArray.unshift(0);
        }
        num = Buffer1.from(numArray);
    }
    if (Buffer1.isBuffer(num)) {
        let size = num.length;
        if (num.length === 0) {
            size++;
        }
        const out = Buffer1.alloc(size);
        num.copy(out);
        if (num.length === 0) {
            out[0] = 0;
        }
        return this._createEncoderBuffer(out);
    }
    if (num < 0x80) {
        return this._createEncoderBuffer(num);
    }
    if (num < 0x100) {
        return this._createEncoderBuffer([
            0,
            num
        ]);
    }
    let size1 = 1;
    for(let i = num; i >= 0x100; i >>= 8){
        size1++;
    }
    const out1 = new Array(size1);
    for(let i1 = out1.length - 1; i1 >= 0; i1--){
        out1[i1] = num & 0xff;
        num >>= 8;
    }
    if (out1[0] & 0x80) {
        out1.unshift(0);
    }
    return this._createEncoderBuffer(Buffer1.from(out1));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 0xff : 0);
};
DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state = this._baseState;
    let i;
    if (state["default"] === null) {
        return false;
    }
    const data = dataBuffer.join();
    if (state.defaultBuffer === undefined) {
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
    }
    if (data.length !== state.defaultBuffer.length) {
        return false;
    }
    for(i = 0; i < data.length; i++){
        if (data[i] !== state.defaultBuffer[i]) {
            return false;
        }
    }
    return true;
};
function encodeTag(tag, primitive, cls, reporter) {
    let res;
    if (tag === "seqof") {
        tag = "seq";
    } else if (tag === "setof") {
        tag = "set";
    }
    if (tagByName.hasOwnProperty(tag)) {
        res = tagByName[tag];
    } else if (typeof tag === "number" && (tag | 0) === tag) {
        res = tag;
    } else {
        return reporter.error("Unknown tag: " + tag);
    }
    if (res >= 0x1f) {
        return reporter.error("Multi-octet tag encoding unsupported");
    }
    if (!primitive) {
        res |= 0x20;
    }
    res |= tagClassByName[cls || "universal"] << 6;
    return res;
}
function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
    constructor: {
        value: PEMEncoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMEncoder.prototype.encode = function encode(data, options) {
    const buf = DEREncoder.prototype.encode.call(this, data);
    const p = buf.toString("base64");
    const out = [
        "-----BEGIN " + options.label + "-----"
    ];
    for(let i = 0; i < p.length; i += 64){
        out.push(p.slice(i, i + 64));
    }
    out.push("-----END " + options.label + "-----");
    return out.join("\n");
};
function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode1();
    this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode(data, options) {
    if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
    }
    return this.tree._decode(data, options);
};
function DERNode1(parent) {
    Node2.call(this, "der", parent);
}
DERNode1.prototype = Object.create(Node2.prototype, {
    constructor: {
        value: DERNode1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode1.prototype._peekTag = function peekTag(buffer, tag, any) {
    if (buffer.isEmpty()) {
        return false;
    }
    const state = buffer.save();
    const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    if (buffer.isError(decodedTag)) {
        return decodedTag;
    }
    buffer.restore(state);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
};
DERNode1.prototype._decodeTag = function decodeTag(buffer, tag, any) {
    const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag)) {
        return decodedTag;
    }
    let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    if (buffer.isError(len)) {
        return len;
    }
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len !== null) {
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    }
    const state = buffer.save();
    const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer.isError(res)) {
        return res;
    }
    len = buffer.offset - state.offset;
    buffer.restore(state);
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};
DERNode1.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
    for(;;){
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag)) {
            return tag;
        }
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len)) {
            return len;
        }
        let res;
        if (tag.primitive || len !== null) {
            res = buffer.skip(len);
        } else {
            res = this._skipUntilEnd(buffer, fail);
        }
        if (buffer.isError(res)) {
            return res;
        }
        if (tag.tagStr === "end") {
            break;
        }
    }
};
DERNode1.prototype._decodeList = function decodeList(buffer, _tag, decoder, options) {
    const result = [];
    while(!buffer.isEmpty()){
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd)) {
            return possibleEnd;
        }
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd) {
            break;
        }
        result.push(res);
    }
    return result;
};
DERNode1.prototype._decodeStr = function decodeStr(buffer, tag) {
    if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused)) {
            return unused;
        }
        return {
            unused: unused,
            data: buffer.raw()
        };
    } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1) {
            return buffer.error("Decoding of string type: bmpstr length mismatch");
        }
        let str = "";
        for(let i = 0; i < raw.length / 2; i++){
            str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
    } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
            return buffer.error("Decoding of string type: " + "numstr unsupported characters");
        }
        return numstr;
    } else if (tag === "octstr") {
        return buffer.raw();
    } else if (tag === "objDesc") {
        return buffer.raw();
    } else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
            return buffer.error("Decoding of string type: " + "printstr unsupported characters");
        }
        return printstr;
    } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
    } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
    }
};
DERNode1.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
    let result;
    const identifiers = [];
    let ident = 0;
    let subident = 0;
    while(!buffer.isEmpty()){
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 0x7f;
        if ((subident & 0x80) === 0) {
            identifiers.push(ident);
            ident = 0;
        }
    }
    if (subident & 0x80) {
        identifiers.push(ident);
    }
    const first = identifiers[0] / 40 | 0;
    const second = identifiers[0] % 40;
    if (relative) {
        result = identifiers;
    } else {
        result = [
            first,
            second
        ].concat(identifiers.slice(1));
    }
    if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === undefined) {
            tmp = values[result.join(".")];
        }
        if (tmp !== undefined) {
            result = tmp;
        }
    }
    return result;
};
DERNode1.prototype._decodeTime = function decodeTime(buffer, tag) {
    const str = buffer.raw().toString();
    let year;
    let mon;
    let day;
    let hour;
    let min;
    let sec;
    if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
    } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70) {
            year = 2000 + year;
        } else {
            year = 1900 + year;
        }
    } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
    }
    return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};
DERNode1.prototype._decodeNull = function decodeNull() {
    return null;
};
DERNode1.prototype._decodeBool = function decodeBool(buffer) {
    const res = buffer.readUInt8();
    if (buffer.isError(res)) {
        return res;
    } else {
        return res !== 0;
    }
};
DERNode1.prototype._decodeInt = function decodeInt(buffer, values) {
    const raw = buffer.raw();
    let res = new BN(raw);
    if (values) {
        res = values[res.toString(10)] || res;
    }
    return res;
};
DERNode1.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail) {
    let tag1 = buf.readUInt8(fail);
    if (buf.isError(tag1)) {
        return tag1;
    }
    const cls = tagClass[tag1 >> 6];
    const primitive = (tag1 & 0x20) === 0;
    if ((tag1 & 0x1f) === 0x1f) {
        let oct = tag1;
        tag1 = 0;
        while((oct & 0x80) === 0x80){
            oct = buf.readUInt8(fail);
            if (buf.isError(oct)) {
                return oct;
            }
            tag1 <<= 7;
            tag1 |= oct & 0x7f;
        }
    } else {
        tag1 &= 0x1f;
    }
    const tagStr = tag[tag1];
    return {
        cls: cls,
        primitive: primitive,
        tag: tag1,
        tagStr: tagStr
    };
}
function derDecodeLen(buf, primitive, fail) {
    let len = buf.readUInt8(fail);
    if (buf.isError(len)) {
        return len;
    }
    if (!primitive && len === 0x80) {
        return null;
    }
    if ((len & 0x80) === 0) {
        return len;
    }
    const num = len & 0x7f;
    if (num > 4) {
        return buf.error("length octect is too long");
    }
    len = 0;
    for(let i = 0; i < num; i++){
        len <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j)) {
            return j;
        }
        len |= j;
    }
    return len;
}
function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
    constructor: {
        value: PEMDecoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMDecoder.prototype.decode = function decode(data, options) {
    const lines = data.toString().split(/[\r\n]+/g);
    const label = options.label.toUpperCase();
    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start = -1;
    let end = -1;
    for(let i = 0; i < lines.length; i++){
        const match = lines[i].match(re);
        if (match === null) {
            continue;
        }
        if (match[2] !== label) {
            continue;
        }
        if (start === -1) {
            if (match[1] !== "BEGIN") {
                break;
            }
            start = i;
        } else {
            if (match[1] !== "END") {
                break;
            }
            end = i;
            break;
        }
    }
    if (start === -1 || end === -1) {
        throw new Error("PEM section not found for: " + label);
    }
    const base64 = lines.slice(start + 1, end).join("");
    base64.replace(/[^a-z0-9+/=]+/gi, "");
    const input = Buffer1.from(base64, "base64");
    return DERDecoder.prototype.decode.call(this, input, options);
};
const base = {
    DecoderBuffer,
    EncoderBuffer,
    Node: Node2,
    Reporter
};
const encoders = {
    der: DEREncoder,
    pem: PEMEncoder
};
const decoders = {
    der: DERDecoder,
    pem: PEMDecoder
};
const constants = {
    der: mod10
};
function define(name, body) {
    return new Entity(name, body);
}
function Entity(name, body) {
    this.name = name;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
    const name = this.name;
    function Generated(entity) {
        this._initNamed(entity, name);
    }
    Generated.prototype = Object.create(Base.prototype, {
        constructor: {
            value: Generated,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    Generated.prototype._initNamed = function _initNamed(entity, name) {
        Base.call(this, entity, name);
    };
    return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    if (!this.decoders.hasOwnProperty(enc)) {
        this.decoders[enc] = this._createNamed(decoders[enc]);
    }
    return this.decoders[enc];
};
Entity.prototype.decode = function decode(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    if (!this.encoders.hasOwnProperty(enc)) {
        this.encoders[enc] = this._createNamed(encoders[enc]);
    }
    return this.encoders[enc];
};
Entity.prototype.encode = function encode(data, enc, reporter) {
    return this._getEncoder(enc).encode(data, reporter);
};
const __default3 = {
    base,
    bignum: BN,
    constants,
    decoders,
    define,
    encoders
};
const Time = define("Time", function() {
    this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
    });
});
const AttributeTypeValue = define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
});
const AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
const SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
const RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
});
const RDNSequence = define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
});
const Name = define("Name", function() {
    this.choice({
        rdnSequence: this.use(RDNSequence)
    });
});
const Validity = define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
const Extension = define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
const TBSCertificate = define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
const X509Certificate = define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
const RSAPrivateKey = __default3.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
const RSAPublicKey = __default3.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
const PublicKey = __default3.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPublicKey").bitstr());
});
const AlgorithmIdentifier1 = __default3.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
const PrivateKey = __default3.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPrivateKey").octstr());
});
const EncryptedPrivateKey = __default3.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
const DSAPrivateKey = __default3.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
const DSAparam = __default3.define("DSAparam", function() {
    this.int();
});
const ECPrivateKey = __default3.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
const ECParameters = __default3.define("ECParameters", function() {
    this.choice({
        namedCurve: this.objid()
    });
});
const signature = __default3.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
});
const findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
const startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
const fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function __default4(okey, password) {
    const key = okey.toString();
    const match = key.match(findProc);
    let decrypted;
    if (!match) {
        const match2 = key.match(fullRegex);
        decrypted = Buffer1.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
        const suite = "aes" + match[1];
        const iv = Buffer1.from(match[2], "hex");
        const cipherText = Buffer1.from(match[3].replace(/[\r\n]/g, ""), "base64");
        const cipherKey = EVP_BytesToKey(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        const out = [];
        const cipher = createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer1.concat(out);
    }
    const tag = key.match(startRegex)[1];
    return {
        tag: tag,
        data: decrypted
    };
}
const aesid = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer) {
    let password;
    if (typeof buffer === "object" && !Buffer1.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
    }
    if (typeof buffer === "string") {
        buffer = Buffer1.from(buffer);
    }
    const stripped = __default4(buffer, password);
    const type = stripped.tag;
    let data = stripped.data;
    let subtype, ndata;
    switch(type){
        case "CERTIFICATE":
            ndata = X509Certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            if (!ndata) {
                ndata = PublicKey.decode(data, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                    return {
                        type: "ec",
                        data: ndata
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
                    return {
                        type: "dsa",
                        data: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "ENCRYPTED PRIVATE KEY":
            data = EncryptedPrivateKey.decode(data, "der");
            data = decrypt2(data, password);
        case "PRIVATE KEY":
            ndata = PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                    return {
                        curve: ndata.algorithm.curve,
                        privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
                    return {
                        type: "dsa",
                        params: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "RSA PUBLIC KEY":
            return RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
            return RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: DSAPrivateKey.decode(data, "der")
            };
        case "EC PRIVATE KEY":
            data = ECPrivateKey.decode(data, "der");
            return {
                curve: data.parameters.value,
                privateKey: data.privateKey
            };
        default:
            throw new Error("unknown key type " + type);
    }
}
parseKeys.signature = signature;
function decrypt2(data, password) {
    const salt = data.algorithm.decrypt.kde.kdeparams.salt;
    const iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    const algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
    const iv = data.algorithm.decrypt.cipher.iv;
    const cipherText = data.subjectPrivateKey;
    const keylen = parseInt(algo.split("-")[1], 10) / 8;
    const key = pbkdf2Sync(password, salt, iters, keylen, "sha1");
    const cipher = createDecipheriv(algo, key, iv);
    const out = [];
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    return Buffer1.concat(out);
}
const MAX_BYTES = 65536;
function randomBytes(size, cb) {
    if (size > 4294967295) {
        throw new RangeError("requested too many random bytes");
    }
    const bytes = Buffer1.allocUnsafe(size);
    if (size > 0) {
        if (size > 65536) {
            for(let generated = 0; generated < size; generated += MAX_BYTES){
                globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
            }
        } else {
            globalThis.crypto.getRandomValues(bytes);
        }
    }
    if (typeof cb === "function") {
        return nextTick(function() {
            cb(null, bytes);
        });
    }
    return bytes;
}
function blind(priv) {
    const r = getr(priv);
    const blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
    return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
    };
}
function getr(priv) {
    const len = priv.modulus.byteLength();
    let r;
    do {
        r = new BN(randomBytes(len));
    }while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
    return r;
}
function crt(msg, priv) {
    const blinds = blind(priv);
    const len = priv.modulus.byteLength();
    const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
    const c1 = blinded.toRed(BN.mont(priv.prime1));
    const c2 = blinded.toRed(BN.mont(priv.prime2));
    const qinv = priv.coefficient;
    const p = priv.prime1;
    const q = priv.prime2;
    const m1 = c1.redPow(priv.exponent1).fromRed();
    const m2 = c2.redPow(priv.exponent2).fromRed();
    const h = m1.isub(m2).imul(qinv).umod(p).imul(q);
    return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer1, "be", len);
}
crt.getr = getr;
class Certificate {
    static Certificate = Certificate;
    static exportChallenge(_spkac, _encoding) {
        notImplemented1("crypto.Certificate.exportChallenge");
    }
    static exportPublicKey(_spkac, _encoding) {
        notImplemented1("crypto.Certificate.exportPublicKey");
    }
    static verifySpkac(_spkac, _encoding) {
        notImplemented1("crypto.Certificate.verifySpkac");
    }
}
globalThis.crypto;
getOptionValue("--force-fips");
Object.defineProperty(crypto1, "defaultCipherList", {
    value: getOptionValue("--tls-cipher-list")
});
const HASH_OPERATIONS = {
    sha256: ()=>new Hash('sha256'),
    sha512: ()=>new Hash('sha512'),
    sha1: ()=>new Hash('sha1'),
    sha224: ()=>new Hash('sha224'),
    sha384: ()=>new Hash('sha384'),
    md5: ()=>new Hash('md5'),
    ripemd160: ()=>new Hash('ripemd160'),
    rmd160: ()=>new Hash('rmd160')
};
const VALID_ACTIONS1 = Object.keys(HASH_OPERATIONS);
const hashRoutes = new Hono();
hashRoutes.get("/", (c)=>{
    return c.text('Hash commands');
});
hashRoutes.get("/:action", (c)=>{
    const input = getCommandInput(c, {
        validActions: VALID_ACTIONS1,
        paramsName: [
            'text'
        ]
    });
    const hasher = HASH_OPERATIONS[input.action]();
    const result = hasher.update(input.params.text).digest('hex');
    return c.json({
        result,
        input
    });
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function getDefaultExportFromNamespaceIfNotNamed(n) {
    return n && Object.prototype.hasOwnProperty.call(n, "default") && Object.keys(n).length === 1 ? n["default"] : n;
}
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var alea = createCommonjsModule(function(module) {
    (function(global2, module2, define) {
        function Alea(seed) {
            var me = this, mash = Mash();
            me.next = function() {
                var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
                me.s0 = me.s1;
                me.s1 = me.s2;
                return me.s2 = t - (me.c = t | 0);
            };
            me.c = 1;
            me.s0 = mash(" ");
            me.s1 = mash(" ");
            me.s2 = mash(" ");
            me.s0 -= mash(seed);
            if (me.s0 < 0) {
                me.s0 += 1;
            }
            me.s1 -= mash(seed);
            if (me.s1 < 0) {
                me.s1 += 1;
            }
            me.s2 -= mash(seed);
            if (me.s2 < 0) {
                me.s2 += 1;
            }
            mash = null;
        }
        function copy(f, t) {
            t.c = f.c;
            t.s0 = f.s0;
            t.s1 = f.s1;
            t.s2 = f.s2;
            return t;
        }
        function impl(seed, opts) {
            var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
            prng.int32 = function() {
                return xg.next() * 4294967296 | 0;
            };
            prng.double = function() {
                return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
            };
            prng.quick = prng;
            if (state) {
                if (typeof state == "object") copy(state, xg);
                prng.state = function() {
                    return copy(xg, {});
                };
            }
            return prng;
        }
        function Mash() {
            var n = 4022871197;
            var mash = function(data) {
                data = String(data);
                for(var i = 0; i < data.length; i++){
                    n += data.charCodeAt(i);
                    var h = 0.02519603282416938 * n;
                    n = h >>> 0;
                    h -= n;
                    h *= n;
                    n = h >>> 0;
                    h -= n;
                    n += h * 4294967296;
                }
                return (n >>> 0) * 23283064365386963e-26;
            };
            return mash;
        }
        if (module2 && module2.exports) {
            module2.exports = impl;
        } else if (define && define.amd) {
            define(function() {
                return impl;
            });
        } else {
            this.alea = impl;
        }
    })(commonjsGlobal, module, false);
});
var xor128 = createCommonjsModule(function(module) {
    (function(global2, module2, define) {
        function XorGen(seed) {
            var me = this, strseed = "";
            me.x = 0;
            me.y = 0;
            me.z = 0;
            me.w = 0;
            me.next = function() {
                var t = me.x ^ me.x << 11;
                me.x = me.y;
                me.y = me.z;
                me.z = me.w;
                return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
            };
            if (seed === (seed | 0)) {
                me.x = seed;
            } else {
                strseed += seed;
            }
            for(var k = 0; k < strseed.length + 64; k++){
                me.x ^= strseed.charCodeAt(k) | 0;
                me.next();
            }
        }
        function copy(f, t) {
            t.x = f.x;
            t.y = f.y;
            t.z = f.z;
            t.w = f.w;
            return t;
        }
        function impl(seed, opts) {
            var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
            };
            prng.double = function() {
                do {
                    var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
                }while (result === 0)
                return result;
            };
            prng.int32 = xg.next;
            prng.quick = prng;
            if (state) {
                if (typeof state == "object") copy(state, xg);
                prng.state = function() {
                    return copy(xg, {});
                };
            }
            return prng;
        }
        if (module2 && module2.exports) {
            module2.exports = impl;
        } else if (define && define.amd) {
            define(function() {
                return impl;
            });
        } else {
            this.xor128 = impl;
        }
    })(commonjsGlobal, module, false);
});
var xorwow = createCommonjsModule(function(module) {
    (function(global2, module2, define) {
        function XorGen(seed) {
            var me = this, strseed = "";
            me.next = function() {
                var t = me.x ^ me.x >>> 2;
                me.x = me.y;
                me.y = me.z;
                me.z = me.w;
                me.w = me.v;
                return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
            };
            me.x = 0;
            me.y = 0;
            me.z = 0;
            me.w = 0;
            me.v = 0;
            if (seed === (seed | 0)) {
                me.x = seed;
            } else {
                strseed += seed;
            }
            for(var k = 0; k < strseed.length + 64; k++){
                me.x ^= strseed.charCodeAt(k) | 0;
                if (k == strseed.length) {
                    me.d = me.x << 10 ^ me.x >>> 4;
                }
                me.next();
            }
        }
        function copy(f, t) {
            t.x = f.x;
            t.y = f.y;
            t.z = f.z;
            t.w = f.w;
            t.v = f.v;
            t.d = f.d;
            return t;
        }
        function impl(seed, opts) {
            var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
            };
            prng.double = function() {
                do {
                    var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
                }while (result === 0)
                return result;
            };
            prng.int32 = xg.next;
            prng.quick = prng;
            if (state) {
                if (typeof state == "object") copy(state, xg);
                prng.state = function() {
                    return copy(xg, {});
                };
            }
            return prng;
        }
        if (module2 && module2.exports) {
            module2.exports = impl;
        } else if (define && define.amd) {
            define(function() {
                return impl;
            });
        } else {
            this.xorwow = impl;
        }
    })(commonjsGlobal, module, false);
});
var xorshift7 = createCommonjsModule(function(module) {
    (function(global2, module2, define) {
        function XorGen(seed) {
            var me = this;
            me.next = function() {
                var X = me.x, i = me.i, t, v;
                t = X[i];
                t ^= t >>> 7;
                v = t ^ t << 24;
                t = X[i + 1 & 7];
                v ^= t ^ t >>> 10;
                t = X[i + 3 & 7];
                v ^= t ^ t >>> 3;
                t = X[i + 4 & 7];
                v ^= t ^ t << 7;
                t = X[i + 7 & 7];
                t = t ^ t << 13;
                v ^= t ^ t << 9;
                X[i] = v;
                me.i = i + 1 & 7;
                return v;
            };
            function init(me2, seed2) {
                var j, w, X = [];
                if (seed2 === (seed2 | 0)) {
                    w = X[0] = seed2;
                } else {
                    seed2 = "" + seed2;
                    for(j = 0; j < seed2.length; ++j){
                        X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
                    }
                }
                while(X.length < 8)X.push(0);
                for(j = 0; j < 8 && X[j] === 0; ++j);
                if (j == 8) w = X[7] = -1;
                else w = X[j];
                me2.x = X;
                me2.i = 0;
                for(j = 256; j > 0; --j){
                    me2.next();
                }
            }
            init(me, seed);
        }
        function copy(f, t) {
            t.x = f.x.slice();
            t.i = f.i;
            return t;
        }
        function impl(seed, opts) {
            if (seed == null) seed = +new Date();
            var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
            };
            prng.double = function() {
                do {
                    var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
                }while (result === 0)
                return result;
            };
            prng.int32 = xg.next;
            prng.quick = prng;
            if (state) {
                if (state.x) copy(state, xg);
                prng.state = function() {
                    return copy(xg, {});
                };
            }
            return prng;
        }
        if (module2 && module2.exports) {
            module2.exports = impl;
        } else if (define && define.amd) {
            define(function() {
                return impl;
            });
        } else {
            this.xorshift7 = impl;
        }
    })(commonjsGlobal, module, false);
});
var xor4096 = createCommonjsModule(function(module) {
    (function(global2, module2, define) {
        function XorGen(seed) {
            var me = this;
            me.next = function() {
                var w = me.w, X = me.X, i = me.i, t, v;
                me.w = w = w + 1640531527 | 0;
                v = X[i + 34 & 127];
                t = X[i = i + 1 & 127];
                v ^= v << 13;
                t ^= t << 17;
                v ^= v >>> 15;
                t ^= t >>> 12;
                v = X[i] = v ^ t;
                me.i = i;
                return v + (w ^ w >>> 16) | 0;
            };
            function init(me2, seed2) {
                var t, v, i, j, w, X = [], limit = 128;
                if (seed2 === (seed2 | 0)) {
                    v = seed2;
                    seed2 = null;
                } else {
                    seed2 = seed2 + "\0";
                    v = 0;
                    limit = Math.max(limit, seed2.length);
                }
                for(i = 0, j = -32; j < limit; ++j){
                    if (seed2) v ^= seed2.charCodeAt((j + 32) % seed2.length);
                    if (j === 0) w = v;
                    v ^= v << 10;
                    v ^= v >>> 15;
                    v ^= v << 4;
                    v ^= v >>> 13;
                    if (j >= 0) {
                        w = w + 1640531527 | 0;
                        t = X[j & 127] ^= v + w;
                        i = t == 0 ? i + 1 : 0;
                    }
                }
                if (i >= 128) {
                    X[(seed2 && seed2.length || 0) & 127] = -1;
                }
                i = 127;
                for(j = 4 * 128; j > 0; --j){
                    v = X[i + 34 & 127];
                    t = X[i = i + 1 & 127];
                    v ^= v << 13;
                    t ^= t << 17;
                    v ^= v >>> 15;
                    t ^= t >>> 12;
                    X[i] = v ^ t;
                }
                me2.w = w;
                me2.X = X;
                me2.i = i;
            }
            init(me, seed);
        }
        function copy(f, t) {
            t.i = f.i;
            t.w = f.w;
            t.X = f.X.slice();
            return t;
        }
        function impl(seed, opts) {
            if (seed == null) seed = +new Date();
            var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
            };
            prng.double = function() {
                do {
                    var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
                }while (result === 0)
                return result;
            };
            prng.int32 = xg.next;
            prng.quick = prng;
            if (state) {
                if (state.X) copy(state, xg);
                prng.state = function() {
                    return copy(xg, {});
                };
            }
            return prng;
        }
        if (module2 && module2.exports) {
            module2.exports = impl;
        } else if (define && define.amd) {
            define(function() {
                return impl;
            });
        } else {
            this.xor4096 = impl;
        }
    })(commonjsGlobal, module, false);
});
var tychei = createCommonjsModule(function(module) {
    (function(global2, module2, define) {
        function XorGen(seed) {
            var me = this, strseed = "";
            me.next = function() {
                var b = me.b, c = me.c, d = me.d, a = me.a;
                b = b << 25 ^ b >>> 7 ^ c;
                c = c - d | 0;
                d = d << 24 ^ d >>> 8 ^ a;
                a = a - b | 0;
                me.b = b = b << 20 ^ b >>> 12 ^ c;
                me.c = c = c - d | 0;
                me.d = d << 16 ^ c >>> 16 ^ a;
                return me.a = a - b | 0;
            };
            me.a = 0;
            me.b = 0;
            me.c = 2654435769 | 0;
            me.d = 1367130551;
            if (seed === Math.floor(seed)) {
                me.a = seed / 4294967296 | 0;
                me.b = seed | 0;
            } else {
                strseed += seed;
            }
            for(var k = 0; k < strseed.length + 20; k++){
                me.b ^= strseed.charCodeAt(k) | 0;
                me.next();
            }
        }
        function copy(f, t) {
            t.a = f.a;
            t.b = f.b;
            t.c = f.c;
            t.d = f.d;
            return t;
        }
        function impl(seed, opts) {
            var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
            };
            prng.double = function() {
                do {
                    var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
                }while (result === 0)
                return result;
            };
            prng.int32 = xg.next;
            prng.quick = prng;
            if (state) {
                if (typeof state == "object") copy(state, xg);
                prng.state = function() {
                    return copy(xg, {});
                };
            }
            return prng;
        }
        if (module2 && module2.exports) {
            module2.exports = impl;
        } else if (define && define.amd) {
            define(function() {
                return impl;
            });
        } else {
            this.tychei = impl;
        }
    })(commonjsGlobal, module, false);
});
var _nodeResolve_empty = {};
var _nodeResolve_empty$1 = Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
});
var require$$0 = getDefaultExportFromNamespaceIfNotNamed(_nodeResolve_empty$1);
var seedrandom = createCommonjsModule(function(module) {
    (function(global2, pool, math) {
        var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom2(seed, options, callback) {
            var key = [];
            options = options == true ? {
                entropy: true
            } : options || {};
            var shortseed = mixkey(flatten(options.entropy ? [
                seed,
                tostring(pool)
            ] : seed == null ? autoseed() : seed, 3), key);
            var arc4 = new ARC4(key);
            var prng = function() {
                var n = arc4.g(chunks), d = startdenom, x = 0;
                while(n < significance){
                    n = (n + x) * width;
                    d *= width;
                    x = arc4.g(1);
                }
                while(n >= overflow){
                    n /= 2;
                    d /= 2;
                    x >>>= 1;
                }
                return (n + x) / d;
            };
            prng.int32 = function() {
                return arc4.g(4) | 0;
            };
            prng.quick = function() {
                return arc4.g(4) / 4294967296;
            };
            prng.double = prng;
            mixkey(tostring(arc4.S), pool);
            return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
                if (state) {
                    if (state.S) {
                        copy(state, arc4);
                    }
                    prng2.state = function() {
                        return copy(arc4, {});
                    };
                }
                if (is_math_call) {
                    math[rngname] = prng2;
                    return seed2;
                } else return prng2;
            })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
        }
        function ARC4(key) {
            var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
            if (!keylen) {
                key = [
                    keylen++
                ];
            }
            while(i < width){
                s[i] = i++;
            }
            for(i = 0; i < width; i++){
                s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
                s[j] = t;
            }
            (me.g = function(count) {
                var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
                while(count--){
                    t2 = s2[i2 = mask & i2 + 1];
                    r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
                }
                me.i = i2;
                me.j = j2;
                return r;
            })(width);
        }
        function copy(f, t) {
            t.i = f.i;
            t.j = f.j;
            t.S = f.S.slice();
            return t;
        }
        function flatten(obj, depth) {
            var result = [], typ = typeof obj, prop;
            if (depth && typ == "object") {
                for(prop in obj){
                    try {
                        result.push(flatten(obj[prop], depth - 1));
                    } catch (e) {}
                }
            }
            return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
            var stringseed = seed + "", smear, j = 0;
            while(j < stringseed.length){
                key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
            }
            return tostring(key);
        }
        function autoseed() {
            try {
                var out;
                if (nodecrypto && (out = nodecrypto.randomBytes)) {
                    out = out(width);
                } else {
                    out = new Uint8Array(width);
                    (global2.crypto || global2.msCrypto).getRandomValues(out);
                }
                return tostring(out);
            } catch (e) {
                var browser = global2.navigator, plugins = browser && browser.plugins;
                return [
                    +new Date(),
                    global2,
                    plugins,
                    global2.screen,
                    tostring(pool)
                ];
            }
        }
        function tostring(a) {
            return String.fromCharCode.apply(0, a);
        }
        mixkey(math.random(), pool);
        if (module.exports) {
            module.exports = seedrandom2;
            try {
                nodecrypto = require$$0;
            } catch (ex) {}
        } else {
            math["seed" + rngname] = seedrandom2;
        }
    })(typeof self !== "undefined" ? self : commonjsGlobal, [], Math);
});
seedrandom.alea = alea;
seedrandom.xor128 = xor128;
seedrandom.xorwow = xorwow;
seedrandom.xorshift7 = xorshift7;
seedrandom.xor4096 = xor4096;
seedrandom.tychei = tychei;
var seedrandom$1 = seedrandom;
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
        if (!getRandomValues) {
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
    }
    return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for(var i1 = 0; i1 < 256; ++i1){
    byteToHex.push((i1 + 256).toString(16).substr(1));
}
function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
        throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
}
function parse5(uuid) {
    if (!validate(uuid)) {
        throw TypeError("Invalid UUID");
    }
    var v;
    var arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
}
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    var bytes = [];
    for(var i = 0; i < str.length; ++i){
        bytes.push(str.charCodeAt(i));
    }
    return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
            value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
            namespace = parse5(namespace);
        }
        if (namespace.length !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        var bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version2;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
            offset = offset || 0;
            for(var i = 0; i < 16; ++i){
                buf[offset + i] = bytes[i];
            }
            return buf;
        }
        return stringify(bytes);
    }
    try {
        generateUUID.name = name;
    } catch (err) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL1;
    return generateUUID;
}
function md5(bytes) {
    if (typeof bytes === "string") {
        var msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for(var i = 0; i < msg.length; ++i){
            bytes[i] = msg.charCodeAt(i);
        }
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
    var output = [];
    var length32 = input.length * 32;
    var hexTab = "0123456789abcdef";
    for(var i = 0; i < length32; i += 8){
        var x = input[i >> 5] >>> i % 32 & 255;
        var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
    }
    return output;
}
function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
    x[len >> 5] |= 128 << len % 32;
    x[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for(var i = 0; i < x.length; i += 16){
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
    }
    return [
        a,
        b,
        c,
        d
    ];
}
function bytesToWords(input) {
    if (input.length === 0) {
        return [];
    }
    var length8 = input.length * 8;
    var output = new Uint32Array(getOutputLength(length8));
    for(var i = 0; i < length8; i += 8){
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
    }
    return output;
}
function safeAdd(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
v35("v3", 48, md5);
function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
        offset = offset || 0;
        for(var i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return stringify(rnds);
}
function f(s, x, y, z) {
    switch(s){
        case 0:
            return x & y ^ ~x & z;
        case 1:
            return x ^ y ^ z;
        case 2:
            return x & y ^ x & z ^ y & z;
        case 3:
            return x ^ y ^ z;
    }
}
function ROTL(x, n) {
    return x << n | x >>> 32 - n;
}
function sha1(bytes) {
    var K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ];
    var H = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ];
    if (typeof bytes === "string") {
        var msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for(var i = 0; i < msg.length; ++i){
            bytes.push(msg.charCodeAt(i));
        }
    } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
    }
    bytes.push(128);
    var l = bytes.length / 4 + 2;
    var N = Math.ceil(l / 16);
    var M = new Array(N);
    for(var _i = 0; _i < N; ++_i){
        var arr = new Uint32Array(16);
        for(var j = 0; j < 16; ++j){
            arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
        }
        M[_i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
    for(var _i2 = 0; _i2 < N; ++_i2){
        var W = new Uint32Array(80);
        for(var t = 0; t < 16; ++t){
            W[t] = M[_i2][t];
        }
        for(var _t = 16; _t < 80; ++_t){
            W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
        }
        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4];
        for(var _t2 = 0; _t2 < 80; ++_t2){
            var s = Math.floor(_t2 / 20);
            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
    }
    return [
        H[0] >> 24 & 255,
        H[0] >> 16 & 255,
        H[0] >> 8 & 255,
        H[0] & 255,
        H[1] >> 24 & 255,
        H[1] >> 16 & 255,
        H[1] >> 8 & 255,
        H[1] & 255,
        H[2] >> 24 & 255,
        H[2] >> 16 & 255,
        H[2] >> 8 & 255,
        H[2] & 255,
        H[3] >> 24 & 255,
        H[3] >> 16 & 255,
        H[3] >> 8 & 255,
        H[3] & 255,
        H[4] >> 24 & 255,
        H[4] >> 16 & 255,
        H[4] >> 8 & 255,
        H[4] & 255
    ];
}
v35("v5", 80, sha1);
let prng = seedrandom$1();
function random() {
    return prng();
}
function fake(data2, options) {
    const dataSource = Array.isArray(data2) ? ()=>randElement(data2) : data2;
    if ((options == null ? void 0 : options.length) === void 0) {
        return dataSource(0);
    }
    return Array.from({
        length: options.length
    }, (_, index)=>dataSource(index));
}
function randElement(arr) {
    return arr[Math.floor(random() * arr.length)];
}
function getRandomInRange({ min =1 , max =9999.99 , fraction =0  } = {}) {
    return Number((random() * (max - min) + min).toFixed(fraction));
}
const numericChars = "0123456789";
const alphaChars = "abcdefghijklmnopqrstuvwxyz";
`${numericChars}${alphaChars}${alphaChars.toUpperCase()}`;
function randBoolean(options) {
    return fake(()=>randElement([
            true,
            false
        ]), options);
}
function isNil(value) {
    return value === null || typeof value === "undefined";
}
function randNumber(options) {
    const normalized = {
        min: isNil(options == null ? void 0 : options.min) ? 0 : options.min,
        max: isNil(options == null ? void 0 : options.max) ? 999999 : options.max,
        precision: options == null ? void 0 : options.precision,
        fraction: options == null ? void 0 : options.fraction
    };
    return fake(()=>{
        if (normalized.min === normalized.max) {
            return normalized.min;
        }
        const num = getRandomInRange(normalized);
        if (normalized.precision !== void 0) {
            return Math.floor(num / normalized.precision) * normalized.precision;
        }
        return num;
    }, options);
}
function rand(arr, options) {
    return fake(arr, options);
}
var data$1j = [
    "org",
    "biz",
    "com",
    "net",
    "name",
    "info",
    "io",
    "dev"
];
function randDomainSuffix(options) {
    return fake(data$1j, options);
}
var data$1g = [
    "aim",
    "alice",
    "aliceadsl",
    "aol",
    "arcor",
    "att",
    "bellsouth",
    "bigpond",
    "bluewin",
    "blueyonder",
    "bol",
    "centurytel",
    "charter",
    "chello",
    "club-internet",
    "comcast",
    "earthlink",
    "facebook",
    "free",
    "freenet",
    "frontiernet",
    "gmail",
    "gmx",
    "googlemail",
    "hetnet",
    "home",
    "hotmail",
    "ig",
    "juno",
    "laposte",
    "libero",
    "live",
    "mac",
    "mail",
    "me",
    "msn",
    "neuf",
    "ntlworld",
    "optonline",
    "optusnet",
    "orange",
    "outlook",
    "planet",
    "qq",
    "rambler",
    "rediffmail",
    "rocketmail",
    "sbcglobal",
    "sfr",
    "shaw",
    "sky",
    "skynet",
    "sympatico",
    "t-online",
    "telenet",
    "terra",
    "tin",
    "tiscali",
    "unaref",
    "uol",
    "verizon",
    "virgilio",
    "voila",
    "wanadoo",
    "web",
    "windstream",
    "yahoo",
    "yandex",
    "zonnet"
];
function randEmailProvider(options) {
    return fake(data$1g, options);
}
var data$1f = {
    withAccents: {
        male: [
            "Adri\xE1n",
            "\xC6gir",
            "\xC1lvaro",
            "Andr\xE9",
            "Andr\xE9s",
            "\xC1rni",
            "Asbj\xF8rn",
            "Bj\xF6rn",
            "C\xE9sar",
            "Dan\xEDel",
            "Dav\xED\xF0",
            "Em\xEDlio",
            "Fa\xF1ch",
            "Fran\xE7ois",
            "Franti\u0161ek",
            "G\xEDsli",
            "G\xF6tz",
            "Gu\xF0j\xF3n",
            "Gu\xF0mundur",
            "G\xFCnter",
            "Halld\xF3r",
            "Hans-J\xF6rg",
            "Hans-J\xFCrgen",
            "H\xFCseyin",
            "I\xF1aki",
            "J\xE1nos",
            "Jes\xFAs",
            "Ji\u0159\xED",
            "J\xF3hann",
            "J\xF3hannes",
            "Jok\u016Bbas",
            "J\xF3n",
            "Jos\xE9",
            "J\xF6rn",
            "Juli\xE3o",
            "J\xFCrgen",
            "Kristj\xE1n",
            "Ma\xEBl",
            "Magn\xFAs",
            "Math\xE9o",
            "M\xE1ty\xE1s",
            "Micha\u0142",
            "No\xEBl",
            "Nu\xF1ez",
            "\xD3lafur",
            "\xD3scar",
            "\xD8yvind",
            "P\xE1ll",
            "Pawe\u0142",
            "P\xE9tur",
            "Ram\xF3n",
            "Ra\xFAl",
            "Ren\xE9",
            "Ruair\xED",
            "Rub\xE9n",
            "Se\xE1n",
            "S\xE9rgio",
            "Sigur\xF0ur",
            "S\xF6nke",
            "Stef\xE1n",
            "Tom\xE1\u0161",
            "\xDEorsteinn"
        ],
        female: [
            "\xC6del",
            "Agn\xE8s",
            "Al\xEDcia",
            "\xC4nne",
            "Ant\xF3nia",
            "\xC1sta",
            "Au\xF0ur",
            "C\xE4cilia",
            "Chlo\xEB",
            "Cla\xFAdia",
            "D\xF6rte",
            "El\xEDn",
            "El\xEDsabet",
            "Eli\u0161ka",
            "Franti\u0161ka",
            "Gl\xF3ria",
            "Gra\u017Cyna",
            "Gu\xF0bj\xF6rg",
            "Gu\xF0n\xFD",
            "Gu\xF0r\xFAn",
            "Henri\xEBtte",
            "Ingibj\xF6rg",
            "\xCDris",
            "J\xF3hanna",
            "J\xF3na",
            "J\xFAlia",
            "K\xE4te",
            "Katr\xEDn",
            "Kolbr\xFAn",
            "Krist\xEDn",
            "K\u0160the",
            "Let\xEDcia",
            "L\xEDdia",
            "L\xFAcia",
            "Ma\u0142gorzata",
            "Margr\xE9t",
            "Mar\xEDa",
            "M\xF3nica",
            "Nat\xE1lia",
            "\xD3l\xF6f",
            "Patr\xEDcia",
            "Ragnhei\xF0ur",
            "Ren\xE9e",
            "Ru\u017Eena",
            "Si\xE2n",
            "Sigr\xED\xF0ur",
            "Sigr\xFAn",
            "S\xEDlvia",
            "S\xF8rina",
            "V\u011Bra",
            "Virg\xEDnia",
            "Zo\xEB",
            "\xDE\xF3ra",
            "\xDE\xF3runn"
        ]
    },
    withoutAccents: {
        male: [
            "Abdul",
            "Abdullahi",
            "Abubakar",
            "Adam",
            "Adamu",
            "Adiy",
            "Ahmad",
            "Ajay",
            "Akira",
            "Alan",
            "Alberto",
            "Alejandro",
            "Aleksander",
            "Aleksandr",
            "Aleksey",
            "Alex",
            "Alexander",
            "Alexey",
            "Ali",
            "Aliyu",
            "Aminu",
            "Amit",
            "Amiyr",
            "Amiyt",
            "Amnuai",
            "Amphon",
            "Anah",
            "Anan",
            "Andreas",
            "Andrew",
            "Andrey",
            "Andri",
            "Andries",
            "Andrzej",
            "Anil",
            "Anthony",
            "Anton",
            "Antonio",
            "Arnar",
            "Artur",
            "Artyom",
            "Arun",
            "Ashok",
            "Atli",
            "Avraham",
            "Bartosz",
            "Bello",
            "Bernd",
            "Bin",
            "Birgir",
            "Bjarni",
            "Blessing",
            "Bongani",
            "Brian",
            "Bunmi",
            "Carlos",
            "Carol",
            "Chan",
            "Chao",
            "Charles",
            "Charoen",
            "Chen",
            "Cheng",
            "Christian",
            "Christopher",
            "Colin",
            "Daniel",
            "Daniyel",
            "Dariusz",
            "David",
            "Denis",
            "Dennis",
            "Diego",
            "Dieter",
            "Dilip",
            "Dinesh",
            "Dmitriy",
            "Dmitry",
            "Einar",
            "Eliyahu",
            "Emmanuel",
            "Evgeniy",
            "Fernando",
            "Fran",
            "Francis",
            "Francisco",
            "Francisco-Javier",
            "Frank",
            "Franz",
            "Gang",
            "Gareth",
            "Gary",
            "George",
            "Gerhard",
            "Graham",
            "Grzegorz",
            "Gunnar",
            "Guy",
            "Haim",
            "Haiyan",
            "Hans",
            "Hans-Ulrich",
            "Haruna",
            "Hassan",
            "Heike",
            "Heinz",
            "Helgi",
            "Helmut",
            "Hendrik",
            "Herbert",
            "Hideo",
            "Hiromi",
            "Hiroshi",
            "Hong",
            "Horst",
            "Hui",
            "Ian",
            "Ibrahim",
            "Idris",
            "Igor",
            "Ilya",
            "Isa",
            "Isaac",
            "Isah",
            "Ivan",
            "Jabulani",
            "Jacek",
            "Jacobus",
            "Jakub",
            "James",
            "Jan",
            "Janusz",
            "Javier",
            "Jean",
            "Jerzy",
            "Jesus",
            "Jason",
            "Jianguo",
            "Jianhua",
            "Jianjun",
            "Jianping",
            "Jin",
            "Joan",
            "Johan",
            "Johannes",
            "John",
            "Jonathan",
            "Jorge",
            "Jose",
            "Jose-Antonio",
            "Jose-Luis",
            "Jose-Manuel",
            "Jose-Maria",
            "Josef",
            "Joseph",
            "Joyce",
            "Juan",
            "Kabiru",
            "Kai",
            "Kamil",
            "Karen",
            "Karl",
            "Karl-Heinz",
            "Katsumi",
            "Kazuo",
            "Kelvin",
            "Kenji",
            "Kenneth",
            "Kevin",
            "Kiran",
            "Kirill",
            "Kiyoshi",
            "Kjartan",
            "Klaus",
            "Ko",
            "Koichi",
            "Koji",
            "Konstantin",
            "Koshi",
            "Krishna",
            "Kristinn",
            "Krzysztof",
            "Kun",
            "Lakshmi",
            "Lan",
            "Laxmi",
            "Lei",
            "Li",
            "Lihua",
            "Lijun",
            "Lilian",
            "Lin",
            "Ling",
            "Liping",
            "Liyor",
            "Luis",
            "Lukasz",
            "Maciej",
            "Mahmood",
            "Maksim",
            "Manfred",
            "Manoj",
            "Manuel",
            "Marcin",
            "Mardkhay",
            "Marek",
            "Mariusz",
            "Mark",
            "Martin",
            "Masami",
            "Masao",
            "Mateusz",
            "Matt",
            "Matthew",
            "Meiyr",
            "Michael",
            "Michal",
            "Miguel",
            "Miguel-Angel",
            "Mikhail",
            "Min",
            "Ming",
            "Mitsuo",
            "Miykhael",
            "Miykhal",
            "Mo",
            "Mohamed",
            "Mohammad",
            "Mohammed",
            "Mohan",
            "Moses",
            "Moshe",
            "Mpho",
            "Muhammad",
            "Muhammed",
            "Mukesh",
            "Musa",
            "Narong",
            "Nathan",
            "Nicola",
            "Nikita",
            "Nikolay",
            "Ning",
            "Nkosinathi",
            "Noam",
            "Oleg",
            "Omer",
            "Otieno",
            "Pablo",
            "Patrick",
            "Paul",
            "Pavel",
            "Pawel",
            "Pedro",
            "Peng",
            "Peter",
            "Petrus",
            "Philip",
            "Pieter",
            "Ping",
            "Piotr",
            "Prasit",
            "Prasoet",
            "Pricha",
            "Pushpa",
            "Qiang",
            "Qing",
            "Radha",
            "Rafael",
            "Ragnar",
            "Raj",
            "Rajendra",
            "Rajesh",
            "Raju",
            "Rakesh",
            "Ram",
            "Ramesh",
            "Raphael",
            "Rattana",
            "Ravi",
            "Richard",
            "Robert",
            "Roman",
            "Rong",
            "Roy",
            "Ryan",
            "Salisu",
            "Saman",
            "Samran",
            "Samuel",
            "Sani",
            "Sanjay",
            "Santosh",
            "Sam",
            "Sammy",
            "Sawat",
            "Sebastian",
            "Sergey",
            "Sergio",
            "Shankar",
            "Shay",
            "Shigeru",
            "Shimon",
            "Shlomo",
            "Shoji",
            "Sibusiso",
            "Simon",
            "Sipho",
            "Sombat",
            "Sombun",
            "Somchai",
            "Somchit",
            "Somkhit",
            "Somkiat",
            "Sommai",
            "Somnuek",
            "Somphon",
            "Somphong",
            "Somsak",
            "Sri",
            "Stefan",
            "Stephen",
            "Steve",
            "Steven",
            "Suman",
            "Sunday",
            "Sunil",
            "Sunthon",
            "Suresh",
            "Sushila",
            "Suwit",
            "Sveinn",
            "Tadashi",
            "Takashi",
            "Takeshi",
            "Tal",
            "Tebogo",
            "Thabo",
            "Thawi",
            "Themba",
            "Thomas",
            "Thulani",
            "Tomasz",
            "Toshio",
            "Udom",
            "Umar",
            "Uriy",
            "Usman",
            "Uwe",
            "Victor",
            "Vijay",
            "Viktor",
            "Vincent",
            "Vinod",
            "Vladimir",
            "Walter",
            "Wanchai",
            "Waraphon",
            "Wei",
            "Werner",
            "Wichai",
            "Wichian",
            "Willem",
            "William",
            "Winai",
            "Wirat",
            "Wirot",
            "Wojciech",
            "Wolfgang",
            "Xiang",
            "Xiaohong",
            "Xiaoli",
            "Xiaoping",
            "Xiaoyan",
            "Xin",
            "Xolani",
            "Yaakv",
            "Yahaya",
            "Yakubu",
            "Yan",
            "Yasuo",
            "Yhudah",
            "Ying",
            "Yisrael",
            "Yong",
            "Yosef",
            "Yoshie",
            "Yoshimi",
            "Yoshio",
            "Yu",
            "Yue",
            "Yukio",
            "Yun",
            "Yuriy",
            "Yusuf",
            "Yuval",
            "Zbigniew",
            "Zhen",
            "Zhiqiang"
        ],
        female: [
            "Agata",
            "Agnieszka",
            "Aisha",
            "Akira",
            "Aleksandra",
            "Alina",
            "Alyona",
            "Amina",
            "Amnuai",
            "Ana",
            "Ana-Maria",
            "Anah",
            "Anan",
            "Anastasiya",
            "Andrea",
            "Angela",
            "Anita",
            "Ann",
            "Anna",
            "Anong",
            "Antonia",
            "Asha",
            "Barbara",
            "Beata",
            "Berglind",
            "Bin",
            "Birgit",
            "Birna",
            "Blessing",
            "Brigitte",
            "Bunmi",
            "Busisiwe",
            "Carmen",
            "Carol",
            "Caroline",
            "Catherine",
            "Chan",
            "Chanah",
            "Chao",
            "Charoen",
            "Chayah",
            "Chen",
            "Cheng",
            "Christa",
            "Christine",
            "Claire",
            "Claudia",
            "Cristina",
            "Darya",
            "Dolores",
            "Dorota",
            "Edda",
            "Ekaterina",
            "Elena",
            "Elisabeth",
            "Elizabeth",
            "Elke",
            "Emiko",
            "Emma",
            "Erika",
            "Erla",
            "Erna",
            "Ester",
            "Esther",
            "Eunice",
            "Eva",
            "Eugenia",
            "Ewa",
            "Faith",
            "Fatima",
            "Fiona",
            "Fran",
            "Francisca",
            "Fumiko",
            "Galina",
            "Gabra",
            "Gisela",
            "Gita",
            "Grace",
            "Hadiza",
            "Haiyan",
            "Hanna",
            "Haruna",
            "Hauwa",
            "Heike",
            "Helen",
            "Helga",
            "Hildur",
            "Hiroko",
            "Hiromi",
            "Hisako",
            "Hong",
            "Hui",
            "Hulda",
            "Inga",
            "Ingrid",
            "Irina",
            "Isa",
            "Isabel",
            "Isah",
            "Iwona",
            "Jackline",
            "Jan",
            "Jane",
            "Janet",
            "Jean",
            "Jennifer",
            "Jianhua",
            "Jianping",
            "Jin",
            "Joan",
            "Joanna",
            "Johanna",
            "Josefa",
            "Joy",
            "Joyce",
            "Juan",
            "Julie",
            "Justyna",
            "Kai",
            "Kanchana",
            "Karen",
            "Karin",
            "Karolina",
            "Kasia",
            "Katarzyna",
            "Katsumi",
            "Keiko",
            "Kiran",
            "Kiyoko",
            "Kristina",
            "Kseniya",
            "Kun",
            "Lakshmi",
            "Lalita",
            "Lan",
            "Latda",
            "Laura",
            "Laxmi",
            "Leah",
            "Lei",
            "Li",
            "Lihua",
            "Lijun",
            "Lilian",
            "Lilja",
            "Lin",
            "Linda",
            "Lindiwe",
            "Ling",
            "Liping",
            "Lisa",
            "Lucia",
            "Lucy",
            "Lyubov",
            "Lyudmila",
            "Magda",
            "Magdalena",
            "Mali",
            "Manju",
            "Margaret",
            "Maria",
            "Maria-Isabel",
            "Maria-Jose",
            "Maria-Pilar",
            "Marina",
            "Mariya",
            "Marta",
            "Martha",
            "Mary",
            "Maryam",
            "Masako",
            "Masami",
            "Mei",
            "Mercy",
            "Michal",
            "Michiko",
            "Mieko",
            "Min",
            "Mina",
            "Ming",
            "Miriam",
            "Miyoko",
            "Mo",
            "Monika",
            "Mpho",
            "Na",
            "Nadezhda",
            "Nan",
            "Nancy",
            "Natalya",
            "Ngozi",
            "Nicola",
            "Ning",
            "Nittaya",
            "Noam",
            "Nobuko",
            "Nokuthula",
            "Nonhlanhla",
            "Noriko",
            "Nushi",
            "Olga",
            "Omer",
            "Patricia",
            "Paula",
            "Paulina",
            "Peng",
            "Petra",
            "Phonthip",
            "Pilar",
            "Ping",
            "Prani",
            "Purity",
            "Pushpa",
            "Qing",
            "Rachel",
            "Radha",
            "Rattana",
            "Rebecca",
            "Reiko",
            "Rekha",
            "Renate",
            "Rita",
            "Rong",
            "Rosa",
            "Rose",
            "Rut",
            "Ruth",
            "Ryoko",
            "Sabine",
            "Sachiko",
            "Samran",
            "Santosh",
            "Sara",
            "Sarah",
            "Sam",
            "Sammy",
            "Sawat",
            "Shanti",
            "Sharon",
            "Shay",
            "Shizuko",
            "Shoshanah",
            "Sibongile",
            "Sita",
            "Sombat",
            "Sombun",
            "Somchit",
            "Somkhit",
            "Sommai",
            "Somnuek",
            "Somphon",
            "Somphong",
            "Sri",
            "Steinunn",
            "Sukanya",
            "Suman",
            "Sunday",
            "Sunita",
            "Suphaphon",
            "Susan",
            "Susanne",
            "Sushila",
            "Svetlana",
            "Takako",
            "Tamar",
            "Tatyana",
            "Tal",
            "Tebogo",
            "Teruko",
            "Thawi",
            "Tomiko",
            "Toshiko",
            "Unnur",
            "Urai",
            "Urmila",
            "Ursula",
            "Usha",
            "Valentina",
            "Victoria",
            "Wanjiru",
            "Wanphen",
            "Watsana",
            "Wei",
            "Wilai",
            "Xiang",
            "Xiaohong",
            "Xiaoli",
            "Xiaoping",
            "Xiaoyan",
            "Xin",
            "Yael",
            "Yan",
            "Yasuko",
            "Yelena",
            "Yhudiyt",
            "Ying",
            "Yoko",
            "Yong",
            "Yoshie",
            "Yoshiko",
            "Yoshimi",
            "Yu",
            "Yue",
            "Yuko",
            "Yuliya",
            "Yun",
            "Yuval",
            "Zainab",
            "Zandile",
            "Zanele",
            "Zhen"
        ]
    }
};
function randFirstName(options) {
    var _options$withAccents, _options$gender;
    const withAccents = (_options$withAccents = options == null ? void 0 : options.withAccents) != null ? _options$withAccents : false;
    const gender = (_options$gender = options == null ? void 0 : options.gender) != null ? _options$gender : rand([
        "male",
        "female"
    ]);
    const locale = options == null ? void 0 : options.locale;
    const names = withAccents ? locale ? locale == null ? void 0 : locale.withAccents[gender] : data$1f.withAccents[gender] : locale ? locale == null ? void 0 : locale.withoutAccents[gender] : data$1f.withoutAccents[gender];
    return fake(names, options);
}
var data$1e = {
    withAccents: [
        "\xC6bel\xF8",
        "\xC6beltoft",
        "\xC1g\xFAstsd\xF3ttir",
        "\xC1g\xFAstsson",
        "\xC1lvarez",
        "\xC1rnad\xF3ttir",
        "\xC1rnason",
        "\xC1sgeirsd\xF3ttir",
        "\xC3shaikh",
        "Bene\u0161",
        "Bene\u0161ov\xE1",
        "Baldursd\xF3ttir",
        "Birgisd\xF3ttir",
        "Bjarnad\xF3ttir",
        "Bj\xF6rnsd\xF3ttir",
        "Bj\xF6rnsson",
        "B\xF6ttcher",
        "\u010Cern\xE1",
        "\u010Cern\xFD",
        "Ch\xE1vez",
        "\xD0eki\u0107",
        "D\xEDaz",
        "\xD0or\xF0i\u0107",
        "Dvo\u0159\xE1k",
        "Dvo\u0159\xE1kov\xE1",
        "Einarsd\xF3ttir",
        "Fern\xE1ndez",
        "Fialov\xE1",
        "F\xF6rster",
        "Fri\xF0riksson",
        "Fr\xF6hlich",
        "Garc\xEDa",
        "G\xEDslad\xF3ttir",
        "G\xEDslason",
        "G\xF6bel",
        "G\xF3mez",
        "Gro\xDF",
        "Gunnarsd\xF3ttir",
        "Gu\xF0j\xF3nsd\xF3ttir",
        "Gu\xF0j\xF3nsson",
        "Gu\xF0mundsd\xF3ttir",
        "Gu\xF0mundsson",
        "G\xFCnther",
        "Halld\xF3rsd\xF3ttir",
        "Halld\xF3rsson",
        "Guti\xE9rrez",
        "Guzm\xE1n",
        "H\xE1jek",
        "Haraldsd\xF3ttir",
        "Har\xF0ard\xF3ttir",
        "Har\xF0arson",
        "Helgad\xF3ttir",
        "Hern\xE1ndez",
        "Hauksd\xF3ttir",
        "Hor\xE1k",
        "Hor\xE1kov\xE1",
        "Jab\u0142o\u0144ski",
        "J\xE4ger",
        "Jasi\u0144ski",
        "Jim\xE9nez",
        "J\xF3hannesd\xF3ttir",
        "J\xF3hannesson",
        "J\xF3hannsd\xF3ttir",
        "J\xF3hannsson",
        "J\xF3nasd\xF3ttir",
        "J\xF3nasson",
        "J\xF3nsd\xF3ttir",
        "J\xF3nsson",
        "Kami\u0144ski",
        "Karlsd\xF3ttir",
        "Kjartansd\xF3ttir",
        "K\xF6hler",
        "K\xF6nig",
        "Koz\u0142owski",
        "Kr\xE1lov\xE1",
        "Krej\u010D\xED",
        "Kristinsd\xF3ttir",
        "Kristj\xE1nsd\xF3ttir",
        "Kristj\xE1nsson",
        "Kr\xFCger",
        "Ku\u010Dera",
        "Ku\u010Derov\xE1",
        "\u0141api\u0144ski",
        "L\xF6ffler",
        "L\xF3pez",
        "\u0141uczak",
        "\u0141ukaszewski",
        "Magn\xFAsd\xF3ttir",
        "Magn\xFAsson",
        "Markov\xE1",
        "Mart\xEDnez",
        "Mei\xDFner",
        "M\xE9ndez",
        "M\xF6ller",
        "M\xFCller",
        "Mu\xF1oz",
        "Nov\xE1k",
        "Nov\xE1kov\xE1",
        "Novotn\xE1",
        "Novotn\xFD",
        "Nu\xF1ez",
        "N\xFA\xF1ez",
        "\xD8deg\xE5rd",
        "\u0150hlschl\xE4gerov\xE1",
        "\xD3lafsd\xF3ttir",
        "\xD3lafsson",
        "\u0150ll\xF6sov\xE1",
        "Olszewski",
        "\u0150ri",
        "\u0150rs\xE9gi-Z\xF6lderd\u0151",
        "\xD3skarsd\xF3ttir",
        "\xD3skarsson",
        "\xD8verg\xE5rd",
        "\u0150zse",
        "P\xE1lsd\xF3ttir",
        "P\xE1lsson",
        "Paw\u0142owski",
        "Pe\xF1a",
        "P\xE9rez",
        "P\xE9tursd\xF3ttir",
        "P\xE9tursson",
        "Pokorn\xE1",
        "Pokorn\xFD",
        "Posp\xED\u0161il",
        "Posp\xED\u0161ilov\xE1",
        "Proch\xE1zka",
        "Proch\xE1zkov\xE1",
        "Ragnarsd\xF3ttir",
        "Ram\xEDrez",
        "R\xEDos",
        "Rodr\xEDguez",
        "S\xE1nchez",
        "Sch\xE4fer",
        "Schr\xF6der",
        "Sch\xFCtz",
        "Sigur\xF0ard\xF3ttir",
        "Sigur\xF0sson",
        "Sigurj\xF3nsd\xF3ttir",
        "Sigurj\xF3nsson",
        "Soko\u0142owski",
        "Stef\xE1nsd\xF3ttir",
        "Stef\xE1nsson",
        "Sveinsd\xF3ttir",
        "Svobodov\xE1",
        "Szczepa\u0144ski",
        "Szyma\u0144ski",
        "Urba\u0144ski",
        "\u016Asas",
        "\u016A\u017Eien",
        "V\xE1squez",
        "Vesel\xE1",
        "Vesel\xFD",
        "Wei\xDF",
        "\u017Bak",
        "\u017D\xE1kov\xE1",
        "Zemanov\xE1",
        "Zieli\u0144ski",
        "\u017Dukauskas",
        "\u017Dukauskien\u0117",
        "\xDE\xF3r\xF0ard\xF3ttir",
        "\xDE\xF3r\xF0arson",
        "\xDEorsteinsd\xF3ttir",
        "\xDEorsteinsson"
    ],
    withoutAccents: [
        "Abdi",
        "Abdullahi",
        "Abe",
        "Abubakar",
        "Achieng",
        "Adamczyk",
        "Adamu",
        "Adan",
        "Adebayo",
        "Adhiambo",
        "Adri",
        "Agbaria",
        "Aguilar",
        "Ahmad",
        "Ahmed",
        "Akinyi",
        "Akpan",
        "Ali",
        "Aliev",
        "Aliyu",
        "Allen",
        "Alonso",
        "Alvarez",
        "Amadi",
        "Aminu",
        "Andreev",
        "Andreeva",
        "Ansari",
        "Anyango",
        "Aoki",
        "Arai",
        "Arnarson",
        "Ashknaziy",
        "Atieno",
        "Attias",
        "Audu",
        "Avraham",
        "Ayutthaya",
        "Azulay",
        "Baba",
        "Bai",
        "Bailey",
        "Baker",
        "Bakker",
        "Bala",
        "Baldursson",
        "Baloyi",
        "Baran",
        "Barasa",
        "Barman",
        "Bauer",
        "Becker",
        "Begam",
        "Begum",
        "Behera",
        "Bekher",
        "Bello",
        "Bennett",
        "Ber",
        "Bevan",
        "Bibi",
        "Birgisson",
        "Biswas",
        "Bitton",
        "Bjarnason",
        "Blanco",
        "Blom",
        "Borkowski",
        "Bos",
        "Botha",
        "Bowen",
        "Braun",
        "Brouwer",
        "Brown",
        "Bunma",
        "Bunmi",
        "Bunsi",
        "Buthelezi",
        "Cai",
        "Cano",
        "Cao",
        "Carter",
        "Castillo",
        "Castro",
        "Cele",
        "Ceng",
        "Chaichana",
        "Chand",
        "Chanthara",
        "Chauke",
        "Chebet",
        "Chen",
        "Cheng",
        "Chepkemoi",
        "Cherinsuk",
        "Cheruiyot",
        "Chided",
        "Chmielewski",
        "Chukwu",
        "Clark",
        "Clarke",
        "Coetzee",
        "Cohen",
        "Collins",
        "Cook",
        "Cooper",
        "Cortes",
        "Cruz",
        "Cui",
        "Czarnecki",
        "Dahan",
        "Dai",
        "Das",
        "Dauda",
        "David",
        "Davies",
        "Davis",
        "Dayan",
        "De-Bruijn",
        "De-Graaf",
        "De-Groot",
        "De-Jong",
        "Dekker",
        "Delgado",
        "Deng",
        "Devi",
        "Diaz",
        "Dijkstra",
        "Ding",
        "Dlamini",
        "Dominguez",
        "Dong",
        "Du-Plessis",
        "Dube",
        "Duda",
        "Dudek",
        "Dumont",
        "Edwards",
        "Egorov",
        "Egorova",
        "Einarsson",
        "Elbaz",
        "Eliyahu",
        "Ellis",
        "Emmanuel",
        "Endo",
        "Espinoza",
        "Esteban",
        "Evans",
        "Eze",
        "Fan",
        "Fang",
        "Feldman",
        "Feng",
        "Fernandez",
        "Fiala",
        "Fischer",
        "Flores",
        "Friedman",
        "Frolova",
        "Fu",
        "Fuchs",
        "Fujii",
        "Fujita",
        "Fukuda",
        "Gaby",
        "Gao",
        "Garba",
        "Garcia",
        "Garrido",
        "Garza",
        "Ghosh",
        "Gil",
        "Golan",
        "Goldstein",
        "Gomez",
        "Gonzales",
        "Gonzalez",
        "Goto",
        "Govender",
        "Grabowski",
        "Green",
        "Greenberg",
        "Griffiths",
        "Gu",
        "Guerrero",
        "Gumede",
        "Gunnarsson",
        "Guo",
        "Gupta",
        "Gutierrez",
        "Hahn",
        "Hall",
        "Han",
        "Haraldsson",
        "Harle",
        "Harle-Cowan",
        "Harris",
        "Harrison",
        "Hartmann",
        "Haruna",
        "Hasegawa",
        "Hashimoto",
        "Hasna",
        "Hassan",
        "Hauksson",
        "Hayashi",
        "He",
        "Helgason",
        "Hen",
        "Hendriks",
        "Herbulot",
        "Hernandez",
        "Herrera",
        "Herrmann",
        "Hill",
        "Hoekstra",
        "Hoffmann",
        "Hofmann",
        "Hongthong",
        "Hopkins",
        "Howells",
        "Hu",
        "Huang",
        "Huber",
        "Hughes",
        "Huisman",
        "Hussein",
        "Ibrahim",
        "Idris",
        "Iglesias",
        "Igwe",
        "Ikeda",
        "Inoue",
        "Isa",
        "Isaac",
        "Isah",
        "Ishii",
        "Ishikawa",
        "Ito",
        "Ivanov",
        "Ivanova",
        "Jabarin",
        "Jackson",
        "Jacobs",
        "Jadhav",
        "Jakubowski",
        "James",
        "Jankowski",
        "Jansen",
        "Janssen",
        "Jaworski",
        "Jenkins",
        "Jia",
        "Jiang",
        "Jimenez",
        "Jin",
        "John",
        "Johnson",
        "Jones",
        "Joseph",
        "Juma",
        "Jung",
        "Kaczmarek",
        "Kaiser",
        "Kamau",
        "Karanja",
        "Kariuki",
        "Karlsson",
        "Kato",
        "Katz",
        "Kaur",
        "Keller",
        "Khan",
        "Khatib",
        "Khatoon",
        "Khatun",
        "Khoury",
        "Khoza",
        "Khumalo",
        "Kibet",
        "Kikuchi",
        "Kim",
        "Kimani",
        "Kimura",
        "King",
        "Kjartansson",
        "Klein",
        "Kobayashi",
        "Koch",
        "Koech",
        "Kok",
        "Kondo",
        "Kongkaeo",
        "Koster",
        "Kovalenko",
        "Kowalczyk",
        "Kowalski",
        "Kozlov",
        "Kozlova",
        "Krause",
        "Krawczyk",
        "Kristinsson",
        "Kubiak",
        "Kucharski",
        "Kuipers",
        "Kumar",
        "Kumari",
        "Kuznetsov",
        "Kuznetsova",
        "Kwiatkowski",
        "Lal",
        "Lang",
        "Langat",
        "Lange",
        "Lavyan",
        "Lawal",
        "Lebedeva",
        "Lee",
        "Lehmann",
        "Levy",
        "Lewandowski",
        "Lewis",
        "Li",
        "Liang",
        "Liao",
        "Lim",
        "Lin",
        "Lis",
        "Liu",
        "Llewellyn",
        "Lloyd",
        "Lopez",
        "Lozano",
        "Lu",
        "Luo",
        "Ma",
        "Maas",
        "Mabaso",
        "Macharia",
        "Maciejewski",
        "Maeda",
        "Magomedov",
        "Mahagna",
        "Mahato",
        "Mahlangu",
        "Mahto",
        "Maier",
        "Maina",
        "Majewski",
        "Makarov",
        "Makarova",
        "Malinowski",
        "Malkah",
        "Maluleke",
        "Mandal",
        "Marciniak",
        "Marek",
        "Marin",
        "Martin",
        "Martinez",
        "Masarweh",
        "Maseko",
        "Mathebula",
        "Matsumoto",
        "Matthews",
        "Mayer",
        "Mazibuko",
        "Mazur",
        "Mazurek",
        "Mbatha",
        "Medina",
        "Meier",
        "Meijer",
        "Mendoza",
        "Meng",
        "Meyer",
        "Mhamid",
        "Mhlongo",
        "Michalak",
        "Michalski",
        "Mikhaylov",
        "Mikhaylova",
        "Mishra",
        "Mitchell",
        "Mizrahi",
        "Mkhize",
        "Mofokeng",
        "Mohamed",
        "Mohammed",
        "Mokoena",
        "Molefe",
        "Molina",
        "Mondal",
        "Moore",
        "Mor",
        "Morales",
        "Moreno",
        "Morgan",
        "Mori",
        "Morozov",
        "Morozova",
        "Morris",
        "Moshe",
        "Mthembu",
        "Mthethwa",
        "Mtshali",
        "Muhammad",
        "Muhammadu",
        "Muhammed",
        "Mulder",
        "Murakami",
        "Musa",
        "Mustapha",
        "Muthoni",
        "Mutua",
        "Mutuku",
        "Mwangi",
        "Naidoo",
        "Nakajima",
        "Nakamura",
        "Nakano",
        "Navarro",
        "Nayak",
        "Ndlovu",
        "Nel",
        "Neumann",
        "Ngcobo",
        "Ngobeni",
        "Ngubane",
        "Nguyen",
        "Ngwenya",
        "Nikitina",
        "Nikolaev",
        "Nikolaeva",
        "Njeri",
        "Njoroge",
        "Njuguna",
        "Nkosi",
        "Novikov",
        "Novikova",
        "Nowak",
        "Nowakowski",
        "Nowicki",
        "Ntuli",
        "Nxumalo",
        "Nyambura",
        "Oakley",
        "Ochieng",
        "Odhiambo",
        "Ogawa",
        "Ohana",
        "Ohayon",
        "Ojo",
        "Okada",
        "Okafor",
        "Okeke",
        "Okon",
        "Okoro",
        "Okoth",
        "Omar",
        "Omer",
        "Omondi",
        "Ono",
        "Onyango",
        "Ortega",
        "Ortiz",
        "Ostrowski",
        "Ota",
        "Otieno",
        "Ouma",
        "Owen",
        "Owino",
        "Pal",
        "Pan",
        "Panya",
        "Paramar",
        "Parker",
        "Parry",
        "Paswan",
        "Patel",
        "Patil",
        "Pavlov",
        "Pavlova",
        "Pawlak",
        "Peeters",
        "Peng",
        "Peretz",
        "Perez",
        "Peter",
        "Peters",
        "Petrov",
        "Petrova",
        "Pfeiffer",
        "Phillips",
        "Photsi",
        "Pietrzak",
        "Pillay",
        "Piotrowski",
        "Popov",
        "Popova",
        "Powell",
        "Prasad",
        "Pretorius",
        "Price",
        "Prieto",
        "Prins",
        "Pritchard",
        "Pugh",
        "Qiu",
        "Rabiu",
        "Radebe",
        "Ragnarsson",
        "Ram",
        "Ramirez",
        "Ramos",
        "Rani",
        "Rathod",
        "Ray",
        "Rees",
        "Ren",
        "Reuben",
        "Reyes",
        "Richards",
        "Richardson",
        "Richter",
        "Rivera",
        "Roberts",
        "Robinson",
        "Rodriguez",
        "Rogers",
        "Romanov",
        "Romanova",
        "Romero",
        "Rosenberg",
        "Rotich",
        "Rowlands",
        "Roy",
        "Rubio",
        "Ruiz",
        "Rungrueang",
        "Rumbelow",
        "Rutkowski",
        "Sadowski",
        "Saeli",
        "Saelim",
        "Saengthong",
        "Saetan",
        "Saetang",
        "Saeueng",
        "Sah",
        "Saha",
        "Sahu",
        "Saidu",
        "Saito",
        "Sakai",
        "Sakamoto",
        "Salazar",
        "Salisu",
        "Samuel",
        "Sanchez",
        "Sangthong",
        "Sani",
        "Santiago",
        "Santos",
        "Sanz",
        "Sarkar",
        "Sasaki",
        "Sato",
        "Sawicki",
        "Schmid",
        "Schmidt",
        "Schmitt",
        "Schmitz",
        "Schneider",
        "Scholz",
        "Schouten",
        "Schulz",
        "Schulze",
        "Schwartz",
        "Schwarz",
        "Scott",
        "Segel",
        "Sekh",
        "Sergeeva",
        "Serrano",
        "Shaikh",
        "Shalom",
        "Shapiro",
        "Sharabi",
        "Sharma",
        "Shaw",
        "Shehu",
        "Shemesh",
        "Shevchenko",
        "Shi",
        "Shimizu",
        "Sibiya",
        "Sichantha",
        "Sikora",
        "Simiyu",
        "Singh",
        "Sisuk",
        "Sithole",
        "Sitwat",
        "Smee",
        "Smirnov",
        "Smirnova",
        "Smit",
        "Smith",
        "Smits",
        "Sokolov",
        "Sokolova",
        "Sombun",
        "Song",
        "Soto",
        "Smoakley",
        "Starr",
        "Stepanov",
        "Stepanova",
        "Su",
        "Suad",
        "Suarez",
        "Suissa",
        "Sukkasem",
        "Sulaiman",
        "Suleiman",
        "Sun",
        "Sunday",
        "Suwan",
        "Suzuki",
        "Sveinsson",
        "Svoboda",
        "Szewczyk",
        "Takahashi",
        "Takeuchi",
        "Tal",
        "Tan",
        "Tanaka",
        "Tang",
        "Taylor",
        "Thakur",
        "Thomas",
        "Thompson",
        "Thongdi",
        "Thongkham",
        "Thongsuk",
        "Tian",
        "Tomaszewski",
        "Torres",
        "Tshabalala",
        "Turner",
        "Udo",
        "Ueda",
        "Umar",
        "Umaru",
        "Usman",
        "Vaknin",
        "Valdez",
        "Van-Beek",
        "Van-Dam",
        "Van-den-Berg",
        "Van-der-Heijden",
        "Van-der-Linden",
        "Van-Dijk",
        "Vargas",
        "Vasilev",
        "Vasileva",
        "Vazquez",
        "Vega",
        "Venter",
        "Verhoeven",
        "Vermeulen",
        "Visser",
        "Volkov",
        "Volkova",
        "Vos",
        "Wafula",
        "Wagner",
        "Wairimu",
        "Walczak",
        "Walker",
        "Walter",
        "Walters",
        "Wambua",
        "Wambui",
        "Wang",
        "Wangui",
        "Wanjala",
        "Wanjiku",
        "Ward",
        "Watanabe",
        "Watkins",
        "Watson",
        "Weber",
        "Wei",
        "Wekesa",
        "Wen",
        "Werner",
        "White",
        "Wieczorek",
        "Wilk",
        "Willems",
        "Williams",
        "Wilson",
        "Witkowski",
        "Wojciechowski",
        "Wolf",
        "Wood",
        "Wright",
        "Wu",
        "Xiao",
        "Xie",
        "Xu",
        "Yaakv",
        "Yadav",
        "Yahaya",
        "Yakovleva",
        "Yakubu",
        "Yamada",
        "Yamaguchi",
        "Yamamoto",
        "Yamashita",
        "Yamazaki",
        "Yan",
        "Yang",
        "Yao",
        "Ye",
        "Yin",
        "Yosef",
        "Yoshida",
        "Young",
        "Yu",
        "Yuan",
        "Yusuf",
        "Zajac",
        "Zakharov",
        "Zakharova",
        "Zalewski",
        "Zawadzki",
        "Zaytseva",
        "Zhang",
        "Zhao",
        "Zheng",
        "Zhong",
        "Zhou",
        "Zhu",
        "Zimmermann",
        "Zoabi",
        "Zulu",
        "Zwane"
    ]
};
function randLastName(options) {
    var _options$withAccents;
    const withAccents = (_options$withAccents = options == null ? void 0 : options.withAccents) != null ? _options$withAccents : randBoolean();
    const names = withAccents ? data$1e["withAccents"] : data$1e["withoutAccents"];
    return fake(names, options);
}
function randFormattedName(options) {
    var _options$firstName, _options$lastName;
    let separator = "";
    const firstName = (_options$firstName = options == null ? void 0 : options.firstName) != null ? _options$firstName : randFirstName({
        withAccents: false
    });
    const lastName = (_options$lastName = options == null ? void 0 : options.lastName) != null ? _options$lastName : randLastName({
        withAccents: false
    });
    if (!(options != null && options.nameSeparator)) {
        separator = fake([
            ".",
            "-",
            "_",
            "+",
            ""
        ]);
    } else if (options.nameSeparator !== "none") {
        separator = options.nameSeparator;
    }
    let name = `${firstName} ${lastName}`.replace(" ", separator);
    if (randBoolean()) {
        name += randNumber({
            min: 1,
            max: 1e3
        });
    }
    return name.toLowerCase();
}
function randEmail(options) {
    const factory = ()=>{
        const emailProvider = (options == null ? void 0 : options.provider) || randEmailProvider();
        const formattedName = randFormattedName(options);
        const emailSuffix = (options == null ? void 0 : options.suffix) || randDomainSuffix();
        return `${formattedName}@${emailProvider}.${emailSuffix}`;
    };
    return fake(factory, options);
}
var data$16 = {
    china: [
        "Peking roasted duck",
        "Kung pao chicken",
        "Sweet and sour pork",
        "Hot pot",
        "Dim sum",
        "Dumplings",
        "Ma po tofu",
        "Char siu",
        "Chicken chow mein",
        "Beef chow mein",
        "vegetable chow mein",
        "Chicken fried rice",
        "Beef fried rice",
        "Vegetable fried Rice",
        "Special fried Rice",
        "Sichuan pork",
        "Xiaolongbao",
        "Zhajiangmian",
        "Wonton soup",
        "Sweet and sour pork",
        "Duck spring Rolls",
        "Vegetable spring Rolls",
        "Wonton",
        "Peking duck",
        "Lamb hot pot",
        "Spicy crayfish",
        "Guilin rice noodles",
        "Lanzhou hand-pulled noodles",
        "Steamed crab",
        "Shredded pork with garlic sauce",
        "Red braised pork",
        "Sweet and sour Ribs",
        "Xinjiang",
        "Braised pork with vermicelli"
    ],
    italy: [
        "Butternut squash risotto",
        "Mushroom risotto",
        "Beetroot risotto",
        "Courgette risotto",
        "Pizza",
        "Gnocchi",
        "Spaghetti bolognese",
        "Spaghetti carbonara",
        "Pesto alla Genovese",
        "Beef lasagne",
        "Vegetable lasagne",
        "Gelato",
        "Prosciutto di Parma",
        "Ribollita",
        "Bagna cauda",
        "Polenta",
        "Tortelli and ravioli",
        "Focaccia",
        "Garlic bread",
        "Arancini",
        "Il tartufo",
        "Panzerotto fritto",
        "Fiorentina",
        "Minestrone",
        "Frico",
        "Arrosticini",
        "Olive ascolante",
        "Fritto misto piemontes",
        "Tiramis\xF9"
    ],
    india: [
        "Biryani",
        "Dosa",
        "Tandoori chicken",
        "Samosas",
        "Chaat",
        "Plain naan",
        "Garlic naan",
        "Pilau rice",
        "Steamed rice",
        "Chicken madras",
        "Vegetable madras",
        "Chicken vindaloo",
        "Chicken jalfrezi",
        "Chicken roghan josh",
        "Lamb roghan josh",
        "Beef roghan josh",
        "Butter chicken",
        "Dosa",
        "Gulab jamun",
        "Chicken korma",
        "Mutter paneer",
        "Papadum",
        "Paratha",
        "Raita",
        "Saag paneer",
        "Tandoori chicken",
        "Chicken tikka masala",
        "Pakora",
        "Dal",
        "Chapati",
        "Pasanda",
        "Aloo gobi",
        "Kofta",
        "Chicken makhani",
        "Paneer naan",
        "Chana Aloo Curry"
    ],
    mexico: [
        "Chilaquiles",
        "Pozole",
        "Tacos al pastor",
        "Tostadas",
        "Chiles en nogada",
        "Elote",
        "Enchiladas",
        "Mole",
        "Guacamole",
        "Tamales",
        "Huevos rancheros",
        "Machaca",
        "Discada",
        "Beef Burrito",
        "Chicken Burrito",
        "Pozole de pollo o duajolote",
        "Menudo",
        "Cochinita pibil",
        "Tamale",
        "Quesadilla",
        "Frijoles puercos",
        "Chile en nogada",
        "Esquites",
        "Alegria de amaranto",
        "Pipi\xE1n",
        "Aguachile",
        "Ceviche",
        "Pescado zarandeado",
        "Camarones a la diabla",
        "Birria de chivo",
        "Tlayuda",
        "Guacamole con chapulines",
        "Flautas",
        "Torta Ahogada",
        "Carnitas",
        "Caldo Azteca",
        "Gorditas de Nata"
    ],
    japan: [
        "Sushi",
        "Udon",
        "Tofu",
        "Tempura",
        "Yakitori",
        "Sashimi",
        "Ramen",
        "Donburi",
        "Natto",
        "Oden",
        "Tamagoyaki",
        "Soba",
        "Tonkatsu",
        "Kashipan",
        "Sukiyaki",
        "Miso soup",
        "Okonomiyaki",
        "Mentaiko",
        "Nikujaga",
        "Unagi no kabayaki",
        "Shabu Shabu",
        "Onigiri",
        "Gyoza",
        "Takoyaki",
        "aiseki ryori",
        "Edamame",
        "Yakisoba",
        "Chawanmushi",
        "Wagashi"
    ],
    france: [
        "Foie gras",
        "Hu\xEEtres",
        "Cassoulet",
        "Poulet basquaise",
        "Escargots au beurre persill\xE9",
        "Mouclade charentaise",
        "Galettes bretonnes",
        "Flemish carbonnade",
        "Quiche lorraine",
        "Raclette",
        "Cheese fondue",
        "Beef fondue",
        "Gratin dauphinois",
        "Tartiflette",
        "Bouillabaisse",
        "Ratatouille",
        "Boeuf bourguignon",
        "Blanquette de veau",
        "Pot-au-feu",
        "Coq-au-vin",
        "Hachis parmentier",
        "Steak tartare",
        "Choucroute",
        "Souffl\xE9 au fromage",
        "Cuisses de grenouilles",
        "Soupe \xE0 l\u2019oignon",
        "Baguette",
        "Croissant",
        "French cheeses",
        "Fondant au chocolat",
        "Tarte tatin",
        "Macarons",
        "Cr\xE8me br\xFBl\xE9e",
        "\xCEle flottante",
        "Profiteroles",
        "Pain au chocolat"
    ],
    lebanon: [
        "Kibbeh",
        "Kafta",
        "Kanafeh",
        "Hummus",
        "Rice pilaf",
        "Fattoush",
        "Manakish",
        "Tabbouleh",
        "Sfeeha",
        "Fattoush",
        "Labneh",
        "Muhammara",
        "Lahm bi ajin",
        "Kaak",
        "Chanklich",
        "Mssabaha",
        "Shawarma",
        "Kebbe",
        "Falafel",
        "Halewit el jeben",
        "Namoura",
        "Maamoul",
        "Foul mdammas",
        "Balila",
        "Kawarma",
        "Fattouch"
    ],
    thailand: [
        "Pad kra pao moo",
        "Tom kha gai",
        "Khao Pad",
        "Chicken pad Thai",
        "Vegetable pad Thai",
        "Moo satay",
        "Tom yum goong",
        "Khao niew mamuang",
        "Kai yad sai",
        "Khao soi",
        "Pad see ew",
        "Laab moo",
        "Gaeng panang",
        "Gai pad med ma muang",
        "Som tam",
        "Poh pia tod",
        "Gaeng massaman",
        "Pla kapung nueng manao",
        "Tod mun pla",
        "Gaeng ped",
        "Gaeng garee",
        "Gaeng keow wan",
        "Moo ping",
        "Durian",
        "Sai ooah",
        "Hoy tod",
        "Kuay teow reua",
        "Mu kratha",
        "Kao ka moo",
        "Yam nua"
    ],
    greece: [
        "Moussaka",
        "Papoutsakia",
        "Pastitsio",
        "Souvlaki",
        "Soutzoukakia",
        "Stifado",
        "Tomatokeftedes",
        "Tzatziki",
        "Kolokithokeftedes",
        "Giouvetsi",
        "Choriatiki",
        "Kleftiko",
        "Gemista",
        "Fasolada",
        "Bougatsa",
        "Tiropita",
        "Spanakopita",
        "Feta Cheese with Honey",
        "Horta",
        "Tirokroketes",
        "Briam",
        "Saganaki",
        "Gigantes",
        "Dolmades",
        "Fasolatha",
        "Koulouri",
        "Loukoumades",
        "Gyros",
        "Galaktoboureko",
        "Baklava"
    ],
    turkey: [
        "\u015Ei\u015F kebap",
        "D\xF6ner",
        "K\xF6fte",
        "Pide",
        "Kumpir",
        "Meze",
        "Mant\u0131",
        "Lahmacun",
        "Menemen",
        "\u015Ei\u015F kebap",
        "\u0130skender kebab",
        "Corba",
        "Kuzu tandir",
        "\xC7i\u011F K\xF6fte",
        "Pilav",
        "Yaprak sarma",
        "Dolma",
        "\u0130mam bay\u0131ld\u0131",
        "Borek",
        "Durum",
        "Kumpir",
        "Balik ekmek",
        "Simit",
        "Kunefe",
        "Baklava",
        "Lokum",
        "Halva",
        "Mozzaik pasta",
        "G\xFClla\xE7",
        "Mercimek K\xF6ftesi",
        "Haydari",
        "Tursu suyu",
        "Kahvalti",
        "Kazan dibi",
        "Hunkar begendi",
        "Islak burgers",
        "Salep",
        "Yogurtlu kebab"
    ],
    spain: [
        "Tortilla de patatas",
        "Fabada asturiana",
        "Cal\xE7ots",
        "Boquerones al vinagre",
        "Empanada gallega",
        "Paella",
        "Gazpacho",
        "Gachas",
        "Migas",
        "Bocadillo de calamares",
        "Pulpo a feira",
        "Caldo gallego",
        "Lentejas con chorizo",
        "Cocido madrile\xF1o",
        "Cachopo",
        "Caracoles"
    ],
    venezuela: [
        "Pabell\xF3n criollo",
        "Arepa",
        "Mondongo",
        "Empanadas",
        "Quesillo",
        "Chicha andina",
        "Teque\xF1os",
        "Cachapa",
        "Hallaca",
        "Perico",
        "Pasticho",
        "Mandocas",
        "Caraotas negras",
        "Patacones",
        "Dulce de leche",
        "Pan de Jam\xF3n"
    ],
    chile: [
        "Humitas",
        "Empanadas",
        "Porotos con riendas",
        "Completos",
        "Manjar",
        "Cordero al palo",
        "Pastel de choclo",
        "Mote con huesillos",
        "Sopaipillas",
        "Curanto"
    ],
    argentina: [
        "Milanesas",
        "Empanadas",
        "Pizza fugazeta",
        "Asado",
        "Choripan",
        "Bondiola",
        "Bife de chorizo"
    ],
    colombia: [
        "Bandeja paisa",
        "Chuleta valluna",
        "Sancocho trif\xE1sico",
        "Empanada valluna",
        "Salpicon de frutas",
        "Pastel de garbanzo",
        "Ajiaco",
        "Arepas",
        "Arroz de lisa",
        "Sancocho",
        "Pan de bono",
        "Cuchuco",
        "Oblea",
        "Cazuela de mariscos",
        "Pan de yuca",
        "Bollo Limpio",
        "Almoj\xE1bana",
        "Empanadas",
        "Arroz con Coco",
        "Sopa de mondongo",
        "Cazuela de Mariscos",
        "Arroz con Pollo",
        "Arepa de Huevo",
        "Mote de Queso"
    ],
    ecuador: [
        "Encebollado",
        "Ceviche",
        "Tigrillo",
        "Bolon de verde",
        "Llapingacho",
        "Mote pillo",
        "Locro de papa",
        "Churrasco"
    ],
    peru: [
        "Ceviche",
        "Arroz con pollo",
        "Aji de gallina",
        "Llunca de gallina"
    ],
    "el salvador": [
        "Pupusa",
        "Sopa de patas",
        "Rigua",
        "Flor de izote con huevo",
        "Gallo en chicha"
    ],
    romania: [
        "Sarmale",
        "Mici",
        "Pomana porcului",
        "Ciorb\u0103 de fasole cu ciolan",
        "Ciorb\u0103 de burt\u0103",
        "Ciorb\u0103 r\u0103d\u0103u\u021Bean\u0103",
        "Pl\u0103cint\u0103 cu br\xE2nz\u0103",
        "Ciorb\u0103 de potroace",
        "M\u0103m\u0103lig\u0103 cu br\xE2nz\u0103 \u0219i sm\xE2nt\xE2n\u0103",
        "Tochitur\u0103",
        "Piftie",
        "Iahnie de fasole",
        "Sl\u0103nin\u0103 afumat\u0103",
        "C\xE2rna\u021Bi afuma\u021Bi",
        "Varz\u0103 a la Cluj",
        "Gula\u0219 de cartofi cu afum\u0103tur\u0103",
        "Cozonac de cas\u0103",
        "Ciorb\u0103 ardeleneasc\u0103 de porc",
        "Mucenici moldovene\u0219ti",
        "Salat\u0103 de boeuf",
        "Dovleac copt",
        "Papana\u0219i cu br\xE2nz\u0103 de vac\u0103 \u0219i afine",
        "Drob de miel",
        "P\xE2rjoale moldovene\u0219ti",
        "Zacusc\u0103 de vinete",
        "Zacusc\u0103 de fasole",
        "Turt\u0103 dulce",
        "Cl\u0103titele cu gem",
        "Cl\u0103titele cu br\xE2nza de vac\u0103",
        "Balmo\u0219",
        "Cozonac",
        "Chiftele"
    ]
};
var _Object$keys$1;
(_Object$keys$1 = Object.keys(data$16)) == null ? void 0 : _Object$keys$1.length;
function randUuid(options) {
    const v4options = {
        random: randNumber({
            min: 0,
            max: 255,
            length: 16
        })
    };
    return fake(()=>v4(v4options), options);
}
var data$l = {
    olympic: [
        "Archery",
        "Artistic Gymnastics",
        "Artistic Swimming",
        "Athletics",
        "Badminton",
        "Baseball Softball",
        "Basketball",
        "Beach Volleyball",
        "BMX Freestyle",
        "BMX Racing",
        "Boxing",
        "Kayak Flatwater",
        "Kayak Slalom",
        "Diving",
        "Equestrian",
        "Fencing",
        "Football",
        "Golf",
        "Handball",
        "Hockey",
        "Judo",
        "Karate",
        "Marathon Swimming",
        "Modern Pentathlon",
        "Mountain Bike",
        "Rhythmic Gymnastics",
        "Road Cycling",
        "Rowing",
        "Rugby",
        "Sailing",
        "Shooting",
        "Skateboarding",
        "Sport Climbing",
        "Surfing",
        "Swimming",
        "Table Tennis",
        "Taekwondo",
        "Tennis",
        "Track Cycling",
        "Trampoline",
        "Triathlon",
        "Volleyball",
        "Water Polo",
        "Weightlifting",
        "Wrestling"
    ],
    winterOlympic: [
        "Alpine Skiing",
        "Biathlon",
        "Bobsleigh",
        "Cross-Country Skiing",
        "Curling",
        "Figure Skating",
        "Freestyle Skiing",
        "Ice Hockey",
        "Luge",
        "Nordic Combined",
        "Short Track Speed Skating",
        "Skeleton",
        "Ski Jumping",
        "Snowboard",
        "Speed Skating"
    ],
    outdoor: [
        "Archery",
        "Athletics",
        "Badminton",
        "Baseball",
        "Basketball",
        "Bowling",
        "Boxing",
        "Camping",
        "Canoeing",
        "Climbing",
        "Cricket",
        "Curling",
        "Cycling",
        "Equestrian",
        "Fencing",
        "Football",
        "Golf",
        "Gymnastics",
        "Handball",
        "Hang Gliding",
        "High Jumping",
        "Hockey",
        "Ice Hockey",
        "Judo",
        "Karate",
        "Kite Flying",
        "Monkey Bars",
        "Motorsports",
        "Netball",
        "Rowing",
        "Rugby",
        "Running",
        "Sailing",
        "Skateboarding",
        "Slide",
        "Snow Skiing",
        "Soccer",
        "Street Hockey",
        "Surfing",
        "Swimming",
        "Table Tennis",
        "Tennis",
        "Trekking",
        "Triathlon",
        "Volleyball",
        "Weightlifting",
        "Wrestling"
    ]
};
var _Object$keys;
(_Object$keys = Object.keys(data$l)) == null ? void 0 : _Object$keys.length;
({
    bash: '#!/bin/bash\n\nmove()\n{\n  local n="$1"\n  local from="$2"\n  local to="$3"\n  local via="$4"\n\n  if [[ "$n" == "1" ]]\n  then\n    echo "Move disk from pole $from to pole $to"\n  else\n    move $(($n - 1)) $from $via $to\n    move 1 $from $to $via\n    move $(($n - 1)) $via $to $from\n  fi\n}\n\nmove $1 $2 $3 $4',
    c: '#include <stdio.h>\n\nvoid move(int n, int from, int via, int to) {\n   if (n > 1) {\n      move(n - 1, from, to, via);\n      printf("Move disk from pole %d to pole %d\\n", from, to);\n      move(n - 1, via, from, to);\n   } else {\n      printf("Move disk from pole %d to pole %d\\n", from, to);\n   }\n}\nint main() {\n   move(4, 1, 2, 3);\n   return 0;\n}',
    "c#": 'public void move(int n, int from, int to, int via) {\n  if (n == 1) {\n    System.Console.WriteLine("Move disk from pole " + from + " to pole " + to);\n  } else {\n    move(n - 1, from, via, to);\n    move(1, from, to, via);\n    move(n - 1, via, to, from);\n  }\n}',
    "c++": 'void move(int n, int from, int to, int via) {\n  if (n == 1) {\n    std::cout << "Move disk from pole " << from << " to pole " << to << std::endl;\n  } else {\n    move(n - 1, from, via, to);\n    move(1, from, to, via);\n    move(n - 1, via, to, from);\n  }\n}',
    css: ".hover-rotate {\n  overflow: hidden;\n  margin: 8px;\n  min-width: 240px;\n  max-width: 320px;\n  width: 100%;\n}\n\n.hover-rotate img {\n  transition: all 0.3s;\n  box-sizing: border-box;\n  max-width: 100%;\n}\n\n.hover-rotate:hover img {\n  transform: scale(1.3) rotate(5deg);\n}",
    go: "func fib(a int) int {\n  if a < 2 {\n      return a\n  }\n  return fib(a - 1) + fib(a - 2)\n}",
    html: '<form action="http://maps.google.com/maps" method="get" target="_blank">\n  <label for="saddr">Enter your location</label>\n  <input type="text" name="saddr" />\n  <input type="hidden" name="daddr" value="350 5th Ave New York, NY 10018 (Empire State Building)" />\n  <input type="submit" value="Get directions" />\n</form>',
    java: 'public void move(int n, int from, int to, int via) {\n  if (n == 1) {\n      System.out.println("Move disk from pole " + from + " to pole " + to);\n  } else {\n      move(n - 1, from, via, to);\n      move(1, from, to, via);\n      move(n - 1, via, to, from);\n  }\n}',
    javascript: 'function move(n, a, b, c) {\n  if (n > 0) {\n    move(n - 1, a, c, b);\n    console.log("Move disk from " + a + " to " + c);\n    move(n - 1, b, a, c);\n  }\n}\nmove(4, "A", "B", "C");',
    php: 'function move($n,$from,$to,$via) {\n  if ($n === 1) {\n    print("Move disk from pole $from to pole $to");\n  } else {\n    move($n-1,$from,$via,$to);\n    move(1,$from,$to,$via);\n    move($n-1,$via,$to,$from);\n  }\n}',
    python: 'def hanoi(ndisks, startPeg=1, endPeg=3):\n  if ndisks:\n    hanoi(ndisks - 1, startPeg, 6 - startPeg - endPeg)\n    print "Move disk %d from peg %d to peg %d" % (ndisks, startPeg, endPeg)\n    hanoi(ndisks - 1, 6 - startPeg - endPeg, endPeg)\n\nhanoi(ndisks=4)',
    rust: 'fn move_(n: i32, from: i32, to: i32, via: i32) {\n  if n > 0 {\n      move_(n - 1, from, via, to);\n      println!("Move disk from pole {} to pole {}", from, to);\n      move_(n - 1, via, to, from);\n  }\n}\n \nfn main() {\n  move_(4, 1,2,3);\n}',
    sql: "SELECT *\nFROM   call\nORDER  BY call.employee_id ASC,\n          call.start_time ASC;",
    swift: `func hanoi(n: Int, a: String, b: String, c: String) {
  if n > 0 {
    hanoi(n - 1, a: a, b: c, c: b)
    print("Move disk from \\\\(a) to \\\\(c)")
    hanoi(n - 1, a: b, b: a, c: c)
  }
}
  
hanoi(4, a: "A", b: "B", c: "C")';`
});
var OracleResponse;
(function(OracleResponse) {
    OracleResponse["YES"] = "YES";
    OracleResponse["NO"] = "NO";
    OracleResponse["MAYBE"] = "MAYBE";
})(OracleResponse || (OracleResponse = {}));
function strHashcode(text) {
    return text.split('').reduce((acc, curr, i)=>acc + curr.charCodeAt(0) * (1000 + i), 0);
}
function normalizeQuestion(question) {
    return question.replaceAll(/[-:;_ \(\)\[\],.\t\n]/g, "").toLowerCase();
}
const MAX_NAMES_GENERATED = 1000;
const RANDOM_ACTIONS = {
    int: (min, max)=>Math.floor(Math.random() * (max - min + 1)) + min,
    decimal: (min, max)=>Math.random() * (max - min) + min,
    email: randEmail,
    uuid: randUuid,
    names: (total, gender)=>{
        const names = [];
        if (total > 1000) {
            total = MAX_NAMES_GENERATED;
        } else if (total < 1) {
            total = 1;
        }
        for(let index = 0; index < total; index++){
            const genderName = gender || (Math.random() > 0.5 ? 'male' : 'female');
            const firstName = randFirstName({
                gender
            });
            const lastName = randLastName({});
            names.push({
                gender: genderName,
                firstName,
                lastName
            });
        }
        return names;
    },
    oracle: (type, question)=>{
        let num;
        if (question) {
            const questionHash = strHashcode(normalizeQuestion(question));
            num = questionHash % 1000 / 1000.0 * 3;
        } else {
            num = RANDOM_ACTIONS.decimal(0.0, 3.0);
        }
        switch(type){
            case 'YES_NO':
                return num > 1.5 ? OracleResponse.NO : OracleResponse.YES;
            case 'YES_NO_MAYBE':
                return num >= 2.0 ? OracleResponse.NO : num < 1.0 ? OracleResponse.YES : OracleResponse.MAYBE;
            default:
                throw new Error(`Operation not supported ${type}`);
        }
    }
};
const randomRoutes = new Hono();
randomRoutes.get("/", (c)=>{
    return c.text('Random commands');
});
randomRoutes.get("/number/:type", (c)=>{
    const input = getCommandInput(c, {
        validActions: [
            'int',
            'decimal'
        ],
        paramsName: [
            'min',
            'max'
        ],
        mandatoryParams: [],
        actionParamName: 'type'
    });
    const randFn = RANDOM_ACTIONS[input.action];
    input.params.min ??= 0.0;
    input.params.max ??= +input.params.min + 1.0;
    const result = randFn(+input.params.min, +input.params.max);
    return c.json({
        result,
        input
    });
});
randomRoutes.get("/oracle", (c)=>{
    const input = getCommandInput(c, {
        paramsName: [
            'type',
            'question'
        ],
        mandatoryParams: [
            'type'
        ],
        action: 'oracle'
    });
    input.params.type = input.params.type.toUpperCase();
    const result = RANDOM_ACTIONS[input.action](input.params.type, input.params.question);
    return c.json({
        result,
        input
    });
});
randomRoutes.get("/names", (c)=>{
    const input = getCommandInput(c, {
        paramsName: [
            'total',
            'gender'
        ],
        action: 'names'
    });
    const result = RANDOM_ACTIONS[input.action](input.params.total, input.params.gender);
    return c.json({
        result,
        input
    });
});
randomRoutes.get("/:action", (c)=>{
    const input = getCommandInput(c, {
        validActions: [
            'email',
            'uuid'
        ],
        paramsName: []
    });
    const result = RANDOM_ACTIONS[input.action]();
    return c.json({
        result,
        input
    });
});
const app = new Hono();
app.use('*', async (c, next)=>{
    const start = performance.now();
    await next();
    const elapsed = performance.now() - start;
    c.res.headers.set('X-Response-Time', `${(elapsed / 1000).toFixed(2)}ms`);
});
app.use('*', cors());
app.use('*', async (c, next)=>{
    const pretty = !!(c.req.query('_pretty') || c.req.query('_pretty') === '');
    c.pretty(pretty, 2);
    await next();
});
app.get("/", async (c)=>{
    return c.json({
        server: "H3lp3r API",
        version: await getVersion()
    });
});
app.get("/ip", (c)=>{
    let remoteIp = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || c.req.header('cf-connecting-ip') || c.env.remoteAddr.hostname || 'unknown';
    console.log(c);
    remoteIp = remoteIp.split(',')[0].trim();
    return c.text(remoteIp);
});
app.onError((err, c)=>{
    const status = c.get('response-status') || 500;
    return c.json({
        error: err.message || err.toString(),
        path: getPathFromURL1(c.req.url),
        params: c.req.query()
    }, status);
});
app.route('/random', randomRoutes);
app.route('/hash', hashRoutes);
app.route('/base', baseRoutes);
app.route('/convert', convRoutes);
const port = +(Deno.env.get('PORT') || 3003);
const hostname = Deno.env.get('HOST') || '0.0.0.0';
serve(app.fetch, {
    port,
    hostname
});
const __default5 = {
    port,
    host: hostname,
    fetch: app.fetch
};
export { __default5 as default };
